{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur Tock : une plateforme conversationnelle ouverte \u00b6 Tock ( The Open Conversation Kit ) est une plateforme compl\u00e8te pour construire des agents conversationnels - souvent appel\u00e9s bots . Contrairement \u00e0 la plupart des solutions conversationnelles, Tock ne d\u00e9pend pas d'API tierces, bien qu'il soit possible d'en int\u00e9grer. L'utilisateur choisit les composants qu'il embarque et peut ainsi conserver la ma\u00eetrise de ses mod\u00e8les et donn\u00e9es conversationnelles. Tock est utilis\u00e9 en production depuis plusieurs ann\u00e9es par OUI.sncf pour proposer des assistants sur des canaux propres (Web, mobile), r\u00e9seaux sociaux et enceintes connect\u00e9es. L'ensemble du code source est disponible sur GitHub sous une licence Apache 2 . Fonctionnalit\u00e9s \u00b6 Assitants embarqu\u00e9s ou int\u00e9gr\u00e9s \u00e0 des sites Web, applications mobiles, r\u00e9seaux sociaux, enceintes connect\u00e9es etc. Plateforme NLU compl\u00e8te (Natural Language Understanding - ou TALN en fran\u00e7ais (Traitement automatique du langage)) , qui utilise diff\u00e9rentes librairies open-source comme OpenNLP , Stanford CoreNLP , Duckling , (et demain Spacy , Rasa , ...) d\u00e9ployable seule si besoin (pour des usages comme l' Internet des objets ) Interfaces Tock Studio : Gestion des mod\u00e8les, entra\u00eenement du bot Construction de parcours conversationnels sans code Support de l'internationalisation ( i18n ) pour les bots multilingues Suivi des conversations, performances et erreurs des mod\u00e8les Analyse interactive des tendances / parcours utilisateurs ( Bot Flow ) Frameworks pour d\u00e9velopper des parcours complexes et int\u00e9grer des services tiers : DSL en Kotlin ou Node et API tous langages Nombreux connecteurs pour Messenger , WhatsApp , Google Assistant / Home , Twitter , Alexa , Business Chat / iMessage , Teams , Slack ... (voir connecteurs ) Installation cloud ou on-premise , avec ou sans Docker , bot \"embarqu\u00e9\" sans Internet Technologies \u00b6 L'ensemble de la plateforme est containeris\u00e9e avec Docker . La plateforme applicative par d\u00e9faut est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. Tock utilise notamment Vert.x et MongoDB . Les interfaces graphiques (Tock Studio) sont \u00e9crites avec Angular en Typescript . Un widget React de base est disponible pour les interfaces Web. D\u00e9marrer... \u00b6 Table des mati\u00e8res Guides et plateforme de d\u00e9monstration Manuels utilisateur , d\u00e9veloppeur , administrateur Ressources (supports, video) et exemples de code","title":"Vue d`ensemble"},{"location":"#bienvenue-sur-tock-une-plateforme-conversationnelle-ouverte","text":"Tock ( The Open Conversation Kit ) est une plateforme compl\u00e8te pour construire des agents conversationnels - souvent appel\u00e9s bots . Contrairement \u00e0 la plupart des solutions conversationnelles, Tock ne d\u00e9pend pas d'API tierces, bien qu'il soit possible d'en int\u00e9grer. L'utilisateur choisit les composants qu'il embarque et peut ainsi conserver la ma\u00eetrise de ses mod\u00e8les et donn\u00e9es conversationnelles. Tock est utilis\u00e9 en production depuis plusieurs ann\u00e9es par OUI.sncf pour proposer des assistants sur des canaux propres (Web, mobile), r\u00e9seaux sociaux et enceintes connect\u00e9es. L'ensemble du code source est disponible sur GitHub sous une licence Apache 2 .","title":"Bienvenue sur Tock : une plateforme conversationnelle ouverte"},{"location":"#fonctionnalites","text":"Assitants embarqu\u00e9s ou int\u00e9gr\u00e9s \u00e0 des sites Web, applications mobiles, r\u00e9seaux sociaux, enceintes connect\u00e9es etc. Plateforme NLU compl\u00e8te (Natural Language Understanding - ou TALN en fran\u00e7ais (Traitement automatique du langage)) , qui utilise diff\u00e9rentes librairies open-source comme OpenNLP , Stanford CoreNLP , Duckling , (et demain Spacy , Rasa , ...) d\u00e9ployable seule si besoin (pour des usages comme l' Internet des objets ) Interfaces Tock Studio : Gestion des mod\u00e8les, entra\u00eenement du bot Construction de parcours conversationnels sans code Support de l'internationalisation ( i18n ) pour les bots multilingues Suivi des conversations, performances et erreurs des mod\u00e8les Analyse interactive des tendances / parcours utilisateurs ( Bot Flow ) Frameworks pour d\u00e9velopper des parcours complexes et int\u00e9grer des services tiers : DSL en Kotlin ou Node et API tous langages Nombreux connecteurs pour Messenger , WhatsApp , Google Assistant / Home , Twitter , Alexa , Business Chat / iMessage , Teams , Slack ... (voir connecteurs ) Installation cloud ou on-premise , avec ou sans Docker , bot \"embarqu\u00e9\" sans Internet","title":"Fonctionnalit\u00e9s"},{"location":"#technologies","text":"L'ensemble de la plateforme est containeris\u00e9e avec Docker . La plateforme applicative par d\u00e9faut est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. Tock utilise notamment Vert.x et MongoDB . Les interfaces graphiques (Tock Studio) sont \u00e9crites avec Angular en Typescript . Un widget React de base est disponible pour les interfaces Web.","title":"Technologies"},{"location":"#demarrer","text":"Table des mati\u00e8res Guides et plateforme de d\u00e9monstration Manuels utilisateur , d\u00e9veloppeur , administrateur Ressources (supports, video) et exemples de code","title":"D\u00e9marrer..."},{"location":"toc/","text":"Documentation Tock \u00b6 Vue d'ensemble Table des mati\u00e8res D\u00e9couvrir Tock : Cr\u00e9er son premier bot avec Tock Studio Configurer son bot pour Slack Configurer son bot pour Messenger Programmer des parcours en mode Bot API D\u00e9ployer une plateforme Tock avec Docker Utiliser Tock : Concepts conversationnels pour Tock Interfaces Tock Studio : Interface g\u00e9n\u00e9rale Le menu Configuration Le menu NLU Le menu NLU QA Le menu Build Le menu Test Le menu Monitoring Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation) D\u00e9velopper avec Tock : Modes disponibles Tock Bot API Tock Bot int\u00e9gr\u00e9 Tests Unitaires Connecteurs Internationalisation ( i18n ) Liste des APIs Tock Exemples de code Administrer Tock : Architecture fonctionnelle et technique Installation S\u00e9curit\u00e9 Disponibilit\u00e9 Supervision Cloud A propos de Tock : Pourquoi Tock Vitrine utilisateurs Ressources & kit presse Nous contacter Communaut\u00e9 Contribuer Emploi","title":"Table des mati\u00e8res"},{"location":"toc/#documentation-tock","text":"Vue d'ensemble Table des mati\u00e8res D\u00e9couvrir Tock : Cr\u00e9er son premier bot avec Tock Studio Configurer son bot pour Slack Configurer son bot pour Messenger Programmer des parcours en mode Bot API D\u00e9ployer une plateforme Tock avec Docker Utiliser Tock : Concepts conversationnels pour Tock Interfaces Tock Studio : Interface g\u00e9n\u00e9rale Le menu Configuration Le menu NLU Le menu NLU QA Le menu Build Le menu Test Le menu Monitoring Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation) D\u00e9velopper avec Tock : Modes disponibles Tock Bot API Tock Bot int\u00e9gr\u00e9 Tests Unitaires Connecteurs Internationalisation ( i18n ) Liste des APIs Tock Exemples de code Administrer Tock : Architecture fonctionnelle et technique Installation S\u00e9curit\u00e9 Disponibilit\u00e9 Supervision Cloud A propos de Tock : Pourquoi Tock Vitrine utilisateurs Ressources & kit presse Nous contacter Communaut\u00e9 Contribuer Emploi","title":"Documentation Tock"},{"location":"admin/architecture/","text":"Architecture de Tock \u00b6 Ce chapitre pr\u00e9sente l'architecture g\u00e9n\u00e9rale d'une plateforme Tock : composants et d\u00e9pendances, flux, configuration de proxies, etc. Architecture fonctionnelle \u00b6 Deux composants majeurs sont disponibles : le moteur NLU : Natural Language Understanding (voir Tock Studio ) le framework conversationnel int\u00e9gr\u00e9 aux services NLU et \u00e0 diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack (voir manuel d\u00e9veloppeur et connecteurs ). La plateforme NLU est ind\u00e9pendante de la partie conversationnelle. Il est possible d'utiliser le NLU sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l' Internet des objets , l'utilisation d'un mod\u00e8le NLU seule est pertinente. Architecture technique \u00b6 Tock est compos\u00e9 de plusieurs composants applicatifs ( conteneurs lorsqu'on utilise Docker) et d'une base de donn\u00e9e MongoDB . Les descripteurs Docker et Docker Compose fournis (ie. les Dockerfile et docker-compose.yml ) d\u00e9crivent l'architecture de Tock. Un exemple complet se trouve dans le fichier docker-compose-bot-open-data.yml disponible dans le d\u00e9p\u00f4t tock-docker . Base de donn\u00e9es MongoDB \u00b6 La base Mongo doit \u00eatre configur\u00e9e en replica set , c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. C'est obligatoire car Tock utilise la fonctionnalit\u00e9 des Change Streams qui a comme pr\u00e9-requis l'installation en replica set. Il s'agit \u00e9galement d'une bonne pratique afin d'assurer une haute disponibilit\u00e9 de la base de donn\u00e9es. Composants applicatifs \u00b6 Voici une description rapide des diff\u00e9rents composants applicatifs (et images Docker fournies avec Tock) : Interfaces et outils Tock Studio : tock/bot_admin : Tock Studio Partie NLU : tock/build_worker : reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire tock/duckling : analyse les dates et types primitifs en utilisant Duckling tock/nlp_api : analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio Partie conversationnelle : tock/bot_api : API pour d\u00e9velopper des bots (mode Tock Bot API ) tock/kotlin_compiler (facultatif) : compilateur de scripts pour les saisir directement dans l'interface Build de Tock Studio Un dernier composant, le bot lui-m\u00eame, doit \u00eatre ajout\u00e9 et rendu accessible aux partenaires et canaux externes auxquels on souhaite s'int\u00e9grer. Bien entendu l'impl\u00e9mentation du bot n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin) mais un exemple est disponible dans docker-compose-bot-open-data.yml . Modes de d\u00e9ploiement \u00b6 Le mode plateforme NLU seul (sans partie conversationnelle) : Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas), permettant de d\u00e9velopper en Kotlin ou un autre langage \u00e0 travers l'API conversationnelle de Tock : Le mode Tock Bot int\u00e9gr\u00e9 (historique) permettant de d\u00e9velopper en Kotlin uniquement en utilisant toutes les possibilit\u00e9s de Tock mais en acc\u00e9dant \u00e0 la base MongoDB directement depuis le bot : Voir aussi... \u00b6 Installation S\u00e9curit\u00e9 Supervision Cloud Haute disponibilit\u00e9","title":"Architecture"},{"location":"admin/architecture/#architecture-de-tock","text":"Ce chapitre pr\u00e9sente l'architecture g\u00e9n\u00e9rale d'une plateforme Tock : composants et d\u00e9pendances, flux, configuration de proxies, etc.","title":"Architecture de Tock"},{"location":"admin/architecture/#architecture-fonctionnelle","text":"Deux composants majeurs sont disponibles : le moteur NLU : Natural Language Understanding (voir Tock Studio ) le framework conversationnel int\u00e9gr\u00e9 aux services NLU et \u00e0 diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack (voir manuel d\u00e9veloppeur et connecteurs ). La plateforme NLU est ind\u00e9pendante de la partie conversationnelle. Il est possible d'utiliser le NLU sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l' Internet des objets , l'utilisation d'un mod\u00e8le NLU seule est pertinente.","title":"Architecture fonctionnelle"},{"location":"admin/architecture/#architecture-technique","text":"Tock est compos\u00e9 de plusieurs composants applicatifs ( conteneurs lorsqu'on utilise Docker) et d'une base de donn\u00e9e MongoDB . Les descripteurs Docker et Docker Compose fournis (ie. les Dockerfile et docker-compose.yml ) d\u00e9crivent l'architecture de Tock. Un exemple complet se trouve dans le fichier docker-compose-bot-open-data.yml disponible dans le d\u00e9p\u00f4t tock-docker .","title":"Architecture technique"},{"location":"admin/architecture/#base-de-donnees-mongodb","text":"La base Mongo doit \u00eatre configur\u00e9e en replica set , c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. C'est obligatoire car Tock utilise la fonctionnalit\u00e9 des Change Streams qui a comme pr\u00e9-requis l'installation en replica set. Il s'agit \u00e9galement d'une bonne pratique afin d'assurer une haute disponibilit\u00e9 de la base de donn\u00e9es.","title":"Base de donn\u00e9es MongoDB"},{"location":"admin/architecture/#composants-applicatifs","text":"Voici une description rapide des diff\u00e9rents composants applicatifs (et images Docker fournies avec Tock) : Interfaces et outils Tock Studio : tock/bot_admin : Tock Studio Partie NLU : tock/build_worker : reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire tock/duckling : analyse les dates et types primitifs en utilisant Duckling tock/nlp_api : analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio Partie conversationnelle : tock/bot_api : API pour d\u00e9velopper des bots (mode Tock Bot API ) tock/kotlin_compiler (facultatif) : compilateur de scripts pour les saisir directement dans l'interface Build de Tock Studio Un dernier composant, le bot lui-m\u00eame, doit \u00eatre ajout\u00e9 et rendu accessible aux partenaires et canaux externes auxquels on souhaite s'int\u00e9grer. Bien entendu l'impl\u00e9mentation du bot n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin) mais un exemple est disponible dans docker-compose-bot-open-data.yml .","title":"Composants applicatifs"},{"location":"admin/architecture/#modes-de-deploiement","text":"Le mode plateforme NLU seul (sans partie conversationnelle) : Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas), permettant de d\u00e9velopper en Kotlin ou un autre langage \u00e0 travers l'API conversationnelle de Tock : Le mode Tock Bot int\u00e9gr\u00e9 (historique) permettant de d\u00e9velopper en Kotlin uniquement en utilisant toutes les possibilit\u00e9s de Tock mais en acc\u00e9dant \u00e0 la base MongoDB directement depuis le bot :","title":"Modes de d\u00e9ploiement"},{"location":"admin/architecture/#voir-aussi","text":"Installation S\u00e9curit\u00e9 Supervision Cloud Haute disponibilit\u00e9","title":"Voir aussi..."},{"location":"admin/cloud/","text":"Cloud \u00b6 Cette page pr\u00e9sente les aspects li\u00e9s \u00e0 l'utilisation de services Cloud (priv\u00e9s ou publiques) pour d\u00e9ployer et h\u00e9berger plateformes et bots Tock. En effet, nous avons l'exp\u00e9rience d'utilisations de Tock en production sur des h\u00e9bergements classiques on-premise et bare metal , mais aussi sur des Clouds priv\u00e9s comme OpenStack ou Clouds publiques comme AWS . A venir : des d\u00e9tails, exemples et retours d'exp\u00e9rience sur l\"utilisation de Tock sur des h\u00e9bergements de type Cloud . Nous esp\u00e9rons m\u00eame pouvoir partager avec la communaut\u00e9 du code : infra as code , dashboards, etc.","title":"Cloud"},{"location":"admin/cloud/#cloud","text":"Cette page pr\u00e9sente les aspects li\u00e9s \u00e0 l'utilisation de services Cloud (priv\u00e9s ou publiques) pour d\u00e9ployer et h\u00e9berger plateformes et bots Tock. En effet, nous avons l'exp\u00e9rience d'utilisations de Tock en production sur des h\u00e9bergements classiques on-premise et bare metal , mais aussi sur des Clouds priv\u00e9s comme OpenStack ou Clouds publiques comme AWS . A venir : des d\u00e9tails, exemples et retours d'exp\u00e9rience sur l\"utilisation de Tock sur des h\u00e9bergements de type Cloud . Nous esp\u00e9rons m\u00eame pouvoir partager avec la communaut\u00e9 du code : infra as code , dashboards, etc.","title":"Cloud"},{"location":"admin/disponibilite/","text":"Haute disponibilit\u00e9 \u00b6 Cette page est destin\u00e9e \u00e0 fournir des conseils et des retours d'ex\u00e9prience sur les configurations haute disponibilit\u00e9 (ou HA - High Availability ) de bots et plateformes Tock. A venir : plus de d\u00e9tails sur les mani\u00e8res d'obtenir une haute disponibilit\u00e9 sur les diff\u00e9rents composants Tock, et des retours sur notre utilisation en production depuis plusieurs ann\u00e9es (cf vitrine / utilisateurs ). Redondance et r\u00e9silience \u00b6 Une seule instance de tock/build_worker doit exister. Il est recommand\u00e9 d'utiliser une seule instance de tock/bot_admin et tock/kotlin_compiler . Pour les autres composants, en particulier le composant bot (non fourni) mais \u00e9galement tock/nlp_api et tock/duckling , il est recommand\u00e9 de d\u00e9ployer plusieurs instances pour assurer une meilleure disponibilit\u00e9 voire de meilleures performances. Performance \u00b6 Comme indiqu\u00e9 dans la section installation , le premier param\u00e8tre \u00e0 surveiller est la m\u00e9moire disponible. A forte charge - nous avons exp\u00e9riment\u00e9 plus de 80 req/s sur nos propres bots - le facteur limitant devient la base de donn\u00e9es MongoDB, qu'il faut alors redimensionner en cons\u00e9quence quand le besoin s'en fait sentir.","title":"Disponibilit\u00e9"},{"location":"admin/disponibilite/#haute-disponibilite","text":"Cette page est destin\u00e9e \u00e0 fournir des conseils et des retours d'ex\u00e9prience sur les configurations haute disponibilit\u00e9 (ou HA - High Availability ) de bots et plateformes Tock. A venir : plus de d\u00e9tails sur les mani\u00e8res d'obtenir une haute disponibilit\u00e9 sur les diff\u00e9rents composants Tock, et des retours sur notre utilisation en production depuis plusieurs ann\u00e9es (cf vitrine / utilisateurs ).","title":"Haute disponibilit\u00e9"},{"location":"admin/disponibilite/#redondance-et-resilience","text":"Une seule instance de tock/build_worker doit exister. Il est recommand\u00e9 d'utiliser une seule instance de tock/bot_admin et tock/kotlin_compiler . Pour les autres composants, en particulier le composant bot (non fourni) mais \u00e9galement tock/nlp_api et tock/duckling , il est recommand\u00e9 de d\u00e9ployer plusieurs instances pour assurer une meilleure disponibilit\u00e9 voire de meilleures performances.","title":"Redondance et r\u00e9silience"},{"location":"admin/disponibilite/#performance","text":"Comme indiqu\u00e9 dans la section installation , le premier param\u00e8tre \u00e0 surveiller est la m\u00e9moire disponible. A forte charge - nous avons exp\u00e9riment\u00e9 plus de 80 req/s sur nos propres bots - le facteur limitant devient la base de donn\u00e9es MongoDB, qu'il faut alors redimensionner en cons\u00e9quence quand le besoin s'en fait sentir.","title":"Performance"},{"location":"admin/installation/","text":"Installation Tock \u00b6 La page architecture pr\u00e9sente l'architecture fonctionnelle et technique Tock, le r\u00f4le des diff\u00e9rents composants ainsi que les diff\u00e9rents modes de d\u00e9ploiement. Ce chapitre pr\u00e9sente les diff\u00e9rentes options d'installation de Tock. En particulier, il s'agit d'\u00e9voquer le cas d'une installation en production ainsi que partager quelques retours d'exp\u00e9rience sur les performances, la r\u00e9silience, la capacit\u00e9 de Tock \u00e0 monter en charge, les d\u00e9ploiementsde type Cloud , la supervision, etc. Si vous cherchez seulement \u00e0 tester Tock avec des donn\u00e9es non sensibles, vous pouvez pr\u00e9f\u00e9rer utiliser la plateforme de d\u00e9monstration Tock . Installation avec Docker \u00b6 Les informations ci-dessous concernent l'installation avec Docker . En analysant les descripteurs Docker et Docker Compose fournis (les Dockerfile et docker-compose.yml ) on peut facilement concevoir une installation sans Docker. Tock est compos\u00e9 par d\u00e9faut de plusieurs conteneurs/images dockers et d'une base de donn\u00e9e MongoDB . Le guide d\u00e9ployer Tock avec Docker dans la section D\u00e9couvrir Tock donne un exemple de d\u00e9ploiement d'une plateforme compl\u00e8te en quelques minutes avec une empreinte minimale en utilisant Docker et Docker Compose. Cependant, cette m\u00e9thode n'est pas envisageable pour un d\u00e9ploiement p\u00e9renne comme une plateforme de production. Si vous souhaitez utiliser Docker Compose en production, merci de lire cet article et de revoir la configuration, qui est uniquement donn\u00e9e dans le projet tock-docker \u00e0 titre d'exemple. En particulier, la configuration des instances MongoDB doit \u00eatre revue attentivement. Base de donn\u00e9es MongoDB \u00b6 La base Mongo devant \u00eatre configur\u00e9e en replica set , c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. Un tutoriel d'installation en replica set est disponible sur le site de MongoDB. Composants applicatifs \u00b6 Selon les composants applicatifs de Tock, obligatoires ou facultatifs, certains doivent \u00eatre mono-instance et d'autres peuvent \u00eatre d\u00e9ploy\u00e9s en plusieurs instances (voir la section haute disponibilit\u00e9 pour en savoir plus). Pour plus de commodit\u00e9, les composants ci-dessous sont nomm\u00e9 comme les images Docker fournies avec Tock, bien que l'utilisation de Docker ne soit pas obligatoire pour installer Tock. Exposition r\u00e9seau \u00b6 Par d\u00e9faut, les composants ou conteneurs de la plateforme Tock ne doivent pas \u00eatre expos\u00e9s \u00e0 l'ext\u00e9rieur du VPN ou VPC . Seul le bot lui-m\u00eame doit \u00eatre accessible des partenaires et canaux externes auxquels on veut s'int\u00e9grer, pour le fonctionnement des WebHooks . Composant / Image Exposition r\u00e9seau Description tock/bot_admin VPN / VPC uniquement Interfaces et outils Tock Studio tock/build_worker VPN / VPC uniquement Reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire tock/duckling VPN / VPC uniquement Analyse les dates et types primitifs en utilisant Duckling tock/nlp_api VPN / VPC uniquement Analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio tock/bot_api VPN / VPC uniquement API pour d\u00e9velopper des bots (mode Tock Bot API ) tock/kotlin_compiler VPN / VPC uniquement (Facultatif) Compilateur de scripts pour les saisir directement dans l'interface Build de Tock Studio bot (non fourni) Internet / partenaires Le bot lui-m\u00eame, impl\u00e9mentant les parcours programmatiques, accessible des partenaires/canaux externes via des WebHooks Bien s\u00fbr, l'impl\u00e9mentation du bot lui-m\u00eame n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin). Proxies HTTP \u00b6 Les propri\u00e9t\u00e9s syst\u00e8me Java https.proxyHost , http.proxyHost et http.nonProxyHosts sont la m\u00e9thode recommand\u00e9e pour configurer un proxy. Packaging du bot \u00b6 Un exemple de bot en mode Tock Bot int\u00e9gr\u00e9 est disponible dans docker-compose-bot-open-data.yml . Des exemples et indications pour packager des bots en mode Tock Bot API ( WebHooks , WebSockets ) seront bient\u00f4t disponibles. Configurations minimales \u00b6 Le param\u00e8tre principal \u00e0 surveiller est la m\u00e9moire vive disponible. Construction des mod\u00e8les \u00b6 En particulier, plus vos mod\u00e8les sont importants, plus il est n\u00e9cessaire d'augmenter la m\u00e9moire pour reconstruire les mod\u00e8les (composant tock/build_worker ). Pour donner un ordre de grandeur, un mod\u00e8le de 50000 phrases avec plusieurs intentions, comportant une vingtaine d'entit\u00e9s, n\u00e9cessitera de provisionner environ 8 Go de RAM pour le composant tock/build_worker . Cependant, des mod\u00e8les importants mais contenant peu d'entit\u00e9s fonctionnent facilement avec seulement 1 Go de RAM. M\u00e9moire JVM \u00b6 Pour garantir que les conteneurs/instances Docker ne d\u00e9passent pas la m\u00e9moire disponible, il est recommand\u00e9 de limiter la m\u00e9moire des JVMs en suivant l'exemple suivant : JAVA_ARGS =- Xmx1g - XX : MaxMetaspaceSize = 256 m Voir aussi... \u00b6 Pour une utilisation de Tock en production, nous vous recommandons de parcourir \u00e9galement les pages suivantes : S\u00e9curit\u00e9 Supervision Cloud Haute disponibilit\u00e9","title":"Installation"},{"location":"admin/installation/#installation-tock","text":"La page architecture pr\u00e9sente l'architecture fonctionnelle et technique Tock, le r\u00f4le des diff\u00e9rents composants ainsi que les diff\u00e9rents modes de d\u00e9ploiement. Ce chapitre pr\u00e9sente les diff\u00e9rentes options d'installation de Tock. En particulier, il s'agit d'\u00e9voquer le cas d'une installation en production ainsi que partager quelques retours d'exp\u00e9rience sur les performances, la r\u00e9silience, la capacit\u00e9 de Tock \u00e0 monter en charge, les d\u00e9ploiementsde type Cloud , la supervision, etc. Si vous cherchez seulement \u00e0 tester Tock avec des donn\u00e9es non sensibles, vous pouvez pr\u00e9f\u00e9rer utiliser la plateforme de d\u00e9monstration Tock .","title":"Installation Tock"},{"location":"admin/installation/#installation-avec-docker","text":"Les informations ci-dessous concernent l'installation avec Docker . En analysant les descripteurs Docker et Docker Compose fournis (les Dockerfile et docker-compose.yml ) on peut facilement concevoir une installation sans Docker. Tock est compos\u00e9 par d\u00e9faut de plusieurs conteneurs/images dockers et d'une base de donn\u00e9e MongoDB . Le guide d\u00e9ployer Tock avec Docker dans la section D\u00e9couvrir Tock donne un exemple de d\u00e9ploiement d'une plateforme compl\u00e8te en quelques minutes avec une empreinte minimale en utilisant Docker et Docker Compose. Cependant, cette m\u00e9thode n'est pas envisageable pour un d\u00e9ploiement p\u00e9renne comme une plateforme de production. Si vous souhaitez utiliser Docker Compose en production, merci de lire cet article et de revoir la configuration, qui est uniquement donn\u00e9e dans le projet tock-docker \u00e0 titre d'exemple. En particulier, la configuration des instances MongoDB doit \u00eatre revue attentivement.","title":"Installation avec Docker"},{"location":"admin/installation/#base-de-donnees-mongodb","text":"La base Mongo devant \u00eatre configur\u00e9e en replica set , c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. Un tutoriel d'installation en replica set est disponible sur le site de MongoDB.","title":"Base de donn\u00e9es MongoDB"},{"location":"admin/installation/#composants-applicatifs","text":"Selon les composants applicatifs de Tock, obligatoires ou facultatifs, certains doivent \u00eatre mono-instance et d'autres peuvent \u00eatre d\u00e9ploy\u00e9s en plusieurs instances (voir la section haute disponibilit\u00e9 pour en savoir plus). Pour plus de commodit\u00e9, les composants ci-dessous sont nomm\u00e9 comme les images Docker fournies avec Tock, bien que l'utilisation de Docker ne soit pas obligatoire pour installer Tock.","title":"Composants applicatifs"},{"location":"admin/installation/#exposition-reseau","text":"Par d\u00e9faut, les composants ou conteneurs de la plateforme Tock ne doivent pas \u00eatre expos\u00e9s \u00e0 l'ext\u00e9rieur du VPN ou VPC . Seul le bot lui-m\u00eame doit \u00eatre accessible des partenaires et canaux externes auxquels on veut s'int\u00e9grer, pour le fonctionnement des WebHooks . Composant / Image Exposition r\u00e9seau Description tock/bot_admin VPN / VPC uniquement Interfaces et outils Tock Studio tock/build_worker VPN / VPC uniquement Reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire tock/duckling VPN / VPC uniquement Analyse les dates et types primitifs en utilisant Duckling tock/nlp_api VPN / VPC uniquement Analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio tock/bot_api VPN / VPC uniquement API pour d\u00e9velopper des bots (mode Tock Bot API ) tock/kotlin_compiler VPN / VPC uniquement (Facultatif) Compilateur de scripts pour les saisir directement dans l'interface Build de Tock Studio bot (non fourni) Internet / partenaires Le bot lui-m\u00eame, impl\u00e9mentant les parcours programmatiques, accessible des partenaires/canaux externes via des WebHooks Bien s\u00fbr, l'impl\u00e9mentation du bot lui-m\u00eame n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin).","title":"Exposition r\u00e9seau"},{"location":"admin/installation/#proxies-http","text":"Les propri\u00e9t\u00e9s syst\u00e8me Java https.proxyHost , http.proxyHost et http.nonProxyHosts sont la m\u00e9thode recommand\u00e9e pour configurer un proxy.","title":"Proxies HTTP"},{"location":"admin/installation/#packaging-du-bot","text":"Un exemple de bot en mode Tock Bot int\u00e9gr\u00e9 est disponible dans docker-compose-bot-open-data.yml . Des exemples et indications pour packager des bots en mode Tock Bot API ( WebHooks , WebSockets ) seront bient\u00f4t disponibles.","title":"Packaging du bot"},{"location":"admin/installation/#configurations-minimales","text":"Le param\u00e8tre principal \u00e0 surveiller est la m\u00e9moire vive disponible.","title":"Configurations minimales"},{"location":"admin/installation/#construction-des-modeles","text":"En particulier, plus vos mod\u00e8les sont importants, plus il est n\u00e9cessaire d'augmenter la m\u00e9moire pour reconstruire les mod\u00e8les (composant tock/build_worker ). Pour donner un ordre de grandeur, un mod\u00e8le de 50000 phrases avec plusieurs intentions, comportant une vingtaine d'entit\u00e9s, n\u00e9cessitera de provisionner environ 8 Go de RAM pour le composant tock/build_worker . Cependant, des mod\u00e8les importants mais contenant peu d'entit\u00e9s fonctionnent facilement avec seulement 1 Go de RAM.","title":"Construction des mod\u00e8les"},{"location":"admin/installation/#memoire-jvm","text":"Pour garantir que les conteneurs/instances Docker ne d\u00e9passent pas la m\u00e9moire disponible, il est recommand\u00e9 de limiter la m\u00e9moire des JVMs en suivant l'exemple suivant : JAVA_ARGS =- Xmx1g - XX : MaxMetaspaceSize = 256 m","title":"M\u00e9moire JVM"},{"location":"admin/installation/#voir-aussi","text":"Pour une utilisation de Tock en production, nous vous recommandons de parcourir \u00e9galement les pages suivantes : S\u00e9curit\u00e9 Supervision Cloud Haute disponibilit\u00e9","title":"Voir aussi..."},{"location":"admin/securite/","text":"S\u00e9curit\u00e9 \u00b6 Authentification \u00b6 Tock supporte plusieurs syst\u00e8mes d'authentification pour l'interface d'administration. Il utilise les librairies vert.x correspondantes. Voici les syst\u00e8mes disponibles par d\u00e9faut : Un mod\u00e8le par \"propri\u00e9t\u00e9s\", utilis\u00e9 par d\u00e9faut. Le code est disponible dans la classe PropertyBasedAuthProvider Un mod\u00e8le OAuth2 dont un exemple est donn\u00e9 par GithubOAuthProvider Un mod\u00e8le bas\u00e9 sur des jetons JWT , dont une impl\u00e9mentation pour AWS est disponible dans AWSJWTAuthProvider Si ces mod\u00e8les ne correspondent pas \u00e0 votre besoin, il est relativement simple d'en d\u00e9velopper d'autres en se basant sur les exemples ci-dessus. N'h\u00e9sitez pas \u00e0 contribuer au projet et \u00e0 nous contacter pour toute question! Chiffrage et anonymisation \u00b6 Chiffrage \u00b6 Il est recommand\u00e9 de d\u00e9ployer vos bases de donn\u00e9es MongoDB en mode chiffr\u00e9 . Vous pouvez cependant ajouter un chiffrage applicatif (facultatif) de certains champs en base de donn\u00e9es. C'est le r\u00f4le de la propri\u00e9t\u00e9 tock_encrypt_pass qui permet d'indiquer un mot de passe pour chiffrer et d\u00e9chiffrer ces champs. Par d\u00e9faut, Tock chiffre toutes les donn\u00e9es utilisateurs jug\u00e9es sensibles \u00e0 condition que ce mot de passe soit sp\u00e9cifi\u00e9. Pour plus de d\u00e9tails, vous pouvez vous r\u00e9ferrer au code source . Anonymisation \u00b6 Il est souvent souhaitable que certaines phrases soient anonymis\u00e9es que ce soit dans les logs (journalisation) ou dans l'interface ( Tock Studio ). Par exemple, des coordonn\u00e9es, num\u00e9ros de cartes de fid\u00e9lit\u00e9, etc. ne devraient \u00eatre lus ni par les utilisateurs de Tock Studio ni par les administrateurs de la plateforme. Pour anonymiser ces donn\u00e9es, Tock met \u00e0 disposition dans son framework une solution bas\u00e9e sur des expressions r\u00e9guli\u00e8res (RegExp) dont l'interface de base est StringObfuscator .","title":"S\u00e9curit\u00e9"},{"location":"admin/securite/#securite","text":"","title":"S\u00e9curit\u00e9"},{"location":"admin/securite/#authentification","text":"Tock supporte plusieurs syst\u00e8mes d'authentification pour l'interface d'administration. Il utilise les librairies vert.x correspondantes. Voici les syst\u00e8mes disponibles par d\u00e9faut : Un mod\u00e8le par \"propri\u00e9t\u00e9s\", utilis\u00e9 par d\u00e9faut. Le code est disponible dans la classe PropertyBasedAuthProvider Un mod\u00e8le OAuth2 dont un exemple est donn\u00e9 par GithubOAuthProvider Un mod\u00e8le bas\u00e9 sur des jetons JWT , dont une impl\u00e9mentation pour AWS est disponible dans AWSJWTAuthProvider Si ces mod\u00e8les ne correspondent pas \u00e0 votre besoin, il est relativement simple d'en d\u00e9velopper d'autres en se basant sur les exemples ci-dessus. N'h\u00e9sitez pas \u00e0 contribuer au projet et \u00e0 nous contacter pour toute question!","title":"Authentification"},{"location":"admin/securite/#chiffrage-et-anonymisation","text":"","title":"Chiffrage et anonymisation"},{"location":"admin/securite/#chiffrage","text":"Il est recommand\u00e9 de d\u00e9ployer vos bases de donn\u00e9es MongoDB en mode chiffr\u00e9 . Vous pouvez cependant ajouter un chiffrage applicatif (facultatif) de certains champs en base de donn\u00e9es. C'est le r\u00f4le de la propri\u00e9t\u00e9 tock_encrypt_pass qui permet d'indiquer un mot de passe pour chiffrer et d\u00e9chiffrer ces champs. Par d\u00e9faut, Tock chiffre toutes les donn\u00e9es utilisateurs jug\u00e9es sensibles \u00e0 condition que ce mot de passe soit sp\u00e9cifi\u00e9. Pour plus de d\u00e9tails, vous pouvez vous r\u00e9ferrer au code source .","title":"Chiffrage"},{"location":"admin/securite/#anonymisation","text":"Il est souvent souhaitable que certaines phrases soient anonymis\u00e9es que ce soit dans les logs (journalisation) ou dans l'interface ( Tock Studio ). Par exemple, des coordonn\u00e9es, num\u00e9ros de cartes de fid\u00e9lit\u00e9, etc. ne devraient \u00eatre lus ni par les utilisateurs de Tock Studio ni par les administrateurs de la plateforme. Pour anonymiser ces donn\u00e9es, Tock met \u00e0 disposition dans son framework une solution bas\u00e9e sur des expressions r\u00e9guli\u00e8res (RegExp) dont l'interface de base est StringObfuscator .","title":"Anonymisation"},{"location":"admin/supervision/","text":"Supervision \u00b6 Ce chapitre pr\u00e9sente quelques aspects supervision et monitoring du fonctionnement de la plateforme et des bots Tock. A venir : plus de d\u00e9tails sur la mani\u00e8re de monitorer les bots, voire des exemples de dashboards pour quelques technologies de monitoring classiques. N'h\u00e9sitez pas \u00e0 partager les v\u00f4tres. Lignes de vie (healthchecks) \u00b6 L'url /healthcheck renvoie une code HTTP 200 si tout est correct. Pour certaines images, le ligne de vie peut ne pas \u00eatre pr\u00e9sente \u00e0 la racine. En particulier : Pour tock/admin , la ligne de vie est localis\u00e9e par d\u00e9faut dans /rest/admin/healthcheck Pour tock/nlp_api , la ligne de vie est /rest/nlp/healthcheck Journalisation (logs) \u00b6 Logs applicatifs \u00b6 Tock utilise SLF4J pour g\u00e9n\u00e9rer ses logs. Chiffrage et anonymisation \u00b6 Voir la page s\u00e9curit\u00e9 concernant les possibilit\u00e9s de chiffrage et anonymisation des logs.","title":"Supervision"},{"location":"admin/supervision/#supervision","text":"Ce chapitre pr\u00e9sente quelques aspects supervision et monitoring du fonctionnement de la plateforme et des bots Tock. A venir : plus de d\u00e9tails sur la mani\u00e8re de monitorer les bots, voire des exemples de dashboards pour quelques technologies de monitoring classiques. N'h\u00e9sitez pas \u00e0 partager les v\u00f4tres.","title":"Supervision"},{"location":"admin/supervision/#lignes-de-vie-healthchecks","text":"L'url /healthcheck renvoie une code HTTP 200 si tout est correct. Pour certaines images, le ligne de vie peut ne pas \u00eatre pr\u00e9sente \u00e0 la racine. En particulier : Pour tock/admin , la ligne de vie est localis\u00e9e par d\u00e9faut dans /rest/admin/healthcheck Pour tock/nlp_api , la ligne de vie est /rest/nlp/healthcheck","title":"Lignes de vie (healthchecks)"},{"location":"admin/supervision/#journalisation-logs","text":"","title":"Journalisation (logs)"},{"location":"admin/supervision/#logs-applicatifs","text":"Tock utilise SLF4J pour g\u00e9n\u00e9rer ses logs.","title":"Logs applicatifs"},{"location":"admin/supervision/#chiffrage-et-anonymisation","text":"Voir la page s\u00e9curit\u00e9 concernant les possibilit\u00e9s de chiffrage et anonymisation des logs.","title":"Chiffrage et anonymisation"},{"location":"apropos/communaute/","text":"Communaut\u00e9 Tock \u00b6 Tock est b\u00e2ti sur un mod\u00e8le communautaire pour cr\u00e9er une plateforme ouverte. Pour en savoir plus, voir pourquoi Tock . Next events / Meetup \u00b6 Voici les prochains \u00e9v\u00e9nements li\u00e9s \u00e0 Tock ou identifi\u00e9s pour \u00e9changer avec la communaut\u00e9 : Novembre: Nous devrions pr\u00e9senter Tock au Paris NLP (season 4 meetup #2) Un Hackathon ouvert au public aura lieu les 21-22 novembre \u00e0 Paris, autour du th\u00e8me du conversationnel avec Tock (+ infos tr\u00e8s bient\u00f4t) D\u00e9cembre: Une conf\u00e9rence sur les plateformes conversationnelles ouvertes a \u00e9t\u00e9 soumis au CFP du Paris Open Source Summit (\u00e0 confirmer) Association TOSIT \u00b6 La solution Tock souhaite rejoindre une association comme le TOSIT (The Open Source I Trust) , une structure de soutien \u00e0 l\u2019Open Source qui vise \u00e0 soutenir l\u2019\u00e9mergence de codes, logiciels et solutions informatiques sous licence open source et/ou licence libre. Fond\u00e9e par Carrefour, EDF, Enedis, Orange, P\u00f4le Emploi et SNCF, TOSIT compte depuis d'autres membres importants comme Le Minist\u00e8re des Arm\u00e9es, Soci\u00e9t\u00e9 G\u00e9n\u00e9rale ou MAIF par exemple. Tock s'inscrit dans le cadre du Groupe de Travail Chatbots du TOSIT. La solution est d'ores et d\u00e9j\u00e0 utilis\u00e9e par plusieurs membres du TOSIT, dont SNCF. Pour en savoir plus, voir le site de l'association : http://tosit.fr/ GitHub & Gitter \u00b6 L'ensemble de la plateforme et des outils est partag\u00e9 sur https://github.com/theopenconversationkit/tock sous licence Apache 2 . Sources Licence Versions Issues Contributeurs Gitter D\u00e9mo Pour en savoir plus sur l'organisation des d\u00e9p\u00f4ts, les conventions de code, etc. voir la section contribuer \u00e0 Tock . Aide \u00b6 Voir nous contacter .","title":"Communaut\u00e9"},{"location":"apropos/communaute/#communaute-tock","text":"Tock est b\u00e2ti sur un mod\u00e8le communautaire pour cr\u00e9er une plateforme ouverte. Pour en savoir plus, voir pourquoi Tock .","title":"Communaut\u00e9 Tock"},{"location":"apropos/communaute/#next-events-meetup","text":"Voici les prochains \u00e9v\u00e9nements li\u00e9s \u00e0 Tock ou identifi\u00e9s pour \u00e9changer avec la communaut\u00e9 : Novembre: Nous devrions pr\u00e9senter Tock au Paris NLP (season 4 meetup #2) Un Hackathon ouvert au public aura lieu les 21-22 novembre \u00e0 Paris, autour du th\u00e8me du conversationnel avec Tock (+ infos tr\u00e8s bient\u00f4t) D\u00e9cembre: Une conf\u00e9rence sur les plateformes conversationnelles ouvertes a \u00e9t\u00e9 soumis au CFP du Paris Open Source Summit (\u00e0 confirmer)","title":"Next events / Meetup"},{"location":"apropos/communaute/#association-tosit","text":"La solution Tock souhaite rejoindre une association comme le TOSIT (The Open Source I Trust) , une structure de soutien \u00e0 l\u2019Open Source qui vise \u00e0 soutenir l\u2019\u00e9mergence de codes, logiciels et solutions informatiques sous licence open source et/ou licence libre. Fond\u00e9e par Carrefour, EDF, Enedis, Orange, P\u00f4le Emploi et SNCF, TOSIT compte depuis d'autres membres importants comme Le Minist\u00e8re des Arm\u00e9es, Soci\u00e9t\u00e9 G\u00e9n\u00e9rale ou MAIF par exemple. Tock s'inscrit dans le cadre du Groupe de Travail Chatbots du TOSIT. La solution est d'ores et d\u00e9j\u00e0 utilis\u00e9e par plusieurs membres du TOSIT, dont SNCF. Pour en savoir plus, voir le site de l'association : http://tosit.fr/","title":"Association TOSIT"},{"location":"apropos/communaute/#github-gitter","text":"L'ensemble de la plateforme et des outils est partag\u00e9 sur https://github.com/theopenconversationkit/tock sous licence Apache 2 . Sources Licence Versions Issues Contributeurs Gitter D\u00e9mo Pour en savoir plus sur l'organisation des d\u00e9p\u00f4ts, les conventions de code, etc. voir la section contribuer \u00e0 Tock .","title":"GitHub &amp; Gitter"},{"location":"apropos/communaute/#aide","text":"Voir nous contacter .","title":"Aide"},{"location":"apropos/contact/","text":"Nous contacter \u00b6 D\u00e9veloppeurs, utilisateurs ou juste curieux, n'h\u00e9sitez pas \u00e0 contacter les cr\u00e9ateurs de la solution et d'autres membres de la communaut\u00e9 pour \u00e9changer sur Tock. Vous pouvez nous retrouver sur Gitter (la messagerie instantann\u00e9e pour GitHub) : https://gitter.im/tockchat/Lobby Les issues GitHub permettent aussi de remonter une anomalie ou proposer une \u00e9volution : https://github.com/theopenconversationkit/tock/issues","title":"Nous contacter"},{"location":"apropos/contact/#nous-contacter","text":"D\u00e9veloppeurs, utilisateurs ou juste curieux, n'h\u00e9sitez pas \u00e0 contacter les cr\u00e9ateurs de la solution et d'autres membres de la communaut\u00e9 pour \u00e9changer sur Tock. Vous pouvez nous retrouver sur Gitter (la messagerie instantann\u00e9e pour GitHub) : https://gitter.im/tockchat/Lobby Les issues GitHub permettent aussi de remonter une anomalie ou proposer une \u00e9volution : https://github.com/theopenconversationkit/tock/issues","title":"Nous contacter"},{"location":"apropos/contribuer/","text":"Contribuer \u00e0 Tock \u00b6 Le projet Tock est ouvert \u00e0 la contribution et toute proposition est la bienvenue ! Cette page donne des indications sur la structure et les conventions du code de la plateforme. Principales technologies \u00b6 La plateforme applicative est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. Tock utilise Vert.x et MongoDB . Les interfaces graphiques (Tock Studio) sont \u00e9crites avec Angular en Typescript . Structure des sources \u00b6 Les d\u00e9p\u00f4ts \u00b6 tock : d\u00e9p\u00f4t principal comprend le framework et les composants de la plateforme sous licence Apache 2 . tock-corenlp : code utilisant une d\u00e9pendance optionnelle \u00e0 Stanford CoreNLP (\u00e0 la place d' Apache OpenNLP ), sous licence GPL . tock-docker : des images Docker et Docker Compose , pour faciliter la prise en main et le d\u00e9ploiement de la plateforme dans diff\u00e9rentes configurations. tock-bot-samples : des exemples de code notamment pour programmer des parcours en mode WebHook ou WebSocket comme dans les guides Tock . tock-bot-open-data : un exemple de bot bas\u00e9 sur les API Open Data de la SNCF , impl\u00e9mentant \u00e9galement des bases pour l'internationalisation avec deux langues propos\u00e9es. Le d\u00e9p\u00f4t tock \u00b6 Voici une premi\u00e8re description des sources dans le d\u00e9p\u00f4t tock : bot : la plateforme conversationnelle (interfaces, API, connecteurs, etc.), en d\u00e9pendance sur les modules NLU docs : le sites de documentation, g\u00e9n\u00e9r\u00e9s avec MkDocs docs-mk : les sources pour les sites de documentation, pour MkDocs dokka : la documentation Dokka du framework Kotlin etc : des scripts utilitaires, par exemple pour g\u00e9n\u00e9rer les sites avec MkDocs nlp : la plateforme NLU uniquement (interfaces, API, mod\u00e8les d'entit\u00e9s, etc.) scripts : d'autres scripts utilitaires, par exemple pour d\u00e9velopper sur Messenger avec ngrok shared : des composants Kotlin partag\u00e9s entre les diff\u00e9rents modules du framework stt : des impl\u00e9mentations et wrappers pour le speech-to-text translator : des impl\u00e9mentations et wrappers pour le multilingue ( i18n ) Remarque : il existe \"deux admin \" (ie. deux interfaces Tock Studio ) dans les sources. En effet, il est possible d'installer la plateforme NLU / NLP seule sans les outils conversationnels. En cons\u00e9quence : nlp/admin : contient les composants et interfaces graphiques pour le NLU / NLP seulement bot/admin : reprend les composants NLP / NLU (en d\u00e9pendance dans le build Maven) et reconstruit les interfaces en y ajoutant les outils conversationnels Le d\u00e9p\u00f4t tock-docker \u00b6 Le d\u00e9p\u00f4t contient une structure de modules Maven reprenant les diff\u00e9rents composants de la plateforme Tock. Chacun de ces modules porte une impl\u00e9mentation Docker du composant en s'appuie sur le plugin Maven io.fabric8:docker-maven-plugin pour encapsuler le build Docker. A la racine du d\u00e9p\u00f4t se trouvent diff\u00e9rents descripteurs Docker Compose permettant de d\u00e9ployer une plateforme en se basant sur les images d\u00e9j\u00e0 construites. Diff\u00e9rentes configurations existent, notamment en mode Bot API ou en mode int\u00e9gr\u00e9 , avec la plateforme NLU standalone, etc. Le descripteur de r\u00e9f\u00e9rence pour le mode Bot API est docker-compose-bot.yml . Construire Tock \u00e0 partir des sources \u00b6 Tock (core) \u00b6 Le projet est construit avec Maven , y compris les modules Web impliquant NPM et Angular : $ mvn package Un build d'int\u00e9gration continue est disponible sur Travis . Images Docker \u00b6 Les images Docker de Tock peuvent \u00eatre reconstruites \u00e0 partir des sources du d\u00e9p\u00f4t tock-docker . Pour cela, utilisez Maven qui d\u00e9clenchera le build Docker : $ mvn docker:build Vous pouvez ensuite instancier ces images via Docker ou les stacks Docker Compose avec les descripteurs \u00e0 la racine du d\u00e9p\u00f4t. Ex\u00e9cuter dans un IDE \u00b6 Pour d\u00e9marrer Tock avec Docker Compose hors d'un IDE, voir D\u00e9ployer Tock avec Docker . Il est possible d'ex\u00e9cuter les diff\u00e9rents composants de Tock (NLU, Studio, bot...) depuis un IDE comme IntelliJ , Eclipse ou Visual Studio Code par exemple. Outre les images Docker , des configurations pour IntelliJ sont fournies avec les sources de Tock : Le serveur d'administration du bot : BotAdmin Le serveur d'administration du NLP uniquement : Admin Le service NLP : NlpService Le service Duckling : Duckling Le service de construction des mod\u00e8les NLP : BuildWorker Le service de compilation des scripts : KotlinCompilerServer Pour le bot d'exemple : OpenDataBot Enfin pour lancer les interfaces d'administration, vous aurez besoin de lancer les commandes d\u00e9crites dans les liens suivants : Pour l'administration compl\u00e8te (Bot + NLP) Pour l'administration NLP uniquement Conventions \u00b6 Les Kotlin Code Conventions sont utilis\u00e9es pour d\u00e9velopper le code de Tock. Nous contacter \u00b6 Un probl\u00e8me ? Une question sur l'impl\u00e9mentation ? Une id\u00e9e \u00e0 partager ? Pour contribuer au projet ou simplement en savoir plus, n'h\u00e9sitez pas \u00e0 nous contacter .","title":"Contribuer"},{"location":"apropos/contribuer/#contribuer-a-tock","text":"Le projet Tock est ouvert \u00e0 la contribution et toute proposition est la bienvenue ! Cette page donne des indications sur la structure et les conventions du code de la plateforme.","title":"Contribuer \u00e0 Tock"},{"location":"apropos/contribuer/#principales-technologies","text":"La plateforme applicative est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. Tock utilise Vert.x et MongoDB . Les interfaces graphiques (Tock Studio) sont \u00e9crites avec Angular en Typescript .","title":"Principales technologies"},{"location":"apropos/contribuer/#structure-des-sources","text":"","title":"Structure des sources"},{"location":"apropos/contribuer/#les-depots","text":"tock : d\u00e9p\u00f4t principal comprend le framework et les composants de la plateforme sous licence Apache 2 . tock-corenlp : code utilisant une d\u00e9pendance optionnelle \u00e0 Stanford CoreNLP (\u00e0 la place d' Apache OpenNLP ), sous licence GPL . tock-docker : des images Docker et Docker Compose , pour faciliter la prise en main et le d\u00e9ploiement de la plateforme dans diff\u00e9rentes configurations. tock-bot-samples : des exemples de code notamment pour programmer des parcours en mode WebHook ou WebSocket comme dans les guides Tock . tock-bot-open-data : un exemple de bot bas\u00e9 sur les API Open Data de la SNCF , impl\u00e9mentant \u00e9galement des bases pour l'internationalisation avec deux langues propos\u00e9es.","title":"Les d\u00e9p\u00f4ts"},{"location":"apropos/contribuer/#le-depot-tock","text":"Voici une premi\u00e8re description des sources dans le d\u00e9p\u00f4t tock : bot : la plateforme conversationnelle (interfaces, API, connecteurs, etc.), en d\u00e9pendance sur les modules NLU docs : le sites de documentation, g\u00e9n\u00e9r\u00e9s avec MkDocs docs-mk : les sources pour les sites de documentation, pour MkDocs dokka : la documentation Dokka du framework Kotlin etc : des scripts utilitaires, par exemple pour g\u00e9n\u00e9rer les sites avec MkDocs nlp : la plateforme NLU uniquement (interfaces, API, mod\u00e8les d'entit\u00e9s, etc.) scripts : d'autres scripts utilitaires, par exemple pour d\u00e9velopper sur Messenger avec ngrok shared : des composants Kotlin partag\u00e9s entre les diff\u00e9rents modules du framework stt : des impl\u00e9mentations et wrappers pour le speech-to-text translator : des impl\u00e9mentations et wrappers pour le multilingue ( i18n ) Remarque : il existe \"deux admin \" (ie. deux interfaces Tock Studio ) dans les sources. En effet, il est possible d'installer la plateforme NLU / NLP seule sans les outils conversationnels. En cons\u00e9quence : nlp/admin : contient les composants et interfaces graphiques pour le NLU / NLP seulement bot/admin : reprend les composants NLP / NLU (en d\u00e9pendance dans le build Maven) et reconstruit les interfaces en y ajoutant les outils conversationnels","title":"Le d\u00e9p\u00f4t tock"},{"location":"apropos/contribuer/#le-depot-tock-docker","text":"Le d\u00e9p\u00f4t contient une structure de modules Maven reprenant les diff\u00e9rents composants de la plateforme Tock. Chacun de ces modules porte une impl\u00e9mentation Docker du composant en s'appuie sur le plugin Maven io.fabric8:docker-maven-plugin pour encapsuler le build Docker. A la racine du d\u00e9p\u00f4t se trouvent diff\u00e9rents descripteurs Docker Compose permettant de d\u00e9ployer une plateforme en se basant sur les images d\u00e9j\u00e0 construites. Diff\u00e9rentes configurations existent, notamment en mode Bot API ou en mode int\u00e9gr\u00e9 , avec la plateforme NLU standalone, etc. Le descripteur de r\u00e9f\u00e9rence pour le mode Bot API est docker-compose-bot.yml .","title":"Le d\u00e9p\u00f4t tock-docker"},{"location":"apropos/contribuer/#construire-tock-a-partir-des-sources","text":"","title":"Construire Tock \u00e0 partir des sources"},{"location":"apropos/contribuer/#tock-core","text":"Le projet est construit avec Maven , y compris les modules Web impliquant NPM et Angular : $ mvn package Un build d'int\u00e9gration continue est disponible sur Travis .","title":"Tock (core)"},{"location":"apropos/contribuer/#images-docker","text":"Les images Docker de Tock peuvent \u00eatre reconstruites \u00e0 partir des sources du d\u00e9p\u00f4t tock-docker . Pour cela, utilisez Maven qui d\u00e9clenchera le build Docker : $ mvn docker:build Vous pouvez ensuite instancier ces images via Docker ou les stacks Docker Compose avec les descripteurs \u00e0 la racine du d\u00e9p\u00f4t.","title":"Images Docker"},{"location":"apropos/contribuer/#executer-dans-un-ide","text":"Pour d\u00e9marrer Tock avec Docker Compose hors d'un IDE, voir D\u00e9ployer Tock avec Docker . Il est possible d'ex\u00e9cuter les diff\u00e9rents composants de Tock (NLU, Studio, bot...) depuis un IDE comme IntelliJ , Eclipse ou Visual Studio Code par exemple. Outre les images Docker , des configurations pour IntelliJ sont fournies avec les sources de Tock : Le serveur d'administration du bot : BotAdmin Le serveur d'administration du NLP uniquement : Admin Le service NLP : NlpService Le service Duckling : Duckling Le service de construction des mod\u00e8les NLP : BuildWorker Le service de compilation des scripts : KotlinCompilerServer Pour le bot d'exemple : OpenDataBot Enfin pour lancer les interfaces d'administration, vous aurez besoin de lancer les commandes d\u00e9crites dans les liens suivants : Pour l'administration compl\u00e8te (Bot + NLP) Pour l'administration NLP uniquement","title":"Ex\u00e9cuter dans un IDE"},{"location":"apropos/contribuer/#conventions","text":"Les Kotlin Code Conventions sont utilis\u00e9es pour d\u00e9velopper le code de Tock.","title":"Conventions"},{"location":"apropos/contribuer/#nous-contacter","text":"Un probl\u00e8me ? Une question sur l'impl\u00e9mentation ? Une id\u00e9e \u00e0 partager ? Pour contribuer au projet ou simplement en savoir plus, n'h\u00e9sitez pas \u00e0 nous contacter .","title":"Nous contacter"},{"location":"apropos/emploi/","text":"Emplois Tock \u00b6 Int\u00e9ress\u00e9(e) par travailler avec Tock et contribuer \u00e0 la plateforme ? Cette page recense des entreprises et organisations proposants des offres d'emploi dans le domaine conversationnel avec Tock : e-voyageurs Technologies (\u00e0 l'origine du projet) recrute pour d\u00e9velopper des assistants conversationnels avec Tock. Pour en savoir plus, rendez-vous sur Gitter ou sur https://jobs.oui.sncf/ . Vous utilisez Tock et proposez des offres d'emploi en conversationnel ? N'h\u00e9sitez pas \u00e0 nous le signaler pour enrichir cette liste.","title":"Emploi"},{"location":"apropos/emploi/#emplois-tock","text":"Int\u00e9ress\u00e9(e) par travailler avec Tock et contribuer \u00e0 la plateforme ? Cette page recense des entreprises et organisations proposants des offres d'emploi dans le domaine conversationnel avec Tock : e-voyageurs Technologies (\u00e0 l'origine du projet) recrute pour d\u00e9velopper des assistants conversationnels avec Tock. Pour en savoir plus, rendez-vous sur Gitter ou sur https://jobs.oui.sncf/ . Vous utilisez Tock et proposez des offres d'emploi en conversationnel ? N'h\u00e9sitez pas \u00e0 nous le signaler pour enrichir cette liste.","title":"Emplois Tock"},{"location":"apropos/pourquoi/","text":"Pourquoi Tock ? \u00b6 Initi\u00e9 en 2016 par l'\u00e9quipe Innovation chez OUI.sncf afin de motoriser l'analyse des commandes vocales sur ses applications mobiles , le framework fut ensuite utilis\u00e9 pour cr\u00e9er son bot Messenger , avant d'\u00eatre \u00e9tendu \u00e0 de nombreux canaux et d'accueillir d'autres bots pour de nouveaux cas d'usage. A ses d\u00e9buts, la plateforme donnait des r\u00e9sultats similaires \u00e0 ceux obtenus avec diff\u00e9rentes solutions du march\u00e9, tout en restant en ma\u00eetrise du code (embarquant des biblioth\u00e8ques opensource issues du domaine universitaire), en \u00e9vitant les effets \"bo\u00eete noire\" (notamment pour d\u00e9bugger les mod\u00e8les conversationnels) pour une r\u00e9activit\u00e9 accrue. Depuis, l'\u00e9quipe derri\u00e8re OUIbot ainsi que d'autres \u00e9quipes d\u00e9di\u00e9es \u00e0 diff\u00e9rents assistants conversationnels SNCF (cf la vitrine ) utilisent quotidiennement Tock en production, tout en enrichissant r\u00e9guli\u00e8rement la plateforme de nouvelles fonctionnalit\u00e9s et connecteurs. Nous pensons qu'il y a un besoin de plateformes conversationnelles et IA ouvertes , permettant des sc\u00e9narios techniques et m\u00e9tier vari\u00e9s tout en restant en ma\u00eetrise du code , l'utilisateur \u00e9tant propri\u00e9taire de ses mod\u00e8les et de ses donn\u00e9es . De plus en plus d'acteurs, petites et grandes entreprises en France et \u00e0 l'international, partagent cette vision et ce besoin pour leurs propres projets. L'ensemble de la solution Tock est partag\u00e9 avec la communaut\u00e9 opensource dans le but de f\u00e9d\u00e9rer et mutualiser l'effort des cr\u00e9ateurs d'assistants. Depuis 2019, Tock est pr\u00e9conis\u00e9 en interne par le groupe SNCF. L'outil a vocation \u00e0 terme \u00e0 rejoindre une association comme le TOSIT (The Open Source I Trust) .","title":"Pourquoi Tock"},{"location":"apropos/pourquoi/#pourquoi-tock","text":"Initi\u00e9 en 2016 par l'\u00e9quipe Innovation chez OUI.sncf afin de motoriser l'analyse des commandes vocales sur ses applications mobiles , le framework fut ensuite utilis\u00e9 pour cr\u00e9er son bot Messenger , avant d'\u00eatre \u00e9tendu \u00e0 de nombreux canaux et d'accueillir d'autres bots pour de nouveaux cas d'usage. A ses d\u00e9buts, la plateforme donnait des r\u00e9sultats similaires \u00e0 ceux obtenus avec diff\u00e9rentes solutions du march\u00e9, tout en restant en ma\u00eetrise du code (embarquant des biblioth\u00e8ques opensource issues du domaine universitaire), en \u00e9vitant les effets \"bo\u00eete noire\" (notamment pour d\u00e9bugger les mod\u00e8les conversationnels) pour une r\u00e9activit\u00e9 accrue. Depuis, l'\u00e9quipe derri\u00e8re OUIbot ainsi que d'autres \u00e9quipes d\u00e9di\u00e9es \u00e0 diff\u00e9rents assistants conversationnels SNCF (cf la vitrine ) utilisent quotidiennement Tock en production, tout en enrichissant r\u00e9guli\u00e8rement la plateforme de nouvelles fonctionnalit\u00e9s et connecteurs. Nous pensons qu'il y a un besoin de plateformes conversationnelles et IA ouvertes , permettant des sc\u00e9narios techniques et m\u00e9tier vari\u00e9s tout en restant en ma\u00eetrise du code , l'utilisateur \u00e9tant propri\u00e9taire de ses mod\u00e8les et de ses donn\u00e9es . De plus en plus d'acteurs, petites et grandes entreprises en France et \u00e0 l'international, partagent cette vision et ce besoin pour leurs propres projets. L'ensemble de la solution Tock est partag\u00e9 avec la communaut\u00e9 opensource dans le but de f\u00e9d\u00e9rer et mutualiser l'effort des cr\u00e9ateurs d'assistants. Depuis 2019, Tock est pr\u00e9conis\u00e9 en interne par le groupe SNCF. L'outil a vocation \u00e0 terme \u00e0 rejoindre une association comme le TOSIT (The Open Source I Trust) .","title":"Pourquoi Tock ?"},{"location":"apropos/ressources/","text":"Ressources Tock \u00b6 Les diff\u00e9rents supports et pr\u00e9sentations ci-dessous donnent un aper\u00e7u de la solution Tock, en compl\u00e9ment des guides pour tester soi-m\u00eame la plateforme. Conf\u00e9rences / video \u00b6 D\u00e9velopper un bot sur Messenger et Google Assistant en 30 minutes @ Devoxx France 2018 (live coding \"tools in action\" 30 min) Supports de pr\u00e9sentation / meetup \u00b6 Tock - The Open Conversation Kit @ Meetup Open Transport (2019) Tock - The Open Conversation Kit @ CRiP OpenSource & Co-d\u00e9veloppement (2017) N'h\u00e9sitez pas \u00e0 partager d'autres supports et liens autour de Tock. Kit presse \u00b6 Comme le reste des sources Tock, les logos sont disponibles sous licence Apache 2 . Logo Tock - couleurs par d\u00e9faut / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - bleu / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - noir / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - blanc / transparent ( t\u00e9l\u00e9charger ) :","title":"Ressources"},{"location":"apropos/ressources/#ressources-tock","text":"Les diff\u00e9rents supports et pr\u00e9sentations ci-dessous donnent un aper\u00e7u de la solution Tock, en compl\u00e9ment des guides pour tester soi-m\u00eame la plateforme.","title":"Ressources Tock"},{"location":"apropos/ressources/#conferences-video","text":"D\u00e9velopper un bot sur Messenger et Google Assistant en 30 minutes @ Devoxx France 2018 (live coding \"tools in action\" 30 min)","title":"Conf\u00e9rences / video"},{"location":"apropos/ressources/#supports-de-presentation-meetup","text":"Tock - The Open Conversation Kit @ Meetup Open Transport (2019) Tock - The Open Conversation Kit @ CRiP OpenSource & Co-d\u00e9veloppement (2017) N'h\u00e9sitez pas \u00e0 partager d'autres supports et liens autour de Tock.","title":"Supports de pr\u00e9sentation / meetup"},{"location":"apropos/ressources/#kit-presse","text":"Comme le reste des sources Tock, les logos sont disponibles sous licence Apache 2 . Logo Tock - couleurs par d\u00e9faut / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - bleu / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - noir / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - blanc / transparent ( t\u00e9l\u00e9charger ) :","title":"Kit presse"},{"location":"apropos/vitrine/","text":"Vitrine utilisateurs \u00b6 Depuis sa cr\u00e9ation pour OUI.sncf en 2016, Tock est utilis\u00e9 par de plus en plus d'\u00e9quipes pour cr\u00e9er des bots conversationnels d\u00e9di\u00e9s \u00e0 des usages divers : business to customer et business to business distribution, transactionnel, paiement assistance, care , help desks FAQ et arbres de d\u00e9cision Cette page pr\u00e9sente diff\u00e9rents assistants et produits construits avec Tock. OUIbot , le bot OUI.sncf \u00b6 OUIbot est l'assistant conversationnel de OUI.sncf. Disponible depuis 2016 sur le r\u00e9seau social Facebook Messenger, OUIbot s'est construit avec les premi\u00e8res versions de Tock. Avec OUIbot, r\u00e9server un billet de train n'a jamais \u00e9t\u00e9 aussi simple ! Il vous assiste dans la pr\u00e9paration de vos voyages, permet d'effectuer rapidement et simplement une r\u00e9servation compl\u00e8te, de la recherche \u00e0 l'achat (paiement inclus), et vous accompagne durant votre voyage. Gr\u00e2ce aux nombreux connecteurs Tock, OUIbot r\u00e9pond pr\u00e9sent sur de nombreux canaux conversationnels : site www.oui.sncf , r\u00e9seaux sociaux, assistants vocaux, enceintes connect\u00e9es et m\u00eame IAffiches avec JCDecaux . En 2019, OUIbot accompagne pr\u00e8s de 10 000 utilisateurs par jour. Il a \u00e9t\u00e9 \u00e9lu Best Robot Experience pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive. Nom : OUIbot Date de naissance : en production depuis 2016 Domaine : distribution, transactionnel (r\u00e9servations, paiements), alertes & push notifications, relai vers un agent Canaux : texte & voix, sur le site Web entreprise, Messenger, WhatsApp, Business Chat (Messages), Google Assistant, Google Home, Alexa, IAffiches JCDecaux L'Assistant SNCF \u00b6 L'Assistant SNCF est l'application mobile des voyageurs SNCF sur Android et iOS, couvrant le train mais aussi d'autres modes de transport. Avec l\u2019 Assistant SNCF , vous pouvez calculer votre itin\u00e9raire, rester inform\u00e9 en temps r\u00e9el, acheter directement vos tickets de transport ou encore r\u00e9server votre course en VTC. En attendant de nouvelles fonctionnalit\u00e9s \u00e0 venir. Accessible via le \"microphone\" dans l'application mobile, le bot conversationnel de l' Assistant SNCF est construit avec Tock et les fonctions speech-to-text Android et iOS. Nom : L'Assistant SNCF Date de naissance : en production, fonction vocale Tock depuis 2019 Domaine : voyage & transport (recherche itin\u00e9raires en multi-modal, etc.) Canaux : vocal, sur l'application mobile SNCF pour Android et iOS Tilien , le chatbot Transilien \u00b6 Tilien est le chatbot Transilien sur Messenger. Con\u00e7u comme un compagnon de voyage personnel et amical, il informe des prochains d\u00e9parts, l'\u00e9tat du trafic, les travaux en cours et \u00e0 venir, propose des itin\u00e9raires et bien d'autres choses (plans des lignes, fiches horaires, etc.) sur l'ensemble du r\u00e9seau ferr\u00e9 Ile-De-France : M\u00e9tro, RER, Transilien, Tram. Motoris\u00e9 par Tock, le chatbot vous attend sur Facebook Messenger pour offrir ses services. Nom : Tilien Date de naissance : en production, depuis 2018 sur Tock Domaine : transport & assistance (recherche itin\u00e9raires, plans des lignes, \u00e9tat du trafic, etc.) Canaux : texte, sur Messenger Mon Assistant TGV INOUI \u00b6 Mon Assistant informe les clients et voyageurs de la marque TGV INOUI avant, pendant et apr\u00e8s leur trajet. Le chatbot est capable de donner l'\u00e9tat du trafic, le quai de d\u00e9part d'un train, la ou les places du client, les services \u00e0 bord (le bar, les prises \u00e9lectriques, etc.). Il permet aussi de parler avec un agent SNCF tout en restant dans la m\u00eame conversation. Pr\u00e9sent sur la page Facebook TGV INOUI , l'assistant qui s'appuie sur Tock est \u00e9galement accessible depuis le SMS de rappel E-Billet ou directement depuis l'application. Nom : Mon Assistant TGV INOUI Date de naissance : en production depuis 2019 Domaine : assistance & info voyageur (info quai, infos voyage en cours, services \u00e0 bord), relai vers un agent Canaux : texte, sur Messenger (page Facebook TGV INOUI ) L'Agent virtuel SNCF \u00b6 L' Agent virtuel SNCF pr\u00e9sente de mani\u00e8re conversationnelle l'information voyageur et les \u00e9ventuelles perturbations sur tous les trains (TGV, IC, TER, Eurostar...). On peut interroger le bot par num\u00e9ro de train, dossier voyageur, prochains d\u00e9parts, etc. pour obtenir les derni\u00e8res informations et l'\u00e9tat du trafic. Accessible via la page Facebook de la SNCF, l' Agent virtuel est bas\u00e9 sur Tock. Nom : Agent virtuel SNCF Date de naissance : en production depuis 2019 Domaine : voyage & transport (\u00e9tat du trafic, travaux, prochains d\u00e9parts), relai vers un agent Canaux : texte, sur Messenger (page Facebook SNCF ) Eve , le bot interne e-voyageurs \u00b6 Eve est l'assistant interne des collaborateurs e-voyageurs SNCF . Le chatbot r\u00e9pond aux questions courantes, renvoie vers les bons contacts et outils collaboratifs de l'entreprise, automatise des demandes courantes au Support Informatique, Services G\u00e9n\u00e9raux, Direction Juridique, etc. Les \u00e9quipes Devops peuvent aussi lui demander l'\u00e9tat de la production, les prochaines interventions, voire d'effectuer directement certaines op\u00e9rations pour plus de simplicit\u00e9 et de r\u00e9activit\u00e9. Eve est \u00e0 l'\u00e9coute des collaborateurs dans l'entreprise et en mobilit\u00e9 sur Teams avec Tock. Nom : Eve Date de naissance : en production depuis 2019 Domaine : assistance en interne & B2B (FAQ, Support Informatique, RH, Juridique), automatisations DevOps (supervision, d\u00e9ploiements, gestion de production, etc.) Canaux : texte & voix, en interne dans l'entreprise et en mobilit\u00e9 via Teams Et vous ? \u00b6 La plateforme est suffisamment g\u00e9n\u00e9rique pour permettre de nombreux usages et l'int\u00e9gration de canaux internes ou externes. Si vous avez un doute sur les possibilit\u00e9s de Tock ou la faisabilit\u00e9 d'un nouveau projet, vous pouvez nous contacter pour en parler. Quant \u00e0 vos propres r\u00e9alisations, n'h\u00e9sitez pas \u00e0 les partager ! \ud83d\ude42","title":"Vitrine utilisateurs"},{"location":"apropos/vitrine/#vitrine-utilisateurs","text":"Depuis sa cr\u00e9ation pour OUI.sncf en 2016, Tock est utilis\u00e9 par de plus en plus d'\u00e9quipes pour cr\u00e9er des bots conversationnels d\u00e9di\u00e9s \u00e0 des usages divers : business to customer et business to business distribution, transactionnel, paiement assistance, care , help desks FAQ et arbres de d\u00e9cision Cette page pr\u00e9sente diff\u00e9rents assistants et produits construits avec Tock.","title":"Vitrine utilisateurs"},{"location":"apropos/vitrine/#ouibot-le-bot-ouisncf","text":"OUIbot est l'assistant conversationnel de OUI.sncf. Disponible depuis 2016 sur le r\u00e9seau social Facebook Messenger, OUIbot s'est construit avec les premi\u00e8res versions de Tock. Avec OUIbot, r\u00e9server un billet de train n'a jamais \u00e9t\u00e9 aussi simple ! Il vous assiste dans la pr\u00e9paration de vos voyages, permet d'effectuer rapidement et simplement une r\u00e9servation compl\u00e8te, de la recherche \u00e0 l'achat (paiement inclus), et vous accompagne durant votre voyage. Gr\u00e2ce aux nombreux connecteurs Tock, OUIbot r\u00e9pond pr\u00e9sent sur de nombreux canaux conversationnels : site www.oui.sncf , r\u00e9seaux sociaux, assistants vocaux, enceintes connect\u00e9es et m\u00eame IAffiches avec JCDecaux . En 2019, OUIbot accompagne pr\u00e8s de 10 000 utilisateurs par jour. Il a \u00e9t\u00e9 \u00e9lu Best Robot Experience pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive. Nom : OUIbot Date de naissance : en production depuis 2016 Domaine : distribution, transactionnel (r\u00e9servations, paiements), alertes & push notifications, relai vers un agent Canaux : texte & voix, sur le site Web entreprise, Messenger, WhatsApp, Business Chat (Messages), Google Assistant, Google Home, Alexa, IAffiches JCDecaux","title":"OUIbot, le bot OUI.sncf"},{"location":"apropos/vitrine/#lassistant-sncf","text":"L'Assistant SNCF est l'application mobile des voyageurs SNCF sur Android et iOS, couvrant le train mais aussi d'autres modes de transport. Avec l\u2019 Assistant SNCF , vous pouvez calculer votre itin\u00e9raire, rester inform\u00e9 en temps r\u00e9el, acheter directement vos tickets de transport ou encore r\u00e9server votre course en VTC. En attendant de nouvelles fonctionnalit\u00e9s \u00e0 venir. Accessible via le \"microphone\" dans l'application mobile, le bot conversationnel de l' Assistant SNCF est construit avec Tock et les fonctions speech-to-text Android et iOS. Nom : L'Assistant SNCF Date de naissance : en production, fonction vocale Tock depuis 2019 Domaine : voyage & transport (recherche itin\u00e9raires en multi-modal, etc.) Canaux : vocal, sur l'application mobile SNCF pour Android et iOS","title":"L'Assistant SNCF"},{"location":"apropos/vitrine/#tilien-le-chatbot-transilien","text":"Tilien est le chatbot Transilien sur Messenger. Con\u00e7u comme un compagnon de voyage personnel et amical, il informe des prochains d\u00e9parts, l'\u00e9tat du trafic, les travaux en cours et \u00e0 venir, propose des itin\u00e9raires et bien d'autres choses (plans des lignes, fiches horaires, etc.) sur l'ensemble du r\u00e9seau ferr\u00e9 Ile-De-France : M\u00e9tro, RER, Transilien, Tram. Motoris\u00e9 par Tock, le chatbot vous attend sur Facebook Messenger pour offrir ses services. Nom : Tilien Date de naissance : en production, depuis 2018 sur Tock Domaine : transport & assistance (recherche itin\u00e9raires, plans des lignes, \u00e9tat du trafic, etc.) Canaux : texte, sur Messenger","title":"Tilien, le chatbot Transilien"},{"location":"apropos/vitrine/#mon-assistant-tgv-inoui","text":"Mon Assistant informe les clients et voyageurs de la marque TGV INOUI avant, pendant et apr\u00e8s leur trajet. Le chatbot est capable de donner l'\u00e9tat du trafic, le quai de d\u00e9part d'un train, la ou les places du client, les services \u00e0 bord (le bar, les prises \u00e9lectriques, etc.). Il permet aussi de parler avec un agent SNCF tout en restant dans la m\u00eame conversation. Pr\u00e9sent sur la page Facebook TGV INOUI , l'assistant qui s'appuie sur Tock est \u00e9galement accessible depuis le SMS de rappel E-Billet ou directement depuis l'application. Nom : Mon Assistant TGV INOUI Date de naissance : en production depuis 2019 Domaine : assistance & info voyageur (info quai, infos voyage en cours, services \u00e0 bord), relai vers un agent Canaux : texte, sur Messenger (page Facebook TGV INOUI )","title":"Mon Assistant TGV INOUI"},{"location":"apropos/vitrine/#lagent-virtuel-sncf","text":"L' Agent virtuel SNCF pr\u00e9sente de mani\u00e8re conversationnelle l'information voyageur et les \u00e9ventuelles perturbations sur tous les trains (TGV, IC, TER, Eurostar...). On peut interroger le bot par num\u00e9ro de train, dossier voyageur, prochains d\u00e9parts, etc. pour obtenir les derni\u00e8res informations et l'\u00e9tat du trafic. Accessible via la page Facebook de la SNCF, l' Agent virtuel est bas\u00e9 sur Tock. Nom : Agent virtuel SNCF Date de naissance : en production depuis 2019 Domaine : voyage & transport (\u00e9tat du trafic, travaux, prochains d\u00e9parts), relai vers un agent Canaux : texte, sur Messenger (page Facebook SNCF )","title":"L'Agent virtuel SNCF"},{"location":"apropos/vitrine/#eve-le-bot-interne-e-voyageurs","text":"Eve est l'assistant interne des collaborateurs e-voyageurs SNCF . Le chatbot r\u00e9pond aux questions courantes, renvoie vers les bons contacts et outils collaboratifs de l'entreprise, automatise des demandes courantes au Support Informatique, Services G\u00e9n\u00e9raux, Direction Juridique, etc. Les \u00e9quipes Devops peuvent aussi lui demander l'\u00e9tat de la production, les prochaines interventions, voire d'effectuer directement certaines op\u00e9rations pour plus de simplicit\u00e9 et de r\u00e9activit\u00e9. Eve est \u00e0 l'\u00e9coute des collaborateurs dans l'entreprise et en mobilit\u00e9 sur Teams avec Tock. Nom : Eve Date de naissance : en production depuis 2019 Domaine : assistance en interne & B2B (FAQ, Support Informatique, RH, Juridique), automatisations DevOps (supervision, d\u00e9ploiements, gestion de production, etc.) Canaux : texte & voix, en interne dans l'entreprise et en mobilit\u00e9 via Teams","title":"Eve, le bot interne e-voyageurs"},{"location":"apropos/vitrine/#et-vous","text":"La plateforme est suffisamment g\u00e9n\u00e9rique pour permettre de nombreux usages et l'int\u00e9gration de canaux internes ou externes. Si vous avez un doute sur les possibilit\u00e9s de Tock ou la faisabilit\u00e9 d'un nouveau projet, vous pouvez nous contacter pour en parler. Quant \u00e0 vos propres r\u00e9alisations, n'h\u00e9sitez pas \u00e0 les partager ! \ud83d\ude42","title":"Et vous ?"},{"location":"dev/api/","text":"Les APIs Tock \u00b6 Cette section de la documentation Tock pr\u00e9sente sommairement les diff\u00e9rentes API fournies avec Tock. Tock NLU API \u00b6 L'API NLU de Tock (reconnaissance du langage naturel) permet d'interroger programmatiquement le mod\u00e8le conversationnel et d'analyser une phrase. La documentation de l'API Tock NLU est disponible dans /api . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/ . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/index.html . Tock Studio API \u00b6 De m\u00eame, la documentation de l'API Tock Studio est disponible dans /api/admin . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/admin.html . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/admin.html . Tock Bot API \u00b6 Cette API permet de d\u00e9velopper des bots Tock avec n'importe quel langage. Elle est utilis\u00e9e par les clients Kotlin en modes WebHook et WebSocket . L'API est toutefois encore en d\u00e9veloppement (b\u00e9ta) et sa documentation arrivera bient\u00f4t. Pour d\u00e9velopper en mode Bot API , voir cette page .","title":"Liste des APIs"},{"location":"dev/api/#les-apis-tock","text":"Cette section de la documentation Tock pr\u00e9sente sommairement les diff\u00e9rentes API fournies avec Tock.","title":"Les APIs Tock"},{"location":"dev/api/#tock-nlu-api","text":"L'API NLU de Tock (reconnaissance du langage naturel) permet d'interroger programmatiquement le mod\u00e8le conversationnel et d'analyser une phrase. La documentation de l'API Tock NLU est disponible dans /api . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/ . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/index.html .","title":"Tock NLU API"},{"location":"dev/api/#tock-studio-api","text":"De m\u00eame, la documentation de l'API Tock Studio est disponible dans /api/admin . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/admin.html . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/admin.html .","title":"Tock Studio API"},{"location":"dev/api/#tock-bot-api","text":"Cette API permet de d\u00e9velopper des bots Tock avec n'importe quel langage. Elle est utilis\u00e9e par les clients Kotlin en modes WebHook et WebSocket . L'API est toutefois encore en d\u00e9veloppement (b\u00e9ta) et sa documentation arrivera bient\u00f4t. Pour d\u00e9velopper en mode Bot API , voir cette page .","title":"Tock Bot API"},{"location":"dev/bot-api/","text":"D\u00e9velopper en mode Tock Bot API \u00b6 Le mode Bot API de Tock permet de d\u00e9velopper des bots en se connectant \u00e0 une plateforme Tock Studio en utilisant l'API REST conversationnelle de Tock. C'est donc le mode de d\u00e9veloppement Tock recommand\u00e9 pour d\u00e9marrer, ainsi que dans des scenarios ou l'acc\u00e8s partag\u00e9 \u00e0 la base de donn\u00e9es serait un probl\u00e8me. Seul le mode Bot API est disponible sur la plateforme de d\u00e9monstration publique Tock. Cette page pr\u00e9sente le d\u00e9veloppement de bots Tock en mode Bot API en Kotlin . Notez qu'il est possible de d\u00e9velopper dans n'importe quel langage via la Bot API . En particulier, un client nodejs est disponible. Une autre section pr\u00e9sente le mode Bot Framework , plus int\u00e9gr\u00e9 mais aussi plus coupl\u00e9 \u00e0 la plateforme Tock. Se connecter sur la plateforme de d\u00e9monstration \u00b6 Plut\u00f4t que d\u00e9ployer se propre plateforme Tock, il est possible de tester les modes WebSocket ou Webhook directement sur la plateforme de d\u00e9monstration Tock . D\u00e9velopper un bot en mode Bot API avec Kotlin \u00b6 Activer le mode WebSocket \u00b6 C'est le mode \u00e0 privil\u00e9gier au d\u00e9marrage car le plus simple \u00e0 mettre en oeuvre. Pour utiliser le client websocket, il faut ajouter la d\u00e9pendance tock-bot-api-websocket \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> 19.9.1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:tock-bot-api-websocket:19.9.1' Activer le mode WebHook \u00b6 De mani\u00e8re alternative, vous pouvez choisir d'utiliser le client WebHook , il faut ajouter la d\u00e9pendance tock-bot-api-webhook \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-webhook </artifactId> <version> 19.9.1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:tock-bot-api-webhook:19.9.1' Dans ce cas, contrairement au mode WebSocket , il faut que l'application/bot d\u00e9marr\u00e9e soit joignable par la plateforme Tock via une URL publique (vous pouvez utilisez par exemple ngrok ). Cette URL doit \u00eatre indiqu\u00e9e dans le champ webhook url dans la vue Configuration > Bot Configurations de l'interface Tock Studio . Param\u00e9trer la cl\u00e9 d'API \u00b6 Dans Tock Studio , apr\u00e8s avoir configur\u00e9 un bot, allez dans Configuration > Bot Configurations et copiez la cl\u00e9 d'API du bot auquel vous souhaitez vous connecter. Vous pourrez saisir/coller cette clef dans le code Kotlin (voir ci-dessous). Cr\u00e9er des parcours en Kotlin \u00b6 Pour le moment, les composants suivants sont support\u00e9s pour les r\u00e9ponses : Texte avec Boutons (Quick Reply) Format \"carte\" Format \"carousel\" Formats sp\u00e9cifiques aux diff\u00e9rents canaux int\u00e9gr\u00e9s Voici un exemple de bot simple avec quelques parcours d\u00e9clar\u00e9s : fun main () { startWithDemo ( newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // R\u00e9cup\u00e9rer la cl\u00e9 d'API \u00e0 partir de l'onglet \"Bot Configurations\" dans Tock Studio newStory ( \"greetings\" ) { // Intention 'greetings' end ( \"Bonjour!\" ) // R\u00e9ponse texte simple }, newStory ( \"location\" ) { // Intention 'location' end ( // R\u00e9ponse avec une carte - pouvant inclure du texte, un fichier (par exemple une image) et des suggestions d'action utilisateur newCard ( \"Le titre de la carte\" , \"Un sous-titre\" , newAttachment ( \"https://url-image.png\" ), newAction ( \"Action 1\" ), newAction ( \"Action 2\" , \"http://redirection\" ) ) ) }, newStory ( \"goodbye\" ) { // Intention 'goodbye' end { // R\u00e9ponse sp\u00e9cifique au format Messenger buttonsTemplate ( \"Etes-vous s\u00fbr(e) de vouloir partir ?\" , nlpQuickReply ( \"Je reste\" )) } }, // R\u00e9ponse fournie pas le bot en cas d'incompr\u00e9hension unknownStory { end ( \"Je n'ai pas compris. Mais j'apprends tous les jours :)\" ) } ) ) } Le code source complet de l'exemple est disponible. D\u00e9velopper dans un autre langage \u00b6 Node \u00b6 Veuillez consulter la documentation d\u00e9di\u00e9e au client nodejs pour plus de d\u00e9tails. API \u00b6 Il est possible de d\u00e9velopper dans n'importe quel langage en programmant directement via l'API. Installer Bot API sur vos propres serveurs \u00b6 Pour utiliser le mode Bot API de Tock, un module sp\u00e9cifique doit \u00eatre d\u00e9ploy\u00e9 avec la plateforme. G\u00e9n\u00e9ralement appel\u00e9 bot-api dans les descripteurs Docker Compose par exemple, ce service a pour r\u00f4le : D'exposer la Bot API aux clients potentiels quelque soit leur langage de programmation D'accepter des connexions en WebSocket et/ou de se connecter au webhook configur\u00e9 Le guide D\u00e9ployer Tock avec Docker ou encore le chapitre Installation montrent comment d\u00e9ployer ce module si n\u00e9cessaire. La seule modification n\u00e9cessaire par rapport au code d'exemple pour la platforme de d\u00e9monstration est de remplacer la m\u00e9thode startWithDemo par start en pr\u00e9cisant si besoin l'adresse de du serveur bot-api .","title":"Tock Bot API"},{"location":"dev/bot-api/#developper-en-mode-tock-bot-api","text":"Le mode Bot API de Tock permet de d\u00e9velopper des bots en se connectant \u00e0 une plateforme Tock Studio en utilisant l'API REST conversationnelle de Tock. C'est donc le mode de d\u00e9veloppement Tock recommand\u00e9 pour d\u00e9marrer, ainsi que dans des scenarios ou l'acc\u00e8s partag\u00e9 \u00e0 la base de donn\u00e9es serait un probl\u00e8me. Seul le mode Bot API est disponible sur la plateforme de d\u00e9monstration publique Tock. Cette page pr\u00e9sente le d\u00e9veloppement de bots Tock en mode Bot API en Kotlin . Notez qu'il est possible de d\u00e9velopper dans n'importe quel langage via la Bot API . En particulier, un client nodejs est disponible. Une autre section pr\u00e9sente le mode Bot Framework , plus int\u00e9gr\u00e9 mais aussi plus coupl\u00e9 \u00e0 la plateforme Tock.","title":"D\u00e9velopper en mode Tock Bot API"},{"location":"dev/bot-api/#se-connecter-sur-la-plateforme-de-demonstration","text":"Plut\u00f4t que d\u00e9ployer se propre plateforme Tock, il est possible de tester les modes WebSocket ou Webhook directement sur la plateforme de d\u00e9monstration Tock .","title":"Se connecter sur la plateforme de d\u00e9monstration"},{"location":"dev/bot-api/#developper-un-bot-en-mode-bot-api-avec-kotlin","text":"","title":"D\u00e9velopper un bot en mode Bot API avec Kotlin"},{"location":"dev/bot-api/#activer-le-mode-websocket","text":"C'est le mode \u00e0 privil\u00e9gier au d\u00e9marrage car le plus simple \u00e0 mettre en oeuvre. Pour utiliser le client websocket, il faut ajouter la d\u00e9pendance tock-bot-api-websocket \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> 19.9.1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:tock-bot-api-websocket:19.9.1'","title":"Activer le mode WebSocket"},{"location":"dev/bot-api/#activer-le-mode-webhook","text":"De mani\u00e8re alternative, vous pouvez choisir d'utiliser le client WebHook , il faut ajouter la d\u00e9pendance tock-bot-api-webhook \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-webhook </artifactId> <version> 19.9.1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:tock-bot-api-webhook:19.9.1' Dans ce cas, contrairement au mode WebSocket , il faut que l'application/bot d\u00e9marr\u00e9e soit joignable par la plateforme Tock via une URL publique (vous pouvez utilisez par exemple ngrok ). Cette URL doit \u00eatre indiqu\u00e9e dans le champ webhook url dans la vue Configuration > Bot Configurations de l'interface Tock Studio .","title":"Activer le mode WebHook"},{"location":"dev/bot-api/#parametrer-la-cle-dapi","text":"Dans Tock Studio , apr\u00e8s avoir configur\u00e9 un bot, allez dans Configuration > Bot Configurations et copiez la cl\u00e9 d'API du bot auquel vous souhaitez vous connecter. Vous pourrez saisir/coller cette clef dans le code Kotlin (voir ci-dessous).","title":"Param\u00e9trer la cl\u00e9 d'API"},{"location":"dev/bot-api/#creer-des-parcours-en-kotlin","text":"Pour le moment, les composants suivants sont support\u00e9s pour les r\u00e9ponses : Texte avec Boutons (Quick Reply) Format \"carte\" Format \"carousel\" Formats sp\u00e9cifiques aux diff\u00e9rents canaux int\u00e9gr\u00e9s Voici un exemple de bot simple avec quelques parcours d\u00e9clar\u00e9s : fun main () { startWithDemo ( newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // R\u00e9cup\u00e9rer la cl\u00e9 d'API \u00e0 partir de l'onglet \"Bot Configurations\" dans Tock Studio newStory ( \"greetings\" ) { // Intention 'greetings' end ( \"Bonjour!\" ) // R\u00e9ponse texte simple }, newStory ( \"location\" ) { // Intention 'location' end ( // R\u00e9ponse avec une carte - pouvant inclure du texte, un fichier (par exemple une image) et des suggestions d'action utilisateur newCard ( \"Le titre de la carte\" , \"Un sous-titre\" , newAttachment ( \"https://url-image.png\" ), newAction ( \"Action 1\" ), newAction ( \"Action 2\" , \"http://redirection\" ) ) ) }, newStory ( \"goodbye\" ) { // Intention 'goodbye' end { // R\u00e9ponse sp\u00e9cifique au format Messenger buttonsTemplate ( \"Etes-vous s\u00fbr(e) de vouloir partir ?\" , nlpQuickReply ( \"Je reste\" )) } }, // R\u00e9ponse fournie pas le bot en cas d'incompr\u00e9hension unknownStory { end ( \"Je n'ai pas compris. Mais j'apprends tous les jours :)\" ) } ) ) } Le code source complet de l'exemple est disponible.","title":"Cr\u00e9er des parcours en Kotlin"},{"location":"dev/bot-api/#developper-dans-un-autre-langage","text":"","title":"D\u00e9velopper dans un autre langage"},{"location":"dev/bot-api/#node","text":"Veuillez consulter la documentation d\u00e9di\u00e9e au client nodejs pour plus de d\u00e9tails.","title":"Node"},{"location":"dev/bot-api/#api","text":"Il est possible de d\u00e9velopper dans n'importe quel langage en programmant directement via l'API.","title":"API"},{"location":"dev/bot-api/#installer-bot-api-sur-vos-propres-serveurs","text":"Pour utiliser le mode Bot API de Tock, un module sp\u00e9cifique doit \u00eatre d\u00e9ploy\u00e9 avec la plateforme. G\u00e9n\u00e9ralement appel\u00e9 bot-api dans les descripteurs Docker Compose par exemple, ce service a pour r\u00f4le : D'exposer la Bot API aux clients potentiels quelque soit leur langage de programmation D'accepter des connexions en WebSocket et/ou de se connecter au webhook configur\u00e9 Le guide D\u00e9ployer Tock avec Docker ou encore le chapitre Installation montrent comment d\u00e9ployer ce module si n\u00e9cessaire. La seule modification n\u00e9cessaire par rapport au code d'exemple pour la platforme de d\u00e9monstration est de remplacer la m\u00e9thode startWithDemo par start en pr\u00e9cisant si besoin l'adresse de du serveur bot-api .","title":"Installer Bot API sur vos propres serveurs"},{"location":"dev/bot-integre/","text":"D\u00e9velopper en mode Tock Bot int\u00e9gr\u00e9 \u00b6 Le mode Bot int\u00e9gr\u00e9 Tock permet de d\u00e9velopper un bot en utilisant un Domain Specifique Language (DSL) en Kotlin . Contrairement au mode Bot API encore en d\u00e9veloppement, le Bot Framework Kotlin permet d'exploiter toutes les possibilit\u00e9s de la plateforme Tock, notamment : Gestion des contextes utilisateurs Historique de conversation Notions avanc\u00e9es comme la fusion d'entit\u00e9s Etc. Exemple de fusion d'entit\u00e9s : lorsque un utilisateur demande \"demain\" dans une phrase (appelons cette entit\u00e9 date ) puis \"plut\u00f4t le soir\" dans une phrase suivante, la fusion permet de mettre \u00e0 jour automatiquement l'entit\u00e9 ( date ) avec les deux informations compl\u00e9mentaires : jour et cr\u00e9neau horaire dans cet exemple. Attention : dans ce mode de d\u00e9veloppement, contrairement au mode Bot API , il est n\u00e9cessaire que le module bot dispose d'une connexion \u00e0 la base de donn\u00e9e (MongoDB) de la plateforme Tock utilis\u00e9e. Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage de programmation Kotlin . D\u00e9marrer avec le framework \u00b6 Documentation KDoc \u00b6 La documentation du framework au format KDoc est disponible ici . D\u00e9pendance bot-toolkit \u00b6 Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance bot-tookit \u00e0 l'application / au projet Kotlin. Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> bot-toolkit </artifactId> <version> 19.9.1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:bot-toolkit:19.9.1' Un bot est un ensemble de parcours (stories) \u00b6 Voici par exemple comment le Bot Open Data est d\u00e9fini : val openBot = bot ( \"bot_open_data\" , stories = listOf ( greetings , departures , arrivals , search ), hello = greetings ) Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de parcours ou stories . Une Story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\" (voir Concepts ). Ici le bot d\u00e9finit 4 parcours : greetings , departures , arrivals et search . Le parcours greetings est d\u00e9clar\u00e9 comme parcours principal, il sera pr\u00e9sent\u00e9 par d\u00e9faut au d\u00e9but d'une conversation : hello = greetings . Une Story simple \u00b6 Comment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e du parcours greetings : val greetings = story ( \"greetings\" ) { send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) end ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) } Notez que dans le corps de la fonction, this est de type BotBus , \u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der \u00e0 tous les \u00e9lements contextuels disponibles. Concr\u00e8tement sela signifie que quand l'intention greetings sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock. Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse ( bus.send() ), puis un deuxi\u00e8me en indiquant que c'est la derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un bus.end() . Voici maintenant la version compl\u00e8te de greetings : val greetings = story ( \"greetings\" ) { //cleanup state resetDialogState () send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) send ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) withMessenger { buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) } withGoogleAssistant { gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) } end () } Deux notions ont \u00e9t\u00e9 ajout\u00e9es : resetDialogState() qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents) les m\u00e9thodes withMessenger{} et withGoogleAssistant{} qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur. Ici un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant. D\u00e9marrer et connecter le bot \u00b6 Pour d\u00e9marrer le bot, il suffit de rajouter dans votre main principal l'appel suivant : registerAndInstallBot ( openBot ) La variable openBot dans l'exemple est le bot que vous avez d\u00e9fini plus haut. Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s dans l'interface d'administration du bot, du menu Configuration > Bot Configurations > Create a new configuration . Pour en savoir plus sur les diff\u00e9rents canaux et connecteurs, voir cette page . Aller plus loin \u00b6 Bien s\u00fbr, le StoryHandler de greetings ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame. Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire. Intentions secondaires \u00b6 Voici le d\u00e9but de la d\u00e9finition de la story search : val search = storyDef < SearchDef >( \"search\" , otherStarterIntents = setOf ( indicate_origin ), secondaryIntents = setOf ( indicate_location )) { } Le parcours search d\u00e9finit une intention secondaire \"de d\u00e9marrage\" ( indicate_origin ) et une intention secondaire simple ( indicate_location ). Une intention secondaire \"de d\u00e9marrage\" est semblable en tout point \u00e0 une intention principale : d\u00e8s que cette intention est d\u00e9tect\u00e9e, le parcours search va \u00eatre ex\u00e9cut\u00e9, si la story courante ne poss\u00e8de pas cette intention en tant qu'intention secondaire. Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte est \"d\u00e9j\u00e0\" la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires. Manipuler les entit\u00e9s \u00b6 Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des extensions . Par exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 destination : val destinationEntity = openBot . entity ( \"location\" , \"destination\" ) var BotBus . destination : Place ? get () = place ( destinationEntity ) set ( value ) = setPlace ( destinationEntity , value ) private fun BotBus . place ( entity : Entity ): Place ? = entityValue ( entity , :: placeValue ) ?. place private fun BotBus . setPlace ( entity : Entity , place : Place ?) = changeEntityValue ( entity , place ?. let { PlaceValue ( place ) }) Une entit\u00e9 de type location et de role destination est cr\u00e9\u00e9e. Il s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP. Une variable destination est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier. Cette variable contient la valeur actuelle de la destination dans le contexte utilisateur. Voici une version compl\u00e9t\u00e9e de la story search qui utilise destination : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0. Idem pour l'origine ou la date de d\u00e9part. Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe ( SearchDef ). La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //handle generic location intent if ( isIntent ( indicate_location ) && location != null ) { if ( destination == null || origin != null ) { destination = returnsAndRemoveLocation () } else { origin = returnsAndRemoveLocation () } } //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est indicate_location , nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination. Il est donc cod\u00e9 une r\u00e8gle simple : Si il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination. Sinon, il s'agit de l'origine. Utiliser HandlerDef \u00b6 Dans la d\u00e9finition de la story search ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique SearchDef . Voici le code de cette classe : @GAHandler ( GASearchConnector :: class ) @MessengerHandler ( MessengerSearchConnector :: class ) class SearchDef ( bus : BotBus ) : HandlerDef < SearchConnector >( bus ) { private val d : Place = bus . destination !! private val o : Place = bus . origin !! private val date : LocalDateTime = bus . departureDate !! override fun answer () { send ( \"De {0} \u00e0 {1}\" , o , d ) send ( \"D\u00e9part le {0}\" , date by datetimeFormat ) val journeys = SncfOpenDataClient . journey ( o , d , date ) if ( journeys . isEmpty ()) { end ( \"D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :(\" ) } else { send ( \"Voici la premi\u00e8re proposition :\" ) connector ?. sendFirstJourney ( journeys . first ()) end () } } } SearchDef \u00e9tend HandlerDef qui est un alias d'une classe du framework Tock. C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des parcours complexes. Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire : SearchConnector . SearchConnector est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations @GAHandler(GASearchConnector::class) et @MessengerHandler(MessengerSearchConnector::class) indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger). Que se passerait-il s'il n'y avait pas de connecteur pour Google Assistant par exemple ? La m\u00e9thode connector?.sendFirstJourney(journeys.first()) n'enverrait pas la r\u00e9ponse finale, puisque connector serait null . Utiliser ConnectorDef \u00b6 Voici maintenant une version simplifi\u00e9e de SearchConnector : sealed class SearchConnector ( context : SearchDef ) : ConnectorDef < SearchDef >( context ) { fun Section . title (): CharSequence = i18n ( \"{0} - {1}\" , from , to ) fun sendFirstJourney ( journey : Journey ) = withMessage ( sendFirstJourney ( journey . publicTransportSections ())) abstract fun sendFirstJourney ( sections : List < Section >): ConnectorMessage } Et voici son impl\u00e9mentation pour Messenger : class MessengerSearchConnector ( context : SearchDef ) : SearchConnector ( context ) { override fun sendFirstJourney ( sections : List < Section >): ConnectorMessage = flexibleListTemplate ( sections . map { section -> with ( section ) { listElement ( title (), content (), trainImage ) } }, compact ) } Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans SearchConnector et le comportement sp\u00e9cifique \u00e0 chaque connecteur se trouve dans les classes d\u00e9di\u00e9es. Utiliser StoryStep \u00b6 Parfois il est n\u00e9cessaire de se souvenir de l'\u00e9tape \u00e0 laquelle l'utilisateur se trouve dans la story courante. Pour cela Tock met \u00e0 disposition la notion de StoryStep . Il existe deux types de StoryStep : SimpleStoryStep \u00b6 A utiliser dans les cas simples, pour lequels on va g\u00e9rer le comportement induit directement : enum class MyStep : SimpleStoryStep { a , b } val story = storyWithSteps < MyStep >( \"intent\" ) { if ( step == a ) { // ... } else if ( step == b ) { // ... } else { //default case } } Pour modifier l'\u00e9tape courante, deux m\u00e9thodes sont disponibles : Modifier manuellement l'\u00e9tape val story = storyWithSteps < MyStep >( \"intent\" ) { //(...) step = MyStep . a // l'\u00e9tape sera persist\u00e9e tant que nous resterons dans cette story } Utiliser les boutons ou autres quick replies Plus de d\u00e9tails sur ce sujet plus bas . Les StoryStep avec comportement \u00b6 Dans des cas plus complexes, on souhaite pouvoir d\u00e9finir un comportement pour chaque \u00e9tape. L'utilisation de HandlerDef est alors un pr\u00e9requis. enum class MySteps : StoryStep < MyHandlerDef > { //pas de comportement sp\u00e9cifique display , select { // la step \"select\" sera automatiquement s\u00e9lectionn\u00e9e si la sous-intention select est d\u00e9tect\u00e9e override val intent : IntentAware ? = SecondaryIntent . select //dans ce cas la r\u00e9ponse suivante sera apport\u00e9e override fun answer (): MyHandlerDef .() -> Any ? = { end ( \"I don't know yet how to select something\" ) } }, disruption { //seule la r\u00e9ponse est configur\u00e9e override fun answer (): ScoreboardDef .() -> Any ? = { end ( \"some perturbation\" ) } }; } Davantage d'options de configuration sont disponibles. Consultez la description de StoryStep . Postback buttons & quick replies \u00b6 Messenger met \u00e0 disposition ce type de bouton, et la plupart des connecteurs avec interface graphique font de m\u00eame. Tock permet de d\u00e9finir l'action effectu\u00e9e suite \u00e0 un clic sur ces boutons. Dans l'exemple suivant, le bouton redirigera vers l'intention search . buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , search ) ) Il est possible de d\u00e9finir \u00e9galement une StoryStep et des param\u00e8tres d\u00e9di\u00e9s : //pour d\u00e9finir des param\u00e8tres, la pratique recommand\u00e9e est d'\u00e9tendre l'interface ParameterKey enum class ChoiceParameter : ParameterKey { nextResultDate , nextResultOrigin } buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , intent = search , //si aucune step n'est indiqu\u00e9e, c'est la step courante qui est utilis\u00e9e step = MyStep . a , parameters = //ce param\u00e8tre est stock\u00e9 sous forme de cha\u00eene de caract\u00e8re (les crochets sont utilis\u00e9s) nextResultDate [ nextDate ] + //ce param\u00e8tre est stock\u00e9 en json (les parenth\u00e8ses sont utilis\u00e9es) nextResultOrigin ( origin ) ) ) Pour r\u00e9cup\u00e9rer les param\u00e8tres du bouton sur lequel on a cliqu\u00e9 : val isClick = isChoiceAction () val nextDate = choice ( nextResultDate ) val nextOrigin : Locality = action . jsonChoice ( nextResultOrigin ) Tests Unitaires \u00b6 La page Tests Unitaires pr\u00e9sente le framework fourni pour r\u00e9aliser des TUs avec Tock.","title":"Tock Bot int\u00e9gr\u00e9"},{"location":"dev/bot-integre/#developper-en-mode-tock-bot-integre","text":"Le mode Bot int\u00e9gr\u00e9 Tock permet de d\u00e9velopper un bot en utilisant un Domain Specifique Language (DSL) en Kotlin . Contrairement au mode Bot API encore en d\u00e9veloppement, le Bot Framework Kotlin permet d'exploiter toutes les possibilit\u00e9s de la plateforme Tock, notamment : Gestion des contextes utilisateurs Historique de conversation Notions avanc\u00e9es comme la fusion d'entit\u00e9s Etc. Exemple de fusion d'entit\u00e9s : lorsque un utilisateur demande \"demain\" dans une phrase (appelons cette entit\u00e9 date ) puis \"plut\u00f4t le soir\" dans une phrase suivante, la fusion permet de mettre \u00e0 jour automatiquement l'entit\u00e9 ( date ) avec les deux informations compl\u00e9mentaires : jour et cr\u00e9neau horaire dans cet exemple. Attention : dans ce mode de d\u00e9veloppement, contrairement au mode Bot API , il est n\u00e9cessaire que le module bot dispose d'une connexion \u00e0 la base de donn\u00e9e (MongoDB) de la plateforme Tock utilis\u00e9e. Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage de programmation Kotlin .","title":"D\u00e9velopper en mode Tock Bot int\u00e9gr\u00e9"},{"location":"dev/bot-integre/#demarrer-avec-le-framework","text":"","title":"D\u00e9marrer avec le framework"},{"location":"dev/bot-integre/#documentation-kdoc","text":"La documentation du framework au format KDoc est disponible ici .","title":"Documentation KDoc"},{"location":"dev/bot-integre/#dependance-bot-toolkit","text":"Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance bot-tookit \u00e0 l'application / au projet Kotlin. Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> bot-toolkit </artifactId> <version> 19.9.1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:bot-toolkit:19.9.1'","title":"D\u00e9pendance bot-toolkit"},{"location":"dev/bot-integre/#un-bot-est-un-ensemble-de-parcours-stories","text":"Voici par exemple comment le Bot Open Data est d\u00e9fini : val openBot = bot ( \"bot_open_data\" , stories = listOf ( greetings , departures , arrivals , search ), hello = greetings ) Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de parcours ou stories . Une Story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\" (voir Concepts ). Ici le bot d\u00e9finit 4 parcours : greetings , departures , arrivals et search . Le parcours greetings est d\u00e9clar\u00e9 comme parcours principal, il sera pr\u00e9sent\u00e9 par d\u00e9faut au d\u00e9but d'une conversation : hello = greetings .","title":"Un bot est un ensemble de parcours (stories)"},{"location":"dev/bot-integre/#une-story-simple","text":"Comment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e du parcours greetings : val greetings = story ( \"greetings\" ) { send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) end ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) } Notez que dans le corps de la fonction, this est de type BotBus , \u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der \u00e0 tous les \u00e9lements contextuels disponibles. Concr\u00e8tement sela signifie que quand l'intention greetings sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock. Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse ( bus.send() ), puis un deuxi\u00e8me en indiquant que c'est la derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un bus.end() . Voici maintenant la version compl\u00e8te de greetings : val greetings = story ( \"greetings\" ) { //cleanup state resetDialogState () send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) send ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) withMessenger { buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) } withGoogleAssistant { gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) } end () } Deux notions ont \u00e9t\u00e9 ajout\u00e9es : resetDialogState() qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents) les m\u00e9thodes withMessenger{} et withGoogleAssistant{} qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur. Ici un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant.","title":"Une Story simple"},{"location":"dev/bot-integre/#demarrer-et-connecter-le-bot","text":"Pour d\u00e9marrer le bot, il suffit de rajouter dans votre main principal l'appel suivant : registerAndInstallBot ( openBot ) La variable openBot dans l'exemple est le bot que vous avez d\u00e9fini plus haut. Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s dans l'interface d'administration du bot, du menu Configuration > Bot Configurations > Create a new configuration . Pour en savoir plus sur les diff\u00e9rents canaux et connecteurs, voir cette page .","title":"D\u00e9marrer et connecter le bot"},{"location":"dev/bot-integre/#aller-plus-loin","text":"Bien s\u00fbr, le StoryHandler de greetings ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame. Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire.","title":"Aller plus loin"},{"location":"dev/bot-integre/#intentions-secondaires","text":"Voici le d\u00e9but de la d\u00e9finition de la story search : val search = storyDef < SearchDef >( \"search\" , otherStarterIntents = setOf ( indicate_origin ), secondaryIntents = setOf ( indicate_location )) { } Le parcours search d\u00e9finit une intention secondaire \"de d\u00e9marrage\" ( indicate_origin ) et une intention secondaire simple ( indicate_location ). Une intention secondaire \"de d\u00e9marrage\" est semblable en tout point \u00e0 une intention principale : d\u00e8s que cette intention est d\u00e9tect\u00e9e, le parcours search va \u00eatre ex\u00e9cut\u00e9, si la story courante ne poss\u00e8de pas cette intention en tant qu'intention secondaire. Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte est \"d\u00e9j\u00e0\" la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires.","title":"Intentions secondaires"},{"location":"dev/bot-integre/#manipuler-les-entites","text":"Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des extensions . Par exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 destination : val destinationEntity = openBot . entity ( \"location\" , \"destination\" ) var BotBus . destination : Place ? get () = place ( destinationEntity ) set ( value ) = setPlace ( destinationEntity , value ) private fun BotBus . place ( entity : Entity ): Place ? = entityValue ( entity , :: placeValue ) ?. place private fun BotBus . setPlace ( entity : Entity , place : Place ?) = changeEntityValue ( entity , place ?. let { PlaceValue ( place ) }) Une entit\u00e9 de type location et de role destination est cr\u00e9\u00e9e. Il s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP. Une variable destination est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier. Cette variable contient la valeur actuelle de la destination dans le contexte utilisateur. Voici une version compl\u00e9t\u00e9e de la story search qui utilise destination : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0. Idem pour l'origine ou la date de d\u00e9part. Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe ( SearchDef ). La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //handle generic location intent if ( isIntent ( indicate_location ) && location != null ) { if ( destination == null || origin != null ) { destination = returnsAndRemoveLocation () } else { origin = returnsAndRemoveLocation () } } //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est indicate_location , nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination. Il est donc cod\u00e9 une r\u00e8gle simple : Si il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination. Sinon, il s'agit de l'origine.","title":"Manipuler les entit\u00e9s"},{"location":"dev/bot-integre/#utiliser-handlerdef","text":"Dans la d\u00e9finition de la story search ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique SearchDef . Voici le code de cette classe : @GAHandler ( GASearchConnector :: class ) @MessengerHandler ( MessengerSearchConnector :: class ) class SearchDef ( bus : BotBus ) : HandlerDef < SearchConnector >( bus ) { private val d : Place = bus . destination !! private val o : Place = bus . origin !! private val date : LocalDateTime = bus . departureDate !! override fun answer () { send ( \"De {0} \u00e0 {1}\" , o , d ) send ( \"D\u00e9part le {0}\" , date by datetimeFormat ) val journeys = SncfOpenDataClient . journey ( o , d , date ) if ( journeys . isEmpty ()) { end ( \"D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :(\" ) } else { send ( \"Voici la premi\u00e8re proposition :\" ) connector ?. sendFirstJourney ( journeys . first ()) end () } } } SearchDef \u00e9tend HandlerDef qui est un alias d'une classe du framework Tock. C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des parcours complexes. Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire : SearchConnector . SearchConnector est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations @GAHandler(GASearchConnector::class) et @MessengerHandler(MessengerSearchConnector::class) indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger). Que se passerait-il s'il n'y avait pas de connecteur pour Google Assistant par exemple ? La m\u00e9thode connector?.sendFirstJourney(journeys.first()) n'enverrait pas la r\u00e9ponse finale, puisque connector serait null .","title":"Utiliser HandlerDef"},{"location":"dev/bot-integre/#utiliser-connectordef","text":"Voici maintenant une version simplifi\u00e9e de SearchConnector : sealed class SearchConnector ( context : SearchDef ) : ConnectorDef < SearchDef >( context ) { fun Section . title (): CharSequence = i18n ( \"{0} - {1}\" , from , to ) fun sendFirstJourney ( journey : Journey ) = withMessage ( sendFirstJourney ( journey . publicTransportSections ())) abstract fun sendFirstJourney ( sections : List < Section >): ConnectorMessage } Et voici son impl\u00e9mentation pour Messenger : class MessengerSearchConnector ( context : SearchDef ) : SearchConnector ( context ) { override fun sendFirstJourney ( sections : List < Section >): ConnectorMessage = flexibleListTemplate ( sections . map { section -> with ( section ) { listElement ( title (), content (), trainImage ) } }, compact ) } Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans SearchConnector et le comportement sp\u00e9cifique \u00e0 chaque connecteur se trouve dans les classes d\u00e9di\u00e9es.","title":"Utiliser ConnectorDef"},{"location":"dev/bot-integre/#utiliser-storystep","text":"Parfois il est n\u00e9cessaire de se souvenir de l'\u00e9tape \u00e0 laquelle l'utilisateur se trouve dans la story courante. Pour cela Tock met \u00e0 disposition la notion de StoryStep . Il existe deux types de StoryStep :","title":"Utiliser StoryStep"},{"location":"dev/bot-integre/#simplestorystep","text":"A utiliser dans les cas simples, pour lequels on va g\u00e9rer le comportement induit directement : enum class MyStep : SimpleStoryStep { a , b } val story = storyWithSteps < MyStep >( \"intent\" ) { if ( step == a ) { // ... } else if ( step == b ) { // ... } else { //default case } } Pour modifier l'\u00e9tape courante, deux m\u00e9thodes sont disponibles : Modifier manuellement l'\u00e9tape val story = storyWithSteps < MyStep >( \"intent\" ) { //(...) step = MyStep . a // l'\u00e9tape sera persist\u00e9e tant que nous resterons dans cette story } Utiliser les boutons ou autres quick replies Plus de d\u00e9tails sur ce sujet plus bas .","title":"SimpleStoryStep"},{"location":"dev/bot-integre/#les-storystep-avec-comportement","text":"Dans des cas plus complexes, on souhaite pouvoir d\u00e9finir un comportement pour chaque \u00e9tape. L'utilisation de HandlerDef est alors un pr\u00e9requis. enum class MySteps : StoryStep < MyHandlerDef > { //pas de comportement sp\u00e9cifique display , select { // la step \"select\" sera automatiquement s\u00e9lectionn\u00e9e si la sous-intention select est d\u00e9tect\u00e9e override val intent : IntentAware ? = SecondaryIntent . select //dans ce cas la r\u00e9ponse suivante sera apport\u00e9e override fun answer (): MyHandlerDef .() -> Any ? = { end ( \"I don't know yet how to select something\" ) } }, disruption { //seule la r\u00e9ponse est configur\u00e9e override fun answer (): ScoreboardDef .() -> Any ? = { end ( \"some perturbation\" ) } }; } Davantage d'options de configuration sont disponibles. Consultez la description de StoryStep .","title":"Les StoryStep avec comportement"},{"location":"dev/bot-integre/#postback-buttons-quick-replies","text":"Messenger met \u00e0 disposition ce type de bouton, et la plupart des connecteurs avec interface graphique font de m\u00eame. Tock permet de d\u00e9finir l'action effectu\u00e9e suite \u00e0 un clic sur ces boutons. Dans l'exemple suivant, le bouton redirigera vers l'intention search . buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , search ) ) Il est possible de d\u00e9finir \u00e9galement une StoryStep et des param\u00e8tres d\u00e9di\u00e9s : //pour d\u00e9finir des param\u00e8tres, la pratique recommand\u00e9e est d'\u00e9tendre l'interface ParameterKey enum class ChoiceParameter : ParameterKey { nextResultDate , nextResultOrigin } buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , intent = search , //si aucune step n'est indiqu\u00e9e, c'est la step courante qui est utilis\u00e9e step = MyStep . a , parameters = //ce param\u00e8tre est stock\u00e9 sous forme de cha\u00eene de caract\u00e8re (les crochets sont utilis\u00e9s) nextResultDate [ nextDate ] + //ce param\u00e8tre est stock\u00e9 en json (les parenth\u00e8ses sont utilis\u00e9es) nextResultOrigin ( origin ) ) ) Pour r\u00e9cup\u00e9rer les param\u00e8tres du bouton sur lequel on a cliqu\u00e9 : val isClick = isChoiceAction () val nextDate = choice ( nextResultDate ) val nextOrigin : Locality = action . jsonChoice ( nextResultOrigin )","title":"Postback buttons &amp; quick replies"},{"location":"dev/bot-integre/#tests-unitaires","text":"La page Tests Unitaires pr\u00e9sente le framework fourni pour r\u00e9aliser des TUs avec Tock.","title":"Tests Unitaires"},{"location":"dev/connecteurs/","text":"Les connecteurs Tock \u00b6 La page Bot multicanal de la documentation utilisateur pr\u00e9sente la notion de connecteur Tock, ainsi que la liste des connecteurs d\u00e9j\u00e0 disponibles. Cette page n'ajoute donc que les \u00e9l\u00e9ments propres au d\u00e9veloppement avec les connecteurs Tock ou le d\u00e9veloppement de nouveaux connecteurs. Messenger \u00b6 Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-messenger sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Slack \u00b6 Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Google Assistant / Google Home \u00b6 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-ga sur GitHub. Alexa / Echo \u00b6 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-alexa sur GitHub. Rocket.Chat \u00b6 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-rocketchat sur GitHub. WhatsApp \u00b6 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-whatsapp sur GitHub. Teams \u00b6 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-teams sur GitHub. Business Chat / iMessages \u00b6 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-businesschat sur GitHub. Twitter \u00b6 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-twitter sur GitHub. Web \u00b6 Ce connecteur permet de d\u00e9ployer une API REST d\u00e9di\u00e9e \u00e0 la cr\u00e9ation d'un chatbot sur une interface Web par exemple. Consultez ses sources et son README dans le dossier connector-web sur GitHub. D\u00e9velopper son propre connecteur \u00b6 Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. Un exemple de connecteur sp\u00e9cifique est disponible dans le projet d'exemple Bot Open Data . Pour d\u00e9finir son propre connecteur, quatres \u00e9tapes sont n\u00e9cessaires : 1) Impl\u00e9menter l'interface Connector Voici un exemple d'impl\u00e9mentation : val testConnectorType = ConnectorType ( \"test\" ) class TestConnector ( val applicationId : String , val path : String ) : Connector { override val connectorType : ConnectorType = testConnectorType override fun register ( controller : ConnectorController ) { controller . registerServices ( path ) { router -> //main API router . post ( \"$path/message\" ). blockingHandler { context -> //ConnectorRequest est mon objet m\u00e9tier pass\u00e9 par l'appli front val message : ConnectorRequest = mapper . readValue ( context . bodyAsString ) //transformation de l'objet m\u00e9tier en Event tock val event = readUserMessage ( message ) // on passe l'\u00e9v\u00e8nement au framework val callback = TestConnectorCallback ( applicationId , message . userId , context , controller ) controller . handle ( event , ConnectorData ( callback )) } } } override fun send ( event : Event , callback : ConnectorCallback , delayInMs : Long ) { callback as TestConnectorCallback if ( event is Action ) { //on enregistre l'action callback . actions . add ( event ) //si c'est la derni\u00e8re action \u00e0 envoyer, on envoie la r\u00e9ponse if ( event . metadata . lastAnswer ) { callback . sendAnswer () } } else { logger . trace { \"unsupported event: $event\" } } } } // pour r\u00e9cup\u00e9rer toutes les actions avant envoi class TestConnectorCallback ( override val applicationId : String , val userId : String , val context : RoutingContext , val controller : ConnectorController , val actions : MutableList < Action > = CopyOnWriteArrayList ()): ConnectorCallbackBase ( applicationId , testConnectorType ) { internal fun sendAnswer () { //on transforme la liste des r\u00e9ponses Tock en r\u00e9ponse m\u00e9tier val response = mapper . writeValueAsString ( actions . map {...}) //puis on envoie la r\u00e9ponse context . response (). end ( response ) } } 2) Impl\u00e9menter l'interface ConnectorProvider Voici un exemple d'impl\u00e9mentation : object TestConnectorProvider : ConnectorProvider { override val connectorType : ConnectorType = testConnectorType override fun connector ( connectorConfiguration : ConnectorConfiguration ): Connector { return TestConnector ( connectorConfiguration . connectorId , connectorConfiguration . path ) } } class TestConnectorProviderService : ConnectorProvider by TestConnectorProvider 3) Rendre disponible ce connecteur via un Service Loader : Pour cela, placez un fichier META-INF/services/ai.tock.bot.connector.ConnectorProvider dans le classpath, contenant le nom de la classe : mypackage.TestConnectorProviderService 4) Rajouter toutes les classes et fichiers cr\u00e9\u00e9s dans le classpath de l'admin et du bot. Le nouveau connecteur doit alors \u00eatre disponible dans l'interface Bot Configurations de Tock Studio .","title":"Les connecteurs Tock"},{"location":"dev/connecteurs/#les-connecteurs-tock","text":"La page Bot multicanal de la documentation utilisateur pr\u00e9sente la notion de connecteur Tock, ainsi que la liste des connecteurs d\u00e9j\u00e0 disponibles. Cette page n'ajoute donc que les \u00e9l\u00e9ments propres au d\u00e9veloppement avec les connecteurs Tock ou le d\u00e9veloppement de nouveaux connecteurs.","title":"Les connecteurs Tock"},{"location":"dev/connecteurs/#messenger","text":"Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-messenger sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur.","title":"Messenger"},{"location":"dev/connecteurs/#slack","text":"Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur.","title":"Slack"},{"location":"dev/connecteurs/#google-assistant-google-home","text":"Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-ga sur GitHub.","title":"Google Assistant / Google Home"},{"location":"dev/connecteurs/#alexa-echo","text":"Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-alexa sur GitHub.","title":"Alexa / Echo"},{"location":"dev/connecteurs/#rocketchat","text":"Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-rocketchat sur GitHub.","title":"Rocket.Chat"},{"location":"dev/connecteurs/#whatsapp","text":"Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-whatsapp sur GitHub.","title":"WhatsApp"},{"location":"dev/connecteurs/#teams","text":"Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-teams sur GitHub.","title":"Teams"},{"location":"dev/connecteurs/#business-chat-imessages","text":"Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-businesschat sur GitHub.","title":"Business Chat / iMessages"},{"location":"dev/connecteurs/#twitter","text":"Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-twitter sur GitHub.","title":"Twitter"},{"location":"dev/connecteurs/#web","text":"Ce connecteur permet de d\u00e9ployer une API REST d\u00e9di\u00e9e \u00e0 la cr\u00e9ation d'un chatbot sur une interface Web par exemple. Consultez ses sources et son README dans le dossier connector-web sur GitHub.","title":"Web"},{"location":"dev/connecteurs/#developper-son-propre-connecteur","text":"Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. Un exemple de connecteur sp\u00e9cifique est disponible dans le projet d'exemple Bot Open Data . Pour d\u00e9finir son propre connecteur, quatres \u00e9tapes sont n\u00e9cessaires : 1) Impl\u00e9menter l'interface Connector Voici un exemple d'impl\u00e9mentation : val testConnectorType = ConnectorType ( \"test\" ) class TestConnector ( val applicationId : String , val path : String ) : Connector { override val connectorType : ConnectorType = testConnectorType override fun register ( controller : ConnectorController ) { controller . registerServices ( path ) { router -> //main API router . post ( \"$path/message\" ). blockingHandler { context -> //ConnectorRequest est mon objet m\u00e9tier pass\u00e9 par l'appli front val message : ConnectorRequest = mapper . readValue ( context . bodyAsString ) //transformation de l'objet m\u00e9tier en Event tock val event = readUserMessage ( message ) // on passe l'\u00e9v\u00e8nement au framework val callback = TestConnectorCallback ( applicationId , message . userId , context , controller ) controller . handle ( event , ConnectorData ( callback )) } } } override fun send ( event : Event , callback : ConnectorCallback , delayInMs : Long ) { callback as TestConnectorCallback if ( event is Action ) { //on enregistre l'action callback . actions . add ( event ) //si c'est la derni\u00e8re action \u00e0 envoyer, on envoie la r\u00e9ponse if ( event . metadata . lastAnswer ) { callback . sendAnswer () } } else { logger . trace { \"unsupported event: $event\" } } } } // pour r\u00e9cup\u00e9rer toutes les actions avant envoi class TestConnectorCallback ( override val applicationId : String , val userId : String , val context : RoutingContext , val controller : ConnectorController , val actions : MutableList < Action > = CopyOnWriteArrayList ()): ConnectorCallbackBase ( applicationId , testConnectorType ) { internal fun sendAnswer () { //on transforme la liste des r\u00e9ponses Tock en r\u00e9ponse m\u00e9tier val response = mapper . writeValueAsString ( actions . map {...}) //puis on envoie la r\u00e9ponse context . response (). end ( response ) } } 2) Impl\u00e9menter l'interface ConnectorProvider Voici un exemple d'impl\u00e9mentation : object TestConnectorProvider : ConnectorProvider { override val connectorType : ConnectorType = testConnectorType override fun connector ( connectorConfiguration : ConnectorConfiguration ): Connector { return TestConnector ( connectorConfiguration . connectorId , connectorConfiguration . path ) } } class TestConnectorProviderService : ConnectorProvider by TestConnectorProvider 3) Rendre disponible ce connecteur via un Service Loader : Pour cela, placez un fichier META-INF/services/ai.tock.bot.connector.ConnectorProvider dans le classpath, contenant le nom de la classe : mypackage.TestConnectorProviderService 4) Rajouter toutes les classes et fichiers cr\u00e9\u00e9s dans le classpath de l'admin et du bot. Le nouveau connecteur doit alors \u00eatre disponible dans l'interface Bot Configurations de Tock Studio .","title":"D\u00e9velopper son propre connecteur"},{"location":"dev/exemples-code/","text":"Exemples de code Tock \u00b6 Les exemples dans Bot Samples \u00b6 Le d\u00e9p\u00f4t tock-bot-samples contient des exemples de code, notamment ceux utilis\u00e9s dans la documentation Tock pour programmer des parcours en modes WebHook ou WebSocket . Le bot Open Data \u00b6 Le d\u00e9p\u00f4t tock-bot-open-data contient un exemple d'impl\u00e9mentation de bot bas\u00e9 sur les API Open Data de la SNCF . Ce bot utilise le framework Kotlin pour Tock (et pas le mode Bot API via Webhook ou WebSocket ). Il impl\u00e9mente \u00e9galement une internationalisation avec deux langues propos\u00e9es : Fran\u00e7ais et Anglais. D\u00e9ployer le bot avec Docker \u00b6 Pour d\u00e9ployer le bot avec Docker / Docker Compose , suivez les instructions du d\u00e9p\u00f4t tock-docker . D\u00e9ployer le bot dans son IDE \u00b6 Si vous pr\u00e9f\u00e9rez d\u00e9ployer une plateforme Tock sans le Bot Open Data, et ex\u00e9cuter celui-ci dans votre IDE (vous permettant par exemple de faire du debug pas-\u00e0-pas), suivez ces instructions : D\u00e9ployez une stack Tock NLU gr\u00e2ce au descripteur docker-compose.yml comme expliqu\u00e9 ici Demandez votre propre clef SNCF Open Data (gratuite) et configurez la variable d'environnement (voir OpenDataConfiguration ) Configurez un connecteur : Messenger, Google Assistant ou autre (voir canaux et connecteurs ) D\u00e9marrez le lanceur OpenDataBot dans votre IDE, IntelliJ ou autre. Le bot est op\u00e9rationnel, parlez-lui ! :)","title":"Exemples de code"},{"location":"dev/exemples-code/#exemples-de-code-tock","text":"","title":"Exemples de code Tock"},{"location":"dev/exemples-code/#les-exemples-dans-bot-samples","text":"Le d\u00e9p\u00f4t tock-bot-samples contient des exemples de code, notamment ceux utilis\u00e9s dans la documentation Tock pour programmer des parcours en modes WebHook ou WebSocket .","title":"Les exemples dans Bot Samples"},{"location":"dev/exemples-code/#le-bot-open-data","text":"Le d\u00e9p\u00f4t tock-bot-open-data contient un exemple d'impl\u00e9mentation de bot bas\u00e9 sur les API Open Data de la SNCF . Ce bot utilise le framework Kotlin pour Tock (et pas le mode Bot API via Webhook ou WebSocket ). Il impl\u00e9mente \u00e9galement une internationalisation avec deux langues propos\u00e9es : Fran\u00e7ais et Anglais.","title":"Le bot Open Data"},{"location":"dev/exemples-code/#deployer-le-bot-avec-docker","text":"Pour d\u00e9ployer le bot avec Docker / Docker Compose , suivez les instructions du d\u00e9p\u00f4t tock-docker .","title":"D\u00e9ployer le bot avec Docker"},{"location":"dev/exemples-code/#deployer-le-bot-dans-son-ide","text":"Si vous pr\u00e9f\u00e9rez d\u00e9ployer une plateforme Tock sans le Bot Open Data, et ex\u00e9cuter celui-ci dans votre IDE (vous permettant par exemple de faire du debug pas-\u00e0-pas), suivez ces instructions : D\u00e9ployez une stack Tock NLU gr\u00e2ce au descripteur docker-compose.yml comme expliqu\u00e9 ici Demandez votre propre clef SNCF Open Data (gratuite) et configurez la variable d'environnement (voir OpenDataConfiguration ) Configurez un connecteur : Messenger, Google Assistant ou autre (voir canaux et connecteurs ) D\u00e9marrez le lanceur OpenDataBot dans votre IDE, IntelliJ ou autre. Le bot est op\u00e9rationnel, parlez-lui ! :)","title":"D\u00e9ployer le bot dans son IDE"},{"location":"dev/i18n/","text":"D\u00e9velopper un bot multilingue ( i18n ) \u00b6 La page Bot multilingue de la documentation utilisateur pr\u00e9sente les bases de l'internationalisation ( i18n ) pour construire des bots avec Tock : pr\u00e9-requis, Locale , etc. Cette page vient compl\u00e9ter cette documentation avec des \u00e9l\u00e9ments propres au d\u00e9veloppement. Pr\u00e9-requis \u00b6 Pour activer l'internationalisation dans Tock, programmatiquement ou pas, voir Bot multilingue . Principes \u00b6 Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : send ( \"Arrival at {0}\" , time ) est un code valide que le module soit activ\u00e9 ou non. Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement. Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es : Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot) et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 app_arrivals_Arrival at {0} o\u00f9 app est le namespace et arrivals l'intention principale de la story. Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la langue demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte) Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la langue courante Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration : Format des messages \u00b6 Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe MessageFormat en java. Cela inclut le support de ChoiceFormat : send ( \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\" , 2 ) Par ailleurs, Tock met \u00e0 disposition une extension by pour les dates qui permet d'indiquer un format dans les param\u00e8tres : send ( \"Departure at {0}\" , departureDateTime by timeFormat ) Locale utilisateur \u00b6 Voir Bot multilingue . Points d'attention \u00b6 Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin, sont \u00e0 bannir sous peine de mauvaises surprises. Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9. send ( \"There are $nb files\" ) //DANGER!! mais pose probl\u00e8me si il est activ\u00e9. En effet, un nouveau libell\u00e9 sera cr\u00e9\u00e9 pour chaque valeur diff\u00e9rente de la variable nb ! Si il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez les m\u00e9thodes BotBus.sendRaw , BotBus.endRaw ou String.raw send ( \"There are $nb files\" . raw ) //CORRECT send ( \"There are {0} files\" , nb ) //FORMAT A SUIVRE Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. Si vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode i18nKey : send ( i18nKey ( \"my_unique_key\" , \"There are {0} files\" , nb )) Tester l'internationalisation \u00b6 Un exemple de dispositif de test est disponible dans le code source du bot d'exemple Il est n\u00e9cessaire d'\u00e9tendre l'extension de test pour ensuite indiquer la correspondance des libell\u00e9s \u00e0 tester. Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } }","title":"i18n"},{"location":"dev/i18n/#developper-un-bot-multilingue-i18n","text":"La page Bot multilingue de la documentation utilisateur pr\u00e9sente les bases de l'internationalisation ( i18n ) pour construire des bots avec Tock : pr\u00e9-requis, Locale , etc. Cette page vient compl\u00e9ter cette documentation avec des \u00e9l\u00e9ments propres au d\u00e9veloppement.","title":"D\u00e9velopper un bot multilingue (i18n)"},{"location":"dev/i18n/#pre-requis","text":"Pour activer l'internationalisation dans Tock, programmatiquement ou pas, voir Bot multilingue .","title":"Pr\u00e9-requis"},{"location":"dev/i18n/#principes","text":"Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : send ( \"Arrival at {0}\" , time ) est un code valide que le module soit activ\u00e9 ou non. Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement. Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es : Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot) et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 app_arrivals_Arrival at {0} o\u00f9 app est le namespace et arrivals l'intention principale de la story. Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la langue demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte) Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la langue courante Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration :","title":"Principes"},{"location":"dev/i18n/#format-des-messages","text":"Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe MessageFormat en java. Cela inclut le support de ChoiceFormat : send ( \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\" , 2 ) Par ailleurs, Tock met \u00e0 disposition une extension by pour les dates qui permet d'indiquer un format dans les param\u00e8tres : send ( \"Departure at {0}\" , departureDateTime by timeFormat )","title":"Format des messages"},{"location":"dev/i18n/#locale-utilisateur","text":"Voir Bot multilingue .","title":"Locale utilisateur"},{"location":"dev/i18n/#points-dattention","text":"Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin, sont \u00e0 bannir sous peine de mauvaises surprises. Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9. send ( \"There are $nb files\" ) //DANGER!! mais pose probl\u00e8me si il est activ\u00e9. En effet, un nouveau libell\u00e9 sera cr\u00e9\u00e9 pour chaque valeur diff\u00e9rente de la variable nb ! Si il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez les m\u00e9thodes BotBus.sendRaw , BotBus.endRaw ou String.raw send ( \"There are $nb files\" . raw ) //CORRECT send ( \"There are {0} files\" , nb ) //FORMAT A SUIVRE Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. Si vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode i18nKey : send ( i18nKey ( \"my_unique_key\" , \"There are {0} files\" , nb ))","title":"Points d'attention"},{"location":"dev/i18n/#tester-linternationalisation","text":"Un exemple de dispositif de test est disponible dans le code source du bot d'exemple Il est n\u00e9cessaire d'\u00e9tendre l'extension de test pour ensuite indiquer la correspondance des libell\u00e9s \u00e0 tester. Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } }","title":"Tester l'internationalisation"},{"location":"dev/modes/","text":"D\u00e9velopper des bots avec Tock \u00b6 Pour aller plus loin que les possibilit\u00e9s de Tock Studio pour construire bots & assistants conversationnels, on peut programmer des parcours, en Kotlin ou dans d'autres langages. Deux modes / frameworks / architectures sont propos\u00e9s : Le mode Bot API \u00b6 Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas) permet de d\u00e9velopper en Kotlin ou un autre langage \u00e0 travers l'API conversationnelle de Tock : Ce mode est le seul disponible sur la plateforme de d\u00e9monstration Tock . C'est aussi le seul mode permettant de d\u00e9velopper dans n'importe quel langage de programmation, via l'API. Pour en savoir plus, voir la page Bot API . Le mode Bot int\u00e9gr\u00e9 \u00b6 Dans ce mode, vous pouvez acc\u00e9der \u00e0 toutes les fonctionnalit\u00e9s et possibilit\u00e9s du framework Tock pour d\u00e9velopper un bot. C'est le mode de d\u00e9veloppement historique de Tock, et actuellement la plupart des bots publi\u00e9s par les concepteurs de Tock. sont d\u00e9velopp\u00e9s de cette mani\u00e8re. La mise en place de la solution est plus complexe que le mode Bot API et n\u00e9cessite notamment que le composant bot acc\u00e8de directement \u00e0 la base de donn\u00e9es MongoDB. Il est donc n\u00e9cessaire pour utiliser ce mode : D'installer une plateforme (g\u00e9n\u00e9ralement avec Docker ) sur son poste ou sur un serveur De partager la connexion \u00e0 la base MongoDB entre les poste de d\u00e9veloppement et les autres composants de la plateforme Tock utilis\u00e9e De ma\u00eetriser le langage de programmation Kotlin Pour en savoir plus, voir la page Bot int\u00e9gr\u00e9 .","title":"Modes disponibles"},{"location":"dev/modes/#developper-des-bots-avec-tock","text":"Pour aller plus loin que les possibilit\u00e9s de Tock Studio pour construire bots & assistants conversationnels, on peut programmer des parcours, en Kotlin ou dans d'autres langages. Deux modes / frameworks / architectures sont propos\u00e9s :","title":"D\u00e9velopper des bots avec Tock"},{"location":"dev/modes/#le-mode-bot-api","text":"Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas) permet de d\u00e9velopper en Kotlin ou un autre langage \u00e0 travers l'API conversationnelle de Tock : Ce mode est le seul disponible sur la plateforme de d\u00e9monstration Tock . C'est aussi le seul mode permettant de d\u00e9velopper dans n'importe quel langage de programmation, via l'API. Pour en savoir plus, voir la page Bot API .","title":"Le mode Bot API"},{"location":"dev/modes/#le-mode-bot-integre","text":"Dans ce mode, vous pouvez acc\u00e9der \u00e0 toutes les fonctionnalit\u00e9s et possibilit\u00e9s du framework Tock pour d\u00e9velopper un bot. C'est le mode de d\u00e9veloppement historique de Tock, et actuellement la plupart des bots publi\u00e9s par les concepteurs de Tock. sont d\u00e9velopp\u00e9s de cette mani\u00e8re. La mise en place de la solution est plus complexe que le mode Bot API et n\u00e9cessite notamment que le composant bot acc\u00e8de directement \u00e0 la base de donn\u00e9es MongoDB. Il est donc n\u00e9cessaire pour utiliser ce mode : D'installer une plateforme (g\u00e9n\u00e9ralement avec Docker ) sur son poste ou sur un serveur De partager la connexion \u00e0 la base MongoDB entre les poste de d\u00e9veloppement et les autres composants de la plateforme Tock utilis\u00e9e De ma\u00eetriser le langage de programmation Kotlin Pour en savoir plus, voir la page Bot int\u00e9gr\u00e9 .","title":"Le mode Bot int\u00e9gr\u00e9"},{"location":"dev/tester/","text":"Utiliser le framework de test \u00b6 Tock met \u00e0 disposition des extensions pour tester le bot unitairement. Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie bot-test \u00e0 votre projet. Avec Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> bot-test </artifactId> <version> 19.9.1 </version> <scope> test </scope> </dependency> ou Gradle : testCompile 'ai.tock:bot-test:19.9.1' L'ensemble de ce framework est document\u00e9 au format KDoc ici . Ecrire un test simple \u00b6 L'ensemble des exemples suivants utilisent JUnit5 . Une extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est disponible . @RegisterExtension @JvmField val ext = TockJUnit5Extension () Afin de tester la story greetings du bot Open Data, il suffit d'utiliser la m\u00e9thode ext.send() qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi : @Test fun `greetings story displays welcome message WHEN locale is fr` () { ext . send ( locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) } } Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : lastAnswer . assertMessage ( buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) ) Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur), il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester : ext . send ( connectorType = gaConnectorType , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) lastAnswer . assertMessage ( gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) ) } Tester une Story sp\u00e9cifique \u00b6 Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester ( greetings \u00e9tant la story par d\u00e9faut). Supposons que nous souhaitons la story search , nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante : @Test fun `search story asks for destination WHEN there is no destination in context` () { ext . send ( intent = search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } } Tester un dialogue \u00b6 Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine : @Test fun `search story asks for origin WHEN there is a destination but no origin in context` () { ext . send ( \"Je voudrais rechercher un itin\u00e9raire\" , search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) { firstBusAnswer . assertText ( \"Pour quelle origine?\" ) } ext . send ( \"Paris\" , indicate_location , locationEntity setTo paris ) { firstBusAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Le texte en premier param\u00e8tre de la m\u00e9thode send est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests. Les param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase. Par exemple : private val lille = PlaceValue ( SncfPlace ( \"stop_area\" , 90 , \"Lille Europe\" , \"Lille Europe (Lille)\" , \"stop_area:OCE:SA:87223263\" , Coordinates ( 50.638861 , 3.075774 ) ) ) ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention indicate_location et avec une valeur pour l'entit\u00e9 location qui va \u00eatre la localisation lille Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire indicate_location afin d'indiquer l'origine : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Les variables origin et destination sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction run() .","title":"Utiliser le framework de test"},{"location":"dev/tester/#utiliser-le-framework-de-test","text":"Tock met \u00e0 disposition des extensions pour tester le bot unitairement. Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie bot-test \u00e0 votre projet. Avec Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> bot-test </artifactId> <version> 19.9.1 </version> <scope> test </scope> </dependency> ou Gradle : testCompile 'ai.tock:bot-test:19.9.1' L'ensemble de ce framework est document\u00e9 au format KDoc ici .","title":"Utiliser le framework de test"},{"location":"dev/tester/#ecrire-un-test-simple","text":"L'ensemble des exemples suivants utilisent JUnit5 . Une extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est disponible . @RegisterExtension @JvmField val ext = TockJUnit5Extension () Afin de tester la story greetings du bot Open Data, il suffit d'utiliser la m\u00e9thode ext.send() qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi : @Test fun `greetings story displays welcome message WHEN locale is fr` () { ext . send ( locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) } } Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : lastAnswer . assertMessage ( buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) ) Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur), il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester : ext . send ( connectorType = gaConnectorType , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) lastAnswer . assertMessage ( gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) ) }","title":"Ecrire un test simple"},{"location":"dev/tester/#tester-une-story-specifique","text":"Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester ( greetings \u00e9tant la story par d\u00e9faut). Supposons que nous souhaitons la story search , nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante : @Test fun `search story asks for destination WHEN there is no destination in context` () { ext . send ( intent = search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } }","title":"Tester une Story sp\u00e9cifique"},{"location":"dev/tester/#tester-un-dialogue","text":"Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine : @Test fun `search story asks for origin WHEN there is a destination but no origin in context` () { ext . send ( \"Je voudrais rechercher un itin\u00e9raire\" , search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) { firstBusAnswer . assertText ( \"Pour quelle origine?\" ) } ext . send ( \"Paris\" , indicate_location , locationEntity setTo paris ) { firstBusAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Le texte en premier param\u00e8tre de la m\u00e9thode send est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests. Les param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase. Par exemple : private val lille = PlaceValue ( SncfPlace ( \"stop_area\" , 90 , \"Lille Europe\" , \"Lille Europe (Lille)\" , \"stop_area:OCE:SA:87223263\" , Coordinates ( 50.638861 , 3.075774 ) ) ) ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention indicate_location et avec une valeur pour l'entit\u00e9 location qui va \u00eatre la localisation lille Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire indicate_location afin d'indiquer l'origine : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Les variables origin et destination sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction run() .","title":"Tester un dialogue"},{"location":"guide/api/","text":"Programmer des parcours en Kotlin \u00b6 Les interfaces Tock Studio permettent de cr\u00e9er des bots et des parcours relativement simples, comme des arbres de d\u00e9cision et des r\u00e9ponses \u00e0 des questions courantes. Cela s'av\u00e8re suffisant pour de nombreux cas d'usages conversationnels. Toutefois, il est possible de construire des r\u00e9ponses et des parcours plus complexes : Se brancher \u00e0 un compte utilisateur Aggr\u00e9ger les informations de r\u00e9f\u00e9rentiels m\u00e9tier Appeler les services du SI (Syst\u00e8me d'Information) dans une organisation Int\u00e9grer des API externes pour enrichir ses parcours de services tiers Effectuer des actions et des transactions : cr\u00e9ation de tickets, paiements, etc. Impl\u00e9menter des r\u00e8gles de gestion et comportements sp\u00e9cifiques Optimiser les encha\u00eenements entre les intentions Pour construire des parcours complexes, Tock propose plusieurs modes d'int\u00e9gration destin\u00e9s \u00e0 diff\u00e9rents langages et frameworks de d\u00e9veloppement. Dans ce guide, vous utiliserez le langage Kotlin et le mode WebSocket pour ajouter une intention \u00e0 un bot initi\u00e9 dans Tock Studio . Si vous le souhaitez, vous pouvez sauter cette \u00e9tape et d\u00e9ployer un plateforme avec Docker ou passer directement au manuel utilisateur pour en savoir plus sur les possibilit\u00e9s de Tock Studio . Ce que vous allez cr\u00e9er \u00b6 Une intention Tock d\u00e9velopp\u00e9e avec le langage Kotlin Un programme se connectant au bot en WebSocket pour l'enrichir de parcours programm\u00e9s Pr\u00e9-requis \u00b6 Environ 10 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Si vous ne souhaitez pas utiliser d' IDE , ou Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de r\u00e9aliser le m\u00eame exercice avec d'autres outils. Il est \u00e9galement possible d'utiliser d'autres mani\u00e8res de d\u00e9velopper que le mode WebSocket et d'autres langages que Kotlin. Vous en apprendrez plus dans le manuel utilisateur Tock . Cr\u00e9er un programme Kotlin avec la d\u00e9pendance Tock \u00b6 Il existe de nombreuses mani\u00e8res de cr\u00e9er un projet en Kotlin. Ajoutez au classpath la biblioth\u00e8que tock-bot-api-websocket pour le mode WebSocket . Si vous utilisez Apache Maven , voici un exemple de POM ( pom.xml ) pour Kotlin avec la d\u00e9pendance tock-bot-api-websocket incluse : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> test </groupId> <artifactId> tock-kotlin-websocket </artifactId> <version> 0.0.1-SNAPSHOT </version> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <plugin.kotlin.version> 1.3.41 </plugin.kotlin.version> <plugin.source.version> 3.1.0 </plugin.source.version> <lib.tock.version> 19.9.1 </lib.tock.version> </properties> <dependencies> <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> ${lib.tock.version} </version> </dependency> </dependencies> <build> <sourceDirectory> ${project.basedir}/src/main/kotlin </sourceDirectory> <plugins> <plugin> <groupId> org.jetbrains.kotlin </groupId> <artifactId> kotlin-maven-plugin </artifactId> <version> ${plugin.kotlin.version} </version> <executions> <execution> <id> compile </id> <phase> compile </phase> <goals> <goal> compile </goal> </goals> </execution> <execution> <id> test-compile </id> <phase> test-compile </phase> <goals> <goal> test-compile </goal> </goals> </execution> </executions> </plugin> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-source-plugin </artifactId> <version> ${plugin.source.version} </version> <executions> <execution> <id> attach-sources </id> <phase> verify </phase> <goals> <goal> jar-no-fork </goal> </goals> </execution> </executions> </plugin> </plugins> </build> </project> Vous pouvez retrouver ce code et d'autres exemples dans le d\u00e9p\u00f4t tock-bot-samples . Cr\u00e9er une fonction qui se connecte \u00e0 Tock \u00b6 Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import ai.tock.bot.api.client.newBot import ai.tock.bot.api.client.newStory import ai.tock.bot.api.websocket.startWithDemo fun main () { startWithDemo ( // Integrate with the Tock demo platform by default newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // Get your app API key from Bot Configurations in Tock Studio newStory ( \"qui-es-tu\" ) { // Answer for the 'qui-es-tu' story send ( \"Je suis un assistant conversationnel construit avec Tock\" ) end ( \"Comment puis-je aider ?\" ) } ) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration > Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Vous devriez voir appara\u00eetre une ligne de log ressemblant \u00e0 celle-ci : [ main ] INFO ai . tock . bot . api . websocket . BotApiWebSocketClient - start web socket client : { ... } V\u00e9rifiez \u00e9ventuellement que d'autres logs provenant de BotApiWebSocketClient n'indiquent pas d'erreur. Si c'est le cas, il peut s'agir d'une erreur de configuration de la clef d'API. Terminer la configuration dans Tock Studio \u00b6 Retournez dans Tock et allez dans Build > Search Stories D\u00e9cochez l'option Only Configured Stories . Vous voyez alors tous parcours, y compris \"qui-es-tu\" que vous venez de d\u00e9clarer programmatiquement Allez dans Test > Test the bot et saisissez une ou plusieurs phrases comme \"qui es-tu ?\" par exemple. Vous contastez que le bot ne r\u00e9pond pas encore \u00e0 cette question - il r\u00e9pond peut-\u00eatre m\u00eame \u00e0 une autre intention. Il reste en effet une configuration \u00e0 effectuer pour que la qualification fonctionne. A ce stade, le parcours existe bien dans Tock, mais l' intention n'a pas \u00e9t\u00e9 cr\u00e9\u00e9e automatiquement. Vous pouvez le v\u00e9rifier en regardant la liste des intentions disponibles dans NLU > Intents > build (la cat\u00e9gorie par d\u00e9faut). Ce point sera bient\u00f4t am\u00e9lior\u00e9 ( issue #533 ). Allez dans NLU > Inbox , pour la derni\u00e8re phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Puis terminez la qualification de la phrase avec Validate Si vous avez saisi d'autres phrases pour cette intention, pour chacune d'elles s\u00e9lectionnez l'intention dans la liste puis confirmez avec Validate Retournez dans Test > Test the bot . Si vous reposez la question, le bot vous donne d\u00e9sormais la r\u00e9ponse construite dans le code Kotlin (ie. \"Je suis un assistant...\"). F\u00e9licitations! \u00b6 Vous venez de configurer votre premi\u00e8re story programmatique en Kotlin. De cette mani\u00e8re, vous pouvez tirer pleinement parti des possibilit\u00e9s d'un langage de programmation pour construire toutes sortes de parcours simples et complexes, interroger des API tierces, impl\u00e9menter des r\u00e8gles de gestion, etc. Si vous programmez ainsi une story d\u00e9j\u00e0 d\u00e9finie dans Tock Studio , c'est la d\u00e9finition pr\u00e9sente dans Tock Studio qui est utilis\u00e9e pour construire les r\u00e9ponses \u00e0 l'ex\u00e9cution. Continuer... \u00b6 Dans la section suivante vous apprendez \u00e0 : D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur l'utilisation de Tock Bot API en mode WebSocket , mais aussi les autres modes de d\u00e9ploiement, les types de messages support\u00e9s par Tock, etc. vous pouvez consulter le manuel utilisateur .","title":"Programmer des parcours"},{"location":"guide/api/#programmer-des-parcours-en-kotlin","text":"Les interfaces Tock Studio permettent de cr\u00e9er des bots et des parcours relativement simples, comme des arbres de d\u00e9cision et des r\u00e9ponses \u00e0 des questions courantes. Cela s'av\u00e8re suffisant pour de nombreux cas d'usages conversationnels. Toutefois, il est possible de construire des r\u00e9ponses et des parcours plus complexes : Se brancher \u00e0 un compte utilisateur Aggr\u00e9ger les informations de r\u00e9f\u00e9rentiels m\u00e9tier Appeler les services du SI (Syst\u00e8me d'Information) dans une organisation Int\u00e9grer des API externes pour enrichir ses parcours de services tiers Effectuer des actions et des transactions : cr\u00e9ation de tickets, paiements, etc. Impl\u00e9menter des r\u00e8gles de gestion et comportements sp\u00e9cifiques Optimiser les encha\u00eenements entre les intentions Pour construire des parcours complexes, Tock propose plusieurs modes d'int\u00e9gration destin\u00e9s \u00e0 diff\u00e9rents langages et frameworks de d\u00e9veloppement. Dans ce guide, vous utiliserez le langage Kotlin et le mode WebSocket pour ajouter une intention \u00e0 un bot initi\u00e9 dans Tock Studio . Si vous le souhaitez, vous pouvez sauter cette \u00e9tape et d\u00e9ployer un plateforme avec Docker ou passer directement au manuel utilisateur pour en savoir plus sur les possibilit\u00e9s de Tock Studio .","title":"Programmer des parcours en Kotlin"},{"location":"guide/api/#ce-que-vous-allez-creer","text":"Une intention Tock d\u00e9velopp\u00e9e avec le langage Kotlin Un programme se connectant au bot en WebSocket pour l'enrichir de parcours programm\u00e9s","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/api/#pre-requis","text":"Environ 10 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Si vous ne souhaitez pas utiliser d' IDE , ou Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de r\u00e9aliser le m\u00eame exercice avec d'autres outils. Il est \u00e9galement possible d'utiliser d'autres mani\u00e8res de d\u00e9velopper que le mode WebSocket et d'autres langages que Kotlin. Vous en apprendrez plus dans le manuel utilisateur Tock .","title":"Pr\u00e9-requis"},{"location":"guide/api/#creer-un-programme-kotlin-avec-la-dependance-tock","text":"Il existe de nombreuses mani\u00e8res de cr\u00e9er un projet en Kotlin. Ajoutez au classpath la biblioth\u00e8que tock-bot-api-websocket pour le mode WebSocket . Si vous utilisez Apache Maven , voici un exemple de POM ( pom.xml ) pour Kotlin avec la d\u00e9pendance tock-bot-api-websocket incluse : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> test </groupId> <artifactId> tock-kotlin-websocket </artifactId> <version> 0.0.1-SNAPSHOT </version> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <plugin.kotlin.version> 1.3.41 </plugin.kotlin.version> <plugin.source.version> 3.1.0 </plugin.source.version> <lib.tock.version> 19.9.1 </lib.tock.version> </properties> <dependencies> <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> ${lib.tock.version} </version> </dependency> </dependencies> <build> <sourceDirectory> ${project.basedir}/src/main/kotlin </sourceDirectory> <plugins> <plugin> <groupId> org.jetbrains.kotlin </groupId> <artifactId> kotlin-maven-plugin </artifactId> <version> ${plugin.kotlin.version} </version> <executions> <execution> <id> compile </id> <phase> compile </phase> <goals> <goal> compile </goal> </goals> </execution> <execution> <id> test-compile </id> <phase> test-compile </phase> <goals> <goal> test-compile </goal> </goals> </execution> </executions> </plugin> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-source-plugin </artifactId> <version> ${plugin.source.version} </version> <executions> <execution> <id> attach-sources </id> <phase> verify </phase> <goals> <goal> jar-no-fork </goal> </goals> </execution> </executions> </plugin> </plugins> </build> </project> Vous pouvez retrouver ce code et d'autres exemples dans le d\u00e9p\u00f4t tock-bot-samples .","title":"Cr\u00e9er un programme Kotlin avec la d\u00e9pendance Tock"},{"location":"guide/api/#creer-une-fonction-qui-se-connecte-a-tock","text":"Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import ai.tock.bot.api.client.newBot import ai.tock.bot.api.client.newStory import ai.tock.bot.api.websocket.startWithDemo fun main () { startWithDemo ( // Integrate with the Tock demo platform by default newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // Get your app API key from Bot Configurations in Tock Studio newStory ( \"qui-es-tu\" ) { // Answer for the 'qui-es-tu' story send ( \"Je suis un assistant conversationnel construit avec Tock\" ) end ( \"Comment puis-je aider ?\" ) } ) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration > Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Vous devriez voir appara\u00eetre une ligne de log ressemblant \u00e0 celle-ci : [ main ] INFO ai . tock . bot . api . websocket . BotApiWebSocketClient - start web socket client : { ... } V\u00e9rifiez \u00e9ventuellement que d'autres logs provenant de BotApiWebSocketClient n'indiquent pas d'erreur. Si c'est le cas, il peut s'agir d'une erreur de configuration de la clef d'API.","title":"Cr\u00e9er une fonction qui se connecte \u00e0 Tock"},{"location":"guide/api/#terminer-la-configuration-dans-tock-studio","text":"Retournez dans Tock et allez dans Build > Search Stories D\u00e9cochez l'option Only Configured Stories . Vous voyez alors tous parcours, y compris \"qui-es-tu\" que vous venez de d\u00e9clarer programmatiquement Allez dans Test > Test the bot et saisissez une ou plusieurs phrases comme \"qui es-tu ?\" par exemple. Vous contastez que le bot ne r\u00e9pond pas encore \u00e0 cette question - il r\u00e9pond peut-\u00eatre m\u00eame \u00e0 une autre intention. Il reste en effet une configuration \u00e0 effectuer pour que la qualification fonctionne. A ce stade, le parcours existe bien dans Tock, mais l' intention n'a pas \u00e9t\u00e9 cr\u00e9\u00e9e automatiquement. Vous pouvez le v\u00e9rifier en regardant la liste des intentions disponibles dans NLU > Intents > build (la cat\u00e9gorie par d\u00e9faut). Ce point sera bient\u00f4t am\u00e9lior\u00e9 ( issue #533 ). Allez dans NLU > Inbox , pour la derni\u00e8re phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Puis terminez la qualification de la phrase avec Validate Si vous avez saisi d'autres phrases pour cette intention, pour chacune d'elles s\u00e9lectionnez l'intention dans la liste puis confirmez avec Validate Retournez dans Test > Test the bot . Si vous reposez la question, le bot vous donne d\u00e9sormais la r\u00e9ponse construite dans le code Kotlin (ie. \"Je suis un assistant...\").","title":"Terminer la configuration dans Tock Studio"},{"location":"guide/api/#felicitations","text":"Vous venez de configurer votre premi\u00e8re story programmatique en Kotlin. De cette mani\u00e8re, vous pouvez tirer pleinement parti des possibilit\u00e9s d'un langage de programmation pour construire toutes sortes de parcours simples et complexes, interroger des API tierces, impl\u00e9menter des r\u00e8gles de gestion, etc. Si vous programmez ainsi une story d\u00e9j\u00e0 d\u00e9finie dans Tock Studio , c'est la d\u00e9finition pr\u00e9sente dans Tock Studio qui est utilis\u00e9e pour construire les r\u00e9ponses \u00e0 l'ex\u00e9cution.","title":"F\u00e9licitations!"},{"location":"guide/api/#continuer","text":"Dans la section suivante vous apprendez \u00e0 : D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur l'utilisation de Tock Bot API en mode WebSocket , mais aussi les autres modes de d\u00e9ploiement, les types de messages support\u00e9s par Tock, etc. vous pouvez consulter le manuel utilisateur .","title":"Continuer..."},{"location":"guide/messenger/","text":"Configurer son bot pour Messenger \u00b6 Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack. Dans ce guide, vous allez cr\u00e9er une configuration pour Facebook Messenger et int\u00e9grer le bot pour dialoguer avec lui sur ce r\u00e9seau social. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et passer directement \u00e0 la suite . Ce que vous allez cr\u00e9er \u00b6 Une configuration (dans Facebook et dans Tock) pour recevoir et envoyer des messages via Messenger Un bot qui parle sur une page Facebook ou dans Messenger Pr\u00e9-requis \u00b6 Environ 20 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Facebook Developer Cr\u00e9er une page Facebook \u00b6 Cr\u00e9ez une page Facebook Donnez-lui un nom (par exemple My Tock Bot ) Recommandation : ne publiez pas la page pour limiter son acc\u00e8s des utilisateurs Messenger : Param\u00e8tres > G\u00e9n\u00e9ral > Visibilit\u00e9 de la page > Non publi\u00e9e Cr\u00e9er une application Facebook \u00b6 Allez sur la page Facebook for developers > Voir toutes les applications Ajouter une app Entrez un nom pour l' application Cr\u00e9er un ID d'app ... Notez l'ID de la page, vous en aurez besoin plus tard. Ajoutez un produit : Messenger Dans les param\u00e8tres, g\u00e9n\u00e9rez un jeton ( token ) pour votre page. Notez ce token pour la suite. Configurer un connecteur Messenger dans Tock \u00b6 Dans Tock Studio allez dans Configuration > Bot Configurations Cr\u00e9ez un connecteur de type Messenger et ouvrez la section Connector Custom Configuration Configurez l'ID de page et le token pr\u00e9c\u00e9demment g\u00e9n\u00e9r\u00e9s c\u00f4t\u00e9 Facebook Comme Webhook token , saisissez token (par exemple) Dans le champ Secret , entrez la clef secr\u00e8te que vous trouverez dans le portail Facebook for developers : param\u00e8tres > g\u00e9n\u00e9ral > afficher la clef secr\u00e8te V\u00e9rifiez que la configuration du connecteur est bien enregistr\u00e9e ... Testez votre bot sur Messenger ! F\u00e9licitations! \u00b6 Votre bot dialogue d\u00e9sormais sur Messenger, en plus des autres canaux auquel vous l'avez int\u00e9gr\u00e9. Le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant sont construits et restent ind\u00e9pendants des canaux sur lesquels le bot est pr\u00e9sent. Toutefois, rien ne vous emp\u00eache de cr\u00e9er des parcours ou des r\u00e9ponses sp\u00e9cifiquement pour tel ou tel canal, comme vous le verrez au travers de diff\u00e9rents outils Tock : \u00e9cran de gestion des Responses , activation d'intentions sur tel ou tel canal avec l'\u00e9cran Story Rules , utilisation des DSLs et de la Bot API pour tirer parti de composants graphiques sp\u00e9cifiques, etc. Continuer... \u00b6 Dans les sections suivantes vous apprendez \u00e0 : Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Configurer Messenger"},{"location":"guide/messenger/#configurer-son-bot-pour-messenger","text":"Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack. Dans ce guide, vous allez cr\u00e9er une configuration pour Facebook Messenger et int\u00e9grer le bot pour dialoguer avec lui sur ce r\u00e9seau social. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et passer directement \u00e0 la suite .","title":"Configurer son bot pour Messenger"},{"location":"guide/messenger/#ce-que-vous-allez-creer","text":"Une configuration (dans Facebook et dans Tock) pour recevoir et envoyer des messages via Messenger Un bot qui parle sur une page Facebook ou dans Messenger","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/messenger/#pre-requis","text":"Environ 20 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Facebook Developer","title":"Pr\u00e9-requis"},{"location":"guide/messenger/#creer-une-page-facebook","text":"Cr\u00e9ez une page Facebook Donnez-lui un nom (par exemple My Tock Bot ) Recommandation : ne publiez pas la page pour limiter son acc\u00e8s des utilisateurs Messenger : Param\u00e8tres > G\u00e9n\u00e9ral > Visibilit\u00e9 de la page > Non publi\u00e9e","title":"Cr\u00e9er une page Facebook"},{"location":"guide/messenger/#creer-une-application-facebook","text":"Allez sur la page Facebook for developers > Voir toutes les applications Ajouter une app Entrez un nom pour l' application Cr\u00e9er un ID d'app ... Notez l'ID de la page, vous en aurez besoin plus tard. Ajoutez un produit : Messenger Dans les param\u00e8tres, g\u00e9n\u00e9rez un jeton ( token ) pour votre page. Notez ce token pour la suite.","title":"Cr\u00e9er une application Facebook"},{"location":"guide/messenger/#configurer-un-connecteur-messenger-dans-tock","text":"Dans Tock Studio allez dans Configuration > Bot Configurations Cr\u00e9ez un connecteur de type Messenger et ouvrez la section Connector Custom Configuration Configurez l'ID de page et le token pr\u00e9c\u00e9demment g\u00e9n\u00e9r\u00e9s c\u00f4t\u00e9 Facebook Comme Webhook token , saisissez token (par exemple) Dans le champ Secret , entrez la clef secr\u00e8te que vous trouverez dans le portail Facebook for developers : param\u00e8tres > g\u00e9n\u00e9ral > afficher la clef secr\u00e8te V\u00e9rifiez que la configuration du connecteur est bien enregistr\u00e9e ... Testez votre bot sur Messenger !","title":"Configurer un connecteur Messenger dans Tock"},{"location":"guide/messenger/#felicitations","text":"Votre bot dialogue d\u00e9sormais sur Messenger, en plus des autres canaux auquel vous l'avez int\u00e9gr\u00e9. Le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant sont construits et restent ind\u00e9pendants des canaux sur lesquels le bot est pr\u00e9sent. Toutefois, rien ne vous emp\u00eache de cr\u00e9er des parcours ou des r\u00e9ponses sp\u00e9cifiquement pour tel ou tel canal, comme vous le verrez au travers de diff\u00e9rents outils Tock : \u00e9cran de gestion des Responses , activation d'intentions sur tel ou tel canal avec l'\u00e9cran Story Rules , utilisation des DSLs et de la Bot API pour tirer parti de composants graphiques sp\u00e9cifiques, etc.","title":"F\u00e9licitations!"},{"location":"guide/messenger/#continuer","text":"Dans les sections suivantes vous apprendez \u00e0 : Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Continuer..."},{"location":"guide/plateforme/","text":"D\u00e9ployer une plateforme avec Docker \u00b6 Dans les sections pr\u00e9c\u00e9dentes pour d\u00e9couvrir et tester Tock, vous avez utilis\u00e9 la plateforme de d\u00e9monstration . Cela vous a permis de d\u00e9couvrir la construction et la configuration des bots Tock sans avoir \u00e0 installer la plateforme au pr\u00e9alable. Dans ce guide, vous allez apprendre \u00e0 d\u00e9ployer une plateforme compl\u00e8te Tock en quelques minutes, gr\u00e2ce aux exemples d'impl\u00e9mentations Docker / Docker Compose fournies. Notez qu'il est tout \u00e0 fait possible de d\u00e9ployer Tock sans utiliser Docker. Une section sp\u00e9cifique du manuel utilisateur vous en apprendra plus sur l'architecture, les possibilit\u00e9s et les recommandations pour le d\u00e9ploiement et l'utilisation de Tock en production. Ce que vous allez cr\u00e9er \u00b6 Une plateforme Tock compl\u00e8te en local : Tock Studio , Bot API , etc. Un bot et une configuration minimale pour tester la plateforme (Optionnel) Un programme Kotlin se connectant \u00e0 la plateforme locale en WebSocket Pr\u00e9-requis \u00b6 Environ 20 minutes Pour d\u00e9ployer la plateforme en local, un environnement de d\u00e9veloppement avec des versions r\u00e9centes de Docker et Docker Compose install\u00e9es Si vous ne souhaitez pas utiliser Docker, pas de probl\u00e8me. Il y a d'autres mani\u00e8res de d\u00e9ployer la base MongoDB et les services Kotlin sur JVM. Vous pouvez toutefois parcourir les Dockerfile et docker-compose.yml \u00e0 titre d'exemples pour instancier ces services. (Optionnel) Pour le programme en WebSocket, un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Sans IDE ou sans Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de compiler et ex\u00e9cuter le programme avec d'autres outils. D'autres modes que Kotlin et WebSocket sont pr\u00e9sent\u00e9s dans le manuel utilisateur Tock . D\u00e9ployer une plateforme Tock - sans les sources \u00b6 Il est possible de r\u00e9cup\u00e9rer seulement quelques fichiers du d\u00e9p\u00f4t GitHub, sans t\u00e9l\u00e9charger toutes les sources Tock. En quelques lignes de commande, la plateforme est op\u00e9rationnelle. Il est cependant indispensable d'avoir des versions r\u00e9centes de Docker et Docker Compose . Pour d\u00e9marrer depuis les sources du d\u00e9p\u00f4t Tock Docker, passez plut\u00f4t au paragraphe suivant . # Get the lastest docker-compose from GitHub (including Bot API) $ curl -o docker-compose.yml https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/docker-compose-bot.yml # Get the lastest database-init script from GitHub $ mkdir -p scripts && curl -o scripts/setup.sh https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/scripts/setup.sh && chmod +x scripts/setup.sh # Get the lastest Tock version/tag from GitHub $ curl -o .env https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/.env # Run the stack $ docker-compose up D\u00e9ployer une plateforme Tock - depuis les sources \u00b6 Ceci est une mani\u00e8re alternative de d\u00e9marrer Tock, \u00e0 partir du d\u00e9p\u00f4t Tock Docker . Il vous faut, en plus de Docker et Docker Compose , soit un client Git pour r\u00e9cup\u00e9rer les sources (commande git clone ) soit avoir d\u00e9j\u00e0 copi\u00e9 les sources de GitHub en local. Pour d\u00e9marrer sans Git ni les sources du d\u00e9p\u00f4t en local, suivez le paragraphe pr\u00e9c\u00e9dent . # Get the lastest sources from GitHub $ git clone https://github.com/theopenconversationkit/tock-docker.git && cd tock-docker # Make the database-init script executable $ chmod +x scripts/setup.sh # Run the stack (including Bot API) $ docker-compose -f docker-compose-bot.yml up Acc\u00e9der \u00e0 Tock Studio \u00b6 Une fois la plateforme pr\u00eate, les interfaces Tock Studio sont sur le port 80 par d\u00e9faut : Allez sur http://localhost Apr\u00e8s le d\u00e9ploiement de la plateforme, celle-ci s'initialise, et il peut falloir attendre quelques secondes avant que les interfaces Tock Studio soient accessibles. Connectez-vous avec les identifiants admin@app.com / password par d\u00e9faut Il est \u00e9videmment recommand\u00e9 de changer ces valeurs \u00e0 l'installation d'une plateforme destin\u00e9e \u00e0 une utilisation p\u00e9renne (production, plateforme partag\u00e9e entre \u00e9quipes, etc.). Cr\u00e9er une application, un connecteur et une intention \u00b6 Comme dans le guide premier bot utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Tock et un connecteur pour commencer \u00e0 utiliser la plateforme locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de commentaires. Au premier acc\u00e8s \u00e0 la plateforme locale : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Allez dans Configuration > Bot Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Create Notez l' API Key automatiquement g\u00e9n\u00e9r\u00e9e pour votre application. Elle vous servira si vous essayez le mode WebSocket dans la suite de ce guide (optionnel). Allez dans Build > New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Allez dans Test > Test the bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16 Connecter un parcours en Kotlin (optionnel) \u00b6 Comme dans le guide programmer des parcours utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Kotlin se connectant en WebSocket \u00e0 la plateforme Tock locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de d\u00e9tails. Cr\u00e9ez un projet Kotlin par exemple avec Maven comme indiqu\u00e9 dans le guide programmer des parcours Le classpath doit inclure tock-bot-api-websocket pour utiliser le mode WebSocket . Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import ai.tock.bot.api.client.newBot import ai.tock.bot.api.client.newStory import ai.tock.bot.api.websocket.start fun main () { start ( // Do not use #startWithDemo when integrating with a local platform newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // Get your app API key from Bot Configurations in Tock Studio newStory ( \"qui-es-tu\" ) { // Answer for the 'qui-es-tu' story send ( \"Je suis un assistant conversationnel construit avec Tock\" ) end ( \"Comment puis-je aider ?\" ) } ), \"http://localhost:8080\" // Local platform URL (default host/port) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration > Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Retournez dans Tock dans Test > Test the bot et dites \"qui es-tu ?\" : le bot ne r\u00e9pond pas encore. Allez dans NLU > Inbox , pour la phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Terminez la qualification de la phrase avec Validate Retournez dans Test > Test the bot . Dites \"qui es-tu ?\" : le bot r\u00e9pond ! F\u00e9licitations! \u00b6 Vous venez de d\u00e9ployer votre propre plateforme conversationnelle Tock en local. Cela peut servir \u00e0 mieux appr\u00e9hender l'architecture et v\u00e9rifier la portabilit\u00e9 de la solution, mais aussi lors de d\u00e9veloppements, pour les contributeurs Tock ou encore si vous devez travailler sans acc\u00e8s \u00e0 Internet (en mobilit\u00e9, sur un r\u00e9seau restreint, etc.). Attention, l'impl\u00e9mentation Docker fournie ne suffit pas \u00e0 garantir r\u00e9silience et mont\u00e9e en charge de la plateforme quelles que soient les conditions en production. Pour cela, quelques recommandations sont propos\u00e9es dans la section haute disponibilit\u00e9 du manuel Tock. Continuer... \u00b6 Vous venez de terminer les guides de d\u00e9marrage rapide Tock. A partir de l\u00e0, vous pouvez vous lancer directement sur une plateforme Tock, ou parcourir le manuel utilisateur pour en savoir plus sur Tock Studio , Bot API et Bot Flow par exemple. D'autres pages pr\u00e9sentent aussi des \u00e9tudes de cas clients, des exemples de code, comment contacter la communaut\u00e9 Tock, etc.","title":"D\u00e9ployer avec Docker"},{"location":"guide/plateforme/#deployer-une-plateforme-avec-docker","text":"Dans les sections pr\u00e9c\u00e9dentes pour d\u00e9couvrir et tester Tock, vous avez utilis\u00e9 la plateforme de d\u00e9monstration . Cela vous a permis de d\u00e9couvrir la construction et la configuration des bots Tock sans avoir \u00e0 installer la plateforme au pr\u00e9alable. Dans ce guide, vous allez apprendre \u00e0 d\u00e9ployer une plateforme compl\u00e8te Tock en quelques minutes, gr\u00e2ce aux exemples d'impl\u00e9mentations Docker / Docker Compose fournies. Notez qu'il est tout \u00e0 fait possible de d\u00e9ployer Tock sans utiliser Docker. Une section sp\u00e9cifique du manuel utilisateur vous en apprendra plus sur l'architecture, les possibilit\u00e9s et les recommandations pour le d\u00e9ploiement et l'utilisation de Tock en production.","title":"D\u00e9ployer une plateforme avec Docker"},{"location":"guide/plateforme/#ce-que-vous-allez-creer","text":"Une plateforme Tock compl\u00e8te en local : Tock Studio , Bot API , etc. Un bot et une configuration minimale pour tester la plateforme (Optionnel) Un programme Kotlin se connectant \u00e0 la plateforme locale en WebSocket","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/plateforme/#pre-requis","text":"Environ 20 minutes Pour d\u00e9ployer la plateforme en local, un environnement de d\u00e9veloppement avec des versions r\u00e9centes de Docker et Docker Compose install\u00e9es Si vous ne souhaitez pas utiliser Docker, pas de probl\u00e8me. Il y a d'autres mani\u00e8res de d\u00e9ployer la base MongoDB et les services Kotlin sur JVM. Vous pouvez toutefois parcourir les Dockerfile et docker-compose.yml \u00e0 titre d'exemples pour instancier ces services. (Optionnel) Pour le programme en WebSocket, un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Sans IDE ou sans Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de compiler et ex\u00e9cuter le programme avec d'autres outils. D'autres modes que Kotlin et WebSocket sont pr\u00e9sent\u00e9s dans le manuel utilisateur Tock .","title":"Pr\u00e9-requis"},{"location":"guide/plateforme/#deployer-une-plateforme-tock-sans-les-sources","text":"Il est possible de r\u00e9cup\u00e9rer seulement quelques fichiers du d\u00e9p\u00f4t GitHub, sans t\u00e9l\u00e9charger toutes les sources Tock. En quelques lignes de commande, la plateforme est op\u00e9rationnelle. Il est cependant indispensable d'avoir des versions r\u00e9centes de Docker et Docker Compose . Pour d\u00e9marrer depuis les sources du d\u00e9p\u00f4t Tock Docker, passez plut\u00f4t au paragraphe suivant . # Get the lastest docker-compose from GitHub (including Bot API) $ curl -o docker-compose.yml https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/docker-compose-bot.yml # Get the lastest database-init script from GitHub $ mkdir -p scripts && curl -o scripts/setup.sh https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/scripts/setup.sh && chmod +x scripts/setup.sh # Get the lastest Tock version/tag from GitHub $ curl -o .env https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/.env # Run the stack $ docker-compose up","title":"D\u00e9ployer une plateforme Tock - sans les sources"},{"location":"guide/plateforme/#deployer-une-plateforme-tock-depuis-les-sources","text":"Ceci est une mani\u00e8re alternative de d\u00e9marrer Tock, \u00e0 partir du d\u00e9p\u00f4t Tock Docker . Il vous faut, en plus de Docker et Docker Compose , soit un client Git pour r\u00e9cup\u00e9rer les sources (commande git clone ) soit avoir d\u00e9j\u00e0 copi\u00e9 les sources de GitHub en local. Pour d\u00e9marrer sans Git ni les sources du d\u00e9p\u00f4t en local, suivez le paragraphe pr\u00e9c\u00e9dent . # Get the lastest sources from GitHub $ git clone https://github.com/theopenconversationkit/tock-docker.git && cd tock-docker # Make the database-init script executable $ chmod +x scripts/setup.sh # Run the stack (including Bot API) $ docker-compose -f docker-compose-bot.yml up","title":"D\u00e9ployer une plateforme Tock - depuis les sources"},{"location":"guide/plateforme/#acceder-a-tock-studio","text":"Une fois la plateforme pr\u00eate, les interfaces Tock Studio sont sur le port 80 par d\u00e9faut : Allez sur http://localhost Apr\u00e8s le d\u00e9ploiement de la plateforme, celle-ci s'initialise, et il peut falloir attendre quelques secondes avant que les interfaces Tock Studio soient accessibles. Connectez-vous avec les identifiants admin@app.com / password par d\u00e9faut Il est \u00e9videmment recommand\u00e9 de changer ces valeurs \u00e0 l'installation d'une plateforme destin\u00e9e \u00e0 une utilisation p\u00e9renne (production, plateforme partag\u00e9e entre \u00e9quipes, etc.).","title":"Acc\u00e9der \u00e0 Tock Studio"},{"location":"guide/plateforme/#creer-une-application-un-connecteur-et-une-intention","text":"Comme dans le guide premier bot utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Tock et un connecteur pour commencer \u00e0 utiliser la plateforme locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de commentaires. Au premier acc\u00e8s \u00e0 la plateforme locale : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Allez dans Configuration > Bot Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Create Notez l' API Key automatiquement g\u00e9n\u00e9r\u00e9e pour votre application. Elle vous servira si vous essayez le mode WebSocket dans la suite de ce guide (optionnel). Allez dans Build > New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Allez dans Test > Test the bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16","title":"Cr\u00e9er une application, un connecteur et une intention"},{"location":"guide/plateforme/#connecter-un-parcours-en-kotlin-optionnel","text":"Comme dans le guide programmer des parcours utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Kotlin se connectant en WebSocket \u00e0 la plateforme Tock locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de d\u00e9tails. Cr\u00e9ez un projet Kotlin par exemple avec Maven comme indiqu\u00e9 dans le guide programmer des parcours Le classpath doit inclure tock-bot-api-websocket pour utiliser le mode WebSocket . Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import ai.tock.bot.api.client.newBot import ai.tock.bot.api.client.newStory import ai.tock.bot.api.websocket.start fun main () { start ( // Do not use #startWithDemo when integrating with a local platform newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // Get your app API key from Bot Configurations in Tock Studio newStory ( \"qui-es-tu\" ) { // Answer for the 'qui-es-tu' story send ( \"Je suis un assistant conversationnel construit avec Tock\" ) end ( \"Comment puis-je aider ?\" ) } ), \"http://localhost:8080\" // Local platform URL (default host/port) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration > Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Retournez dans Tock dans Test > Test the bot et dites \"qui es-tu ?\" : le bot ne r\u00e9pond pas encore. Allez dans NLU > Inbox , pour la phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Terminez la qualification de la phrase avec Validate Retournez dans Test > Test the bot . Dites \"qui es-tu ?\" : le bot r\u00e9pond !","title":"Connecter un parcours en Kotlin (optionnel)"},{"location":"guide/plateforme/#felicitations","text":"Vous venez de d\u00e9ployer votre propre plateforme conversationnelle Tock en local. Cela peut servir \u00e0 mieux appr\u00e9hender l'architecture et v\u00e9rifier la portabilit\u00e9 de la solution, mais aussi lors de d\u00e9veloppements, pour les contributeurs Tock ou encore si vous devez travailler sans acc\u00e8s \u00e0 Internet (en mobilit\u00e9, sur un r\u00e9seau restreint, etc.). Attention, l'impl\u00e9mentation Docker fournie ne suffit pas \u00e0 garantir r\u00e9silience et mont\u00e9e en charge de la plateforme quelles que soient les conditions en production. Pour cela, quelques recommandations sont propos\u00e9es dans la section haute disponibilit\u00e9 du manuel Tock.","title":"F\u00e9licitations!"},{"location":"guide/plateforme/#continuer","text":"Vous venez de terminer les guides de d\u00e9marrage rapide Tock. A partir de l\u00e0, vous pouvez vous lancer directement sur une plateforme Tock, ou parcourir le manuel utilisateur pour en savoir plus sur Tock Studio , Bot API et Bot Flow par exemple. D'autres pages pr\u00e9sentent aussi des \u00e9tudes de cas clients, des exemples de code, comment contacter la communaut\u00e9 Tock, etc.","title":"Continuer..."},{"location":"guide/slack/","text":"Configurer son bot pour Slack \u00b6 Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack mais celui-ci n'est pas encore configur\u00e9 pour que le bot parle r\u00e9ellement sur Slack . Avec un peu de configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock, un bot peut recevoir des messages et r\u00e9pondre sur ce canal. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et configurer un canal Messenger ou passer directement \u00e0 la suite . Ce que vous allez cr\u00e9er \u00b6 Une configuration (dans Slack et dans Tock) pour recevoir et envoyer des messages Slack Un bot qui parle sur une cha\u00eene Slack Pr\u00e9-requis \u00b6 Environ 15 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Slack et un espace de travail / une cha\u00eene o\u00f9 int\u00e9grer le bot Si vous n'avez jamais utilis\u00e9 Slack, rendez-vous sur sur https://slack.com/ Cr\u00e9er une application dans Slack \u00b6 Allez sur la page Create a Slack app Entrez un nom pour l' application S\u00e9lectionnez un espace de travail Terminez avec Create App Activer l'envoi de messages \u00e0 Slack \u00b6 Ouvrez Incoming Webhooks et cochez Activate Incoming Webhooks Cliquez sur Add New Webhook to Workspace S\u00e9lectionnez une cha\u00eene ou une personne pour la conversation avec le bot Terminez par Installer Copiez la Webhook URL qui vient d'\u00eatre cr\u00e9\u00e9e La Webhook URL ressemble dans son format \u00e0 quelque chose comme : https://hooks.slack.com/services/{workspaceToken}/{webhookToken}/{authToken} Dans Tock Studio allez dans Configuration > Bot Configurations Trouvez votre connecteur de type Slack (ou cr\u00e9ez-en un nouveau si besoin) et ouvrez la section Connector Custom Configuration Saisissez dans les trois champs tokens les jetons issus de l'adresse pr\u00e9c\u00e9demment copi\u00e9e : Token 1 : le premier token de la WebhookURL , ou workspaceToken Token 2 : le deuxi\u00e8me token de la WebhookURL , ou webhookToken Token 3 : le dernier token de la WebhookURL , ou authToken Terminez avec Update Activer la reception de messages depuis Slack \u00b6 Dans la page de votre application Slack, allez dans Event Subscriptions et activez Enable Events Entrez dans le champ Request URL l'adresse compl\u00e8te de votre connecteur Slack dans Tock. Sur la plateforme de d\u00e9monstration Tock, cette adresse sera du type https://demo.tock.ai/{chemin_relatif_du_connecteur_slack} Le chemin relatif du connecteur est indiqu\u00e9 dans la page Bot Configurations . Sur la ligne correspondant \u00e0 votre connecteur Slack, il s'agit du champ Relative REST path Ouvrez Add Workspace Event et s\u00e9lectionnez l'\u00e9venement message.channels Validez avec Save Changes Allez dans Interactive Components et activez Interactivity Entrez la m\u00eame Request URL que pr\u00e9c\u00e9demment Validez avec Save Changes Cr\u00e9er un bot Slack (et lui parler) \u00b6 Dans la page de votre application Slack, allez dans Bot Users et faites Add a Bot User Choisissez un nom / identifiant pour le bot dans Slack Validez avec Add Bot User Allez dans Install App et Reinstall App S\u00e9lectionnez la cha\u00eene Slack puis Installer Dans Slack, allez sur la cha\u00eene et parlez au bot (par exemple \"bonjour\"). Le bot vous r\u00e9pond maintenant dans Slack ! Regarder la conversation dans Tock Studio (optionnel) \u00b6 Quelque soient les canaux utilis\u00e9s pour converser avec le bot, vous pouvez suivre les conversations directement dans tous les \u00e9crans Tock Studio , par exemple : NLU > Inbox et Logs , Build > Bot Flow ou encore Monitoring > Users et Dialogs : Dans Tock, ouvrez Monitoring > Users et cliquez sur l'ic\u00f4ne Display dialog pour voir toute la conversation provenant de Slack F\u00e9licitations! \u00b6 Vous venez de configurer votre bot pour qu'il parle \u00e9galement sur Slack. Comme vous le constatez, connecter un bot Tock \u00e0 un (ou plusieurs) canaux externes n'est qu'une affaire de configuration. Vous pouvez construire le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant ind\u00e9pendamment des canaux sur lesquels vous souhaitez lui parler, aujourd'hui ou \u00e0 l'avenir. Continuer... \u00b6 Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Configurer Slack"},{"location":"guide/slack/#configurer-son-bot-pour-slack","text":"Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack mais celui-ci n'est pas encore configur\u00e9 pour que le bot parle r\u00e9ellement sur Slack . Avec un peu de configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock, un bot peut recevoir des messages et r\u00e9pondre sur ce canal. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et configurer un canal Messenger ou passer directement \u00e0 la suite .","title":"Configurer son bot pour Slack"},{"location":"guide/slack/#ce-que-vous-allez-creer","text":"Une configuration (dans Slack et dans Tock) pour recevoir et envoyer des messages Slack Un bot qui parle sur une cha\u00eene Slack","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/slack/#pre-requis","text":"Environ 15 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Slack et un espace de travail / une cha\u00eene o\u00f9 int\u00e9grer le bot Si vous n'avez jamais utilis\u00e9 Slack, rendez-vous sur sur https://slack.com/","title":"Pr\u00e9-requis"},{"location":"guide/slack/#creer-une-application-dans-slack","text":"Allez sur la page Create a Slack app Entrez un nom pour l' application S\u00e9lectionnez un espace de travail Terminez avec Create App","title":"Cr\u00e9er une application dans Slack"},{"location":"guide/slack/#activer-lenvoi-de-messages-a-slack","text":"Ouvrez Incoming Webhooks et cochez Activate Incoming Webhooks Cliquez sur Add New Webhook to Workspace S\u00e9lectionnez une cha\u00eene ou une personne pour la conversation avec le bot Terminez par Installer Copiez la Webhook URL qui vient d'\u00eatre cr\u00e9\u00e9e La Webhook URL ressemble dans son format \u00e0 quelque chose comme : https://hooks.slack.com/services/{workspaceToken}/{webhookToken}/{authToken} Dans Tock Studio allez dans Configuration > Bot Configurations Trouvez votre connecteur de type Slack (ou cr\u00e9ez-en un nouveau si besoin) et ouvrez la section Connector Custom Configuration Saisissez dans les trois champs tokens les jetons issus de l'adresse pr\u00e9c\u00e9demment copi\u00e9e : Token 1 : le premier token de la WebhookURL , ou workspaceToken Token 2 : le deuxi\u00e8me token de la WebhookURL , ou webhookToken Token 3 : le dernier token de la WebhookURL , ou authToken Terminez avec Update","title":"Activer l'envoi de messages \u00e0 Slack"},{"location":"guide/slack/#activer-la-reception-de-messages-depuis-slack","text":"Dans la page de votre application Slack, allez dans Event Subscriptions et activez Enable Events Entrez dans le champ Request URL l'adresse compl\u00e8te de votre connecteur Slack dans Tock. Sur la plateforme de d\u00e9monstration Tock, cette adresse sera du type https://demo.tock.ai/{chemin_relatif_du_connecteur_slack} Le chemin relatif du connecteur est indiqu\u00e9 dans la page Bot Configurations . Sur la ligne correspondant \u00e0 votre connecteur Slack, il s'agit du champ Relative REST path Ouvrez Add Workspace Event et s\u00e9lectionnez l'\u00e9venement message.channels Validez avec Save Changes Allez dans Interactive Components et activez Interactivity Entrez la m\u00eame Request URL que pr\u00e9c\u00e9demment Validez avec Save Changes","title":"Activer la reception de messages depuis Slack"},{"location":"guide/slack/#creer-un-bot-slack-et-lui-parler","text":"Dans la page de votre application Slack, allez dans Bot Users et faites Add a Bot User Choisissez un nom / identifiant pour le bot dans Slack Validez avec Add Bot User Allez dans Install App et Reinstall App S\u00e9lectionnez la cha\u00eene Slack puis Installer Dans Slack, allez sur la cha\u00eene et parlez au bot (par exemple \"bonjour\"). Le bot vous r\u00e9pond maintenant dans Slack !","title":"Cr\u00e9er un bot Slack (et lui parler)"},{"location":"guide/slack/#regarder-la-conversation-dans-tock-studio-optionnel","text":"Quelque soient les canaux utilis\u00e9s pour converser avec le bot, vous pouvez suivre les conversations directement dans tous les \u00e9crans Tock Studio , par exemple : NLU > Inbox et Logs , Build > Bot Flow ou encore Monitoring > Users et Dialogs : Dans Tock, ouvrez Monitoring > Users et cliquez sur l'ic\u00f4ne Display dialog pour voir toute la conversation provenant de Slack","title":"Regarder la conversation dans Tock Studio (optionnel)"},{"location":"guide/slack/#felicitations","text":"Vous venez de configurer votre bot pour qu'il parle \u00e9galement sur Slack. Comme vous le constatez, connecter un bot Tock \u00e0 un (ou plusieurs) canaux externes n'est qu'une affaire de configuration. Vous pouvez construire le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant ind\u00e9pendamment des canaux sur lesquels vous souhaitez lui parler, aujourd'hui ou \u00e0 l'avenir.","title":"F\u00e9licitations!"},{"location":"guide/slack/#continuer","text":"Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Continuer..."},{"location":"guide/studio/","text":"Cr\u00e9er son premier bot avec Tock Studio \u00b6 Un bon moyen de tester Tock est certainement de cr\u00e9er son premier bot conversationnel dans Tock Studio (l'interface graphiques fournie avec la plateforme). En se connectant \u00e0 la plateforme de d\u00e9monstration Tock, il est possible de cr\u00e9er et tester un assistant en quelques minutes sans \u00e9crire de code. Ce que vous allez cr\u00e9er \u00b6 Une application et un connecteur sur la plateforme de d\u00e9monstration Tock Une story : phrase utilisateur / r\u00e9ponse du bot, testable dans l'interface Tock Studio Un assistant qui r\u00e9pond quand vous lui dites \"bonjour\" ! \ud83d\ude42 Pr\u00e9-requis \u00b6 Entre 5 et 15 minutes environ (en lisant les commentaires) Un compte GitHub pour se connecter \u00e0 la plateforme de d\u00e9monstration Connexion \u00e0 la plateforme d\u00e9mo \u00b6 Rendez-vous sur https://demo.tock.ai/ pour acc\u00e9der \u00e0 la plateforme de d\u00e9monstration Tock. Remarque importante : Cette plateforme n'a pas vocation \u00e0 accueillir de v\u00e9ritables bots en production. C'est un moyen de tester et prendre en main la solution Tock sans avoir \u00e0 l'installer. Une invite appara\u00eet pour vous identifier avec votre compte GitHub. Apr\u00e8s cela, vous devez accepter que Tock acc\u00e8de \u00e0 votre compte - seul l'identifiant de votre compte GitHub sera lu. Cr\u00e9er une application Tock \u00b6 Au premier acc\u00e8s \u00e0 la plateforme de d\u00e9monstration, un assistant invite \u00e0 cr\u00e9er une application : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Vous pouvez retrouver l'application cr\u00e9\u00e9e dans le menu : Configuration > NLU Applications . Si vous aviez d\u00e9j\u00e0 cr\u00e9\u00e9 une ou plusieurs applications, vous pouvez en cr\u00e9er de nouvelles en revenant \u00e0 cet \u00e9cran puis Create New Application . Ajouter un connecteur \u00b6 Pour int\u00e9ragir avec le bot, il faut utiliser un connecteur afin de l'exposer \u00e0 un canal de communication. De nombreux connecteurs existent pour Tock : Messenger , WhatsApp , Google Assistant et Google Home , Twitter , Alexa , Business Chat , Teams , Slack , Rocket.Chat ... Il est m\u00eame possible de d\u00e9velopper ses propres connecteurs pour ouvrir le bot \u00e0 de nouveaux canaux. Pour ce tutoriel, vous allez configurer un connecteur pour Slack . Dans un premier temps, vous testerez le bot en restant dans l'interface Tock Studio , et n'aurez pas besoin d'utiliser Slack. Dans la section suivante Configurer Slack , vous pourrez compl\u00e9ter la configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock afin que le bot soit fonctionnel sur cette plateforme collaborative. De m\u00eame, la section Configurer Messenger vous montrera comment activer le m\u00eame bot sur la messagerie du r\u00e9seau social Facebook. Cr\u00e9ez un premier connecteur pour votre application : Allez dans Configuration > Bot Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Entrez token dans les champs Token (pour le moment) Create Notez qu'une API Key a \u00e9t\u00e9 automatiquement g\u00e9n\u00e9r\u00e9e pour votre application \u00e0 la cr\u00e9ation du premier connecteur. Celle-ci vous servira \u00e0 vous connecter \u00e0 l'API du bot si vous essayez le mode WebHook ou WebSocket dans le guide Programmer des parcours . Si vous cliquez sur Display test configurations , vous pouvez voir qu'une seconde configuration est cr\u00e9\u00e9e. Ce connecteur sp\u00e9cial sera utilis\u00e9 pour tester le bot directement depuis l'interface Tock Studio . Gr\u00e2ce \u00e0 lui, vous pourrez parler au bot sans passer par Slack. Cr\u00e9er un parcours \u00b6 Un bot conversationnel analyse les phrases des utilisateurs en langage naturel, pour en d\u00e9terminer l' intention et \u00e9ventuellement des entit\u00e9s . Exemple : dans la phrase \"Quel temps fera-t-il demain ?\", le moteur NLU (Natural Language Understanding) de Tock va reconna\u00eetre une intention \"m\u00e9t\u00e9o\" et une entit\u00e9 \"demain\" venant pr\u00e9ciser/param\u00e9trer cette intention. Encore faut-il avoir d\u00e9clar\u00e9 les intentions et entit\u00e9s possibles, puis qualifi\u00e9 des phrases pour apprendre au bot \u00e0 les d\u00e9tecter. Le menu NLU de Tock permet de g\u00e9rer intentions et entit\u00e9s, qualifier les phrases et ainsi superviser l'apprentissage du bot : plus on qualifie de phrases, plus le bot devient pertinent dans sa compr\u00e9hension du langage. Mais laissons intentions et entit\u00e9s de c\u00f4t\u00e9 pour le moment... Le mode Stories de Tock permet en quelques clics de cr\u00e9er automatiquement des intentions ainsi que les r\u00e9ponses \u00e0 fournir. Ainsi, sans quitter l'interface Tock Studio , vous allez cr\u00e9er un premier parcours de question(s)-r\u00e9ponse(s). Allez dans Build > New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Un formulaire s'ouvre vous permettant de configurer la cr\u00e9ation de la story , l'intention qui sera \u00e9galement cr\u00e9\u00e9e, le type de r\u00e9ponse, etc. Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Il est possible de r\u00e9pondre par plusieurs messages, ou des messages plus \u00e9volu\u00e9s comme des images, des liens, des boutons d' Action de mani\u00e8re \u00e0 continuer le dialogue, etc. La section Tock Studio du manuel utilisateur Tock vous en apprendra plus. Tester le bot \u00b6 Il est maintenant temps de tester le bot et votre premier parcours! Allez dans Test > Test the bot Dites \"bonjour\"\ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16 Si le bot r\u00e9pond qu'il n'a pas compris, c'est certainement un probl\u00e8me de qualification. Vous pouvez v\u00e9rifier que la story et/ou l' intention ont bien \u00e9t\u00e9 cr\u00e9\u00e9s en allant dans Build > Search Stories . V\u00e9rifiez aussi que vous \u00eates sur la bonne application et la bonne langue (au cas o\u00f9 vous en auriez cr\u00e9\u00e9 plusieurs) pour faire le test : ils sont visibles en haut \u00e0 droite de l'interface. Si malgr\u00e9 tout le bot r\u00e9pond qu'il ne comprend pas, peut-\u00eatre n'avez-vous pas saisi exactement la phrase utilis\u00e9e \u00e0 la cr\u00e9ation de la story , et le bot ne fait pas encore le lien avec cette seconde phrase. Dans le paragraphe suivant, vous verrez comment am\u00e9liorer la compr\u00e9hension du bot en qualifiant plus de phrases utilisateur. Si vous obtenez un message d'erreur technique, il s'agit probablement d'une erreur de configuration du connecteur. Am\u00e9liorer la compr\u00e9hension \u00b6 En saisissant des phrases un peu diff\u00e9rentes dans l'\u00e9cran Test the bot , vous pouvez constater qu'il ne comprend pas encore tr\u00e8s bien votre langage - m\u00eame lorsque les phrases sont proches de celle saisie \u00e0 la cr\u00e9ation de la story . C'est normal. Le mod\u00e8le conversationnel et la partie NLU de Tock s'enrichissent progressivement de phrases qualifi\u00e9es pour alimenter les algorithmes et donner des r\u00e9sultats de plus en plus pertinents. Les premiers essais peuvent \u00eatre d\u00e9cevants, mais souvent apr\u00e8s quelques qualifications, voire une ou deux dizaines de phrases qualifi\u00e9es si besoin, votre bot vous comprend d\u00e9j\u00e0 bien mieux. Allez dans NLU > Inbox Vous voyez les phrases que vous avez saisies, et comment le bot les a interpr\u00eat\u00e9es. Pour chacune s'affichent l'intention reconnue, la langue ainsi que le score (que se donnent les algorithmes selon leur niveau de confiance sur cette phrase). Choisissez quelques phrases, pour chacune s\u00e9lectionnez la bonne intention puis Validate Retournez dans Test > Test the bot V\u00e9rifiez que le bot comprend mieux ces phrases, et m\u00eames d'autres un peu diff\u00e9rentes alors que vous ne les avez pas qualifi\u00e9es explicitement! Cr\u00e9er d'autres parcours (optionnel) \u00b6 Pour aller un peu plus loin avec les stories Tock, vous pouvez cr\u00e9er d'autres parcours et les tester directement dans Tock Studio . Le bot vous r\u00e9pond alors selon l'intention d\u00e9clench\u00e9e, sans autre forme de navigation que le fil que vous donnez \u00e0 la conversation. C'est la magie du conversationnel : le langage naturel est la seule navigation, et l'utilisateur est soustrait aux liens et menus traditionnellement impos\u00e9s par les interfaces Web ou mobiles. Remarque : si vous preniez le temps de cr\u00e9er de tr\u00e8s nombreuses stories , vous contasteriez peut-\u00eatre quelques effets ind\u00e9sirables propres au mode de fonctionnement des mod\u00e8les et algorithmes NLU . Par exemple, un tr\u00e8s grand nombre d'intentions et d'entit\u00e9s peut rendre plus difficile leur d\u00e9tection. On recommande souvent de commencer par cr\u00e9er des bots d\u00e9di\u00e9s \u00e0 un domaine fonctionnel limit\u00e9, facilitant son apprentissage en focalisant le mod\u00e8le sur ce domaine. Qualifier beaucoup de phrases permet en g\u00e9n\u00e9ral d'am\u00e9liorer la compr\u00e9hension, mais \u00e0 l'inverse qualifier trop de phrases (ou trop proches) peut sur-entra\u00eener le mod\u00e8le pour une intention, avec pour effet de r\u00e9duire la reconnaissance des phrases un peu diff\u00e9rentes. Retenez que la conception et la maintenance des mod\u00e8les conversationnels est un sujet complexe qui n\u00e9cessite de l'apprentissage (du bot mais aussi de ceux qui le construisent), de r\u00e9-\u00e9valuer et r\u00e9-adapter r\u00e9guli\u00e8rement ces mod\u00e8les aux besoins et aux nouvelles demandes des utilisateurs. F\u00e9licitations! \u00b6 Vous venez de cr\u00e9er votre premier bot conversationnel avec Tock. Comme vous avez pu vous en apercevoir, quelques minutes suffisent, sans connaissances techniques approfondies, pour cr\u00e9er des parcours conversationnels simples sans \u00e9crire ni d\u00e9ployer de code. Continuer... \u00b6 Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Slack (requiert un compte Slack) Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Cr\u00e9er son premier bot"},{"location":"guide/studio/#creer-son-premier-bot-avec-tock-studio","text":"Un bon moyen de tester Tock est certainement de cr\u00e9er son premier bot conversationnel dans Tock Studio (l'interface graphiques fournie avec la plateforme). En se connectant \u00e0 la plateforme de d\u00e9monstration Tock, il est possible de cr\u00e9er et tester un assistant en quelques minutes sans \u00e9crire de code.","title":"Cr\u00e9er son premier bot avec Tock Studio"},{"location":"guide/studio/#ce-que-vous-allez-creer","text":"Une application et un connecteur sur la plateforme de d\u00e9monstration Tock Une story : phrase utilisateur / r\u00e9ponse du bot, testable dans l'interface Tock Studio Un assistant qui r\u00e9pond quand vous lui dites \"bonjour\" ! \ud83d\ude42","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/studio/#pre-requis","text":"Entre 5 et 15 minutes environ (en lisant les commentaires) Un compte GitHub pour se connecter \u00e0 la plateforme de d\u00e9monstration","title":"Pr\u00e9-requis"},{"location":"guide/studio/#connexion-a-la-plateforme-demo","text":"Rendez-vous sur https://demo.tock.ai/ pour acc\u00e9der \u00e0 la plateforme de d\u00e9monstration Tock. Remarque importante : Cette plateforme n'a pas vocation \u00e0 accueillir de v\u00e9ritables bots en production. C'est un moyen de tester et prendre en main la solution Tock sans avoir \u00e0 l'installer. Une invite appara\u00eet pour vous identifier avec votre compte GitHub. Apr\u00e8s cela, vous devez accepter que Tock acc\u00e8de \u00e0 votre compte - seul l'identifiant de votre compte GitHub sera lu.","title":"Connexion \u00e0 la plateforme d\u00e9mo"},{"location":"guide/studio/#creer-une-application-tock","text":"Au premier acc\u00e8s \u00e0 la plateforme de d\u00e9monstration, un assistant invite \u00e0 cr\u00e9er une application : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Vous pouvez retrouver l'application cr\u00e9\u00e9e dans le menu : Configuration > NLU Applications . Si vous aviez d\u00e9j\u00e0 cr\u00e9\u00e9 une ou plusieurs applications, vous pouvez en cr\u00e9er de nouvelles en revenant \u00e0 cet \u00e9cran puis Create New Application .","title":"Cr\u00e9er une application Tock"},{"location":"guide/studio/#ajouter-un-connecteur","text":"Pour int\u00e9ragir avec le bot, il faut utiliser un connecteur afin de l'exposer \u00e0 un canal de communication. De nombreux connecteurs existent pour Tock : Messenger , WhatsApp , Google Assistant et Google Home , Twitter , Alexa , Business Chat , Teams , Slack , Rocket.Chat ... Il est m\u00eame possible de d\u00e9velopper ses propres connecteurs pour ouvrir le bot \u00e0 de nouveaux canaux. Pour ce tutoriel, vous allez configurer un connecteur pour Slack . Dans un premier temps, vous testerez le bot en restant dans l'interface Tock Studio , et n'aurez pas besoin d'utiliser Slack. Dans la section suivante Configurer Slack , vous pourrez compl\u00e9ter la configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock afin que le bot soit fonctionnel sur cette plateforme collaborative. De m\u00eame, la section Configurer Messenger vous montrera comment activer le m\u00eame bot sur la messagerie du r\u00e9seau social Facebook. Cr\u00e9ez un premier connecteur pour votre application : Allez dans Configuration > Bot Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Entrez token dans les champs Token (pour le moment) Create Notez qu'une API Key a \u00e9t\u00e9 automatiquement g\u00e9n\u00e9r\u00e9e pour votre application \u00e0 la cr\u00e9ation du premier connecteur. Celle-ci vous servira \u00e0 vous connecter \u00e0 l'API du bot si vous essayez le mode WebHook ou WebSocket dans le guide Programmer des parcours . Si vous cliquez sur Display test configurations , vous pouvez voir qu'une seconde configuration est cr\u00e9\u00e9e. Ce connecteur sp\u00e9cial sera utilis\u00e9 pour tester le bot directement depuis l'interface Tock Studio . Gr\u00e2ce \u00e0 lui, vous pourrez parler au bot sans passer par Slack.","title":"Ajouter un connecteur"},{"location":"guide/studio/#creer-un-parcours","text":"Un bot conversationnel analyse les phrases des utilisateurs en langage naturel, pour en d\u00e9terminer l' intention et \u00e9ventuellement des entit\u00e9s . Exemple : dans la phrase \"Quel temps fera-t-il demain ?\", le moteur NLU (Natural Language Understanding) de Tock va reconna\u00eetre une intention \"m\u00e9t\u00e9o\" et une entit\u00e9 \"demain\" venant pr\u00e9ciser/param\u00e9trer cette intention. Encore faut-il avoir d\u00e9clar\u00e9 les intentions et entit\u00e9s possibles, puis qualifi\u00e9 des phrases pour apprendre au bot \u00e0 les d\u00e9tecter. Le menu NLU de Tock permet de g\u00e9rer intentions et entit\u00e9s, qualifier les phrases et ainsi superviser l'apprentissage du bot : plus on qualifie de phrases, plus le bot devient pertinent dans sa compr\u00e9hension du langage. Mais laissons intentions et entit\u00e9s de c\u00f4t\u00e9 pour le moment... Le mode Stories de Tock permet en quelques clics de cr\u00e9er automatiquement des intentions ainsi que les r\u00e9ponses \u00e0 fournir. Ainsi, sans quitter l'interface Tock Studio , vous allez cr\u00e9er un premier parcours de question(s)-r\u00e9ponse(s). Allez dans Build > New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Un formulaire s'ouvre vous permettant de configurer la cr\u00e9ation de la story , l'intention qui sera \u00e9galement cr\u00e9\u00e9e, le type de r\u00e9ponse, etc. Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Il est possible de r\u00e9pondre par plusieurs messages, ou des messages plus \u00e9volu\u00e9s comme des images, des liens, des boutons d' Action de mani\u00e8re \u00e0 continuer le dialogue, etc. La section Tock Studio du manuel utilisateur Tock vous en apprendra plus.","title":"Cr\u00e9er un parcours"},{"location":"guide/studio/#tester-le-bot","text":"Il est maintenant temps de tester le bot et votre premier parcours! Allez dans Test > Test the bot Dites \"bonjour\"\ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16 Si le bot r\u00e9pond qu'il n'a pas compris, c'est certainement un probl\u00e8me de qualification. Vous pouvez v\u00e9rifier que la story et/ou l' intention ont bien \u00e9t\u00e9 cr\u00e9\u00e9s en allant dans Build > Search Stories . V\u00e9rifiez aussi que vous \u00eates sur la bonne application et la bonne langue (au cas o\u00f9 vous en auriez cr\u00e9\u00e9 plusieurs) pour faire le test : ils sont visibles en haut \u00e0 droite de l'interface. Si malgr\u00e9 tout le bot r\u00e9pond qu'il ne comprend pas, peut-\u00eatre n'avez-vous pas saisi exactement la phrase utilis\u00e9e \u00e0 la cr\u00e9ation de la story , et le bot ne fait pas encore le lien avec cette seconde phrase. Dans le paragraphe suivant, vous verrez comment am\u00e9liorer la compr\u00e9hension du bot en qualifiant plus de phrases utilisateur. Si vous obtenez un message d'erreur technique, il s'agit probablement d'une erreur de configuration du connecteur.","title":"Tester le bot"},{"location":"guide/studio/#ameliorer-la-comprehension","text":"En saisissant des phrases un peu diff\u00e9rentes dans l'\u00e9cran Test the bot , vous pouvez constater qu'il ne comprend pas encore tr\u00e8s bien votre langage - m\u00eame lorsque les phrases sont proches de celle saisie \u00e0 la cr\u00e9ation de la story . C'est normal. Le mod\u00e8le conversationnel et la partie NLU de Tock s'enrichissent progressivement de phrases qualifi\u00e9es pour alimenter les algorithmes et donner des r\u00e9sultats de plus en plus pertinents. Les premiers essais peuvent \u00eatre d\u00e9cevants, mais souvent apr\u00e8s quelques qualifications, voire une ou deux dizaines de phrases qualifi\u00e9es si besoin, votre bot vous comprend d\u00e9j\u00e0 bien mieux. Allez dans NLU > Inbox Vous voyez les phrases que vous avez saisies, et comment le bot les a interpr\u00eat\u00e9es. Pour chacune s'affichent l'intention reconnue, la langue ainsi que le score (que se donnent les algorithmes selon leur niveau de confiance sur cette phrase). Choisissez quelques phrases, pour chacune s\u00e9lectionnez la bonne intention puis Validate Retournez dans Test > Test the bot V\u00e9rifiez que le bot comprend mieux ces phrases, et m\u00eames d'autres un peu diff\u00e9rentes alors que vous ne les avez pas qualifi\u00e9es explicitement!","title":"Am\u00e9liorer la compr\u00e9hension"},{"location":"guide/studio/#creer-dautres-parcours-optionnel","text":"Pour aller un peu plus loin avec les stories Tock, vous pouvez cr\u00e9er d'autres parcours et les tester directement dans Tock Studio . Le bot vous r\u00e9pond alors selon l'intention d\u00e9clench\u00e9e, sans autre forme de navigation que le fil que vous donnez \u00e0 la conversation. C'est la magie du conversationnel : le langage naturel est la seule navigation, et l'utilisateur est soustrait aux liens et menus traditionnellement impos\u00e9s par les interfaces Web ou mobiles. Remarque : si vous preniez le temps de cr\u00e9er de tr\u00e8s nombreuses stories , vous contasteriez peut-\u00eatre quelques effets ind\u00e9sirables propres au mode de fonctionnement des mod\u00e8les et algorithmes NLU . Par exemple, un tr\u00e8s grand nombre d'intentions et d'entit\u00e9s peut rendre plus difficile leur d\u00e9tection. On recommande souvent de commencer par cr\u00e9er des bots d\u00e9di\u00e9s \u00e0 un domaine fonctionnel limit\u00e9, facilitant son apprentissage en focalisant le mod\u00e8le sur ce domaine. Qualifier beaucoup de phrases permet en g\u00e9n\u00e9ral d'am\u00e9liorer la compr\u00e9hension, mais \u00e0 l'inverse qualifier trop de phrases (ou trop proches) peut sur-entra\u00eener le mod\u00e8le pour une intention, avec pour effet de r\u00e9duire la reconnaissance des phrases un peu diff\u00e9rentes. Retenez que la conception et la maintenance des mod\u00e8les conversationnels est un sujet complexe qui n\u00e9cessite de l'apprentissage (du bot mais aussi de ceux qui le construisent), de r\u00e9-\u00e9valuer et r\u00e9-adapter r\u00e9guli\u00e8rement ces mod\u00e8les aux besoins et aux nouvelles demandes des utilisateurs.","title":"Cr\u00e9er d'autres parcours (optionnel)"},{"location":"guide/studio/#felicitations","text":"Vous venez de cr\u00e9er votre premier bot conversationnel avec Tock. Comme vous avez pu vous en apercevoir, quelques minutes suffisent, sans connaissances techniques approfondies, pour cr\u00e9er des parcours conversationnels simples sans \u00e9crire ni d\u00e9ployer de code.","title":"F\u00e9licitations!"},{"location":"guide/studio/#continuer","text":"Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Slack (requiert un compte Slack) Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Continuer..."},{"location":"utilisateur/canaux/","text":"Construire un bot multicanal avec Tock \u00b6 Notion de connecteur \u00b6 Un connecteur Tock permet d'int\u00e9grer un bot \u00e0 un canal de communication textuel ou vocal externe. Mis \u00e0 part le type connecteur de test , d\u00e9di\u00e9 aux tests via l'interface Tock Studio , les connecteurs sont associ\u00e9s \u00e0 des canaux externes \u00e0 la plateforme Tock. Tout l'int\u00e9r\u00eat des connecteurs Tock r\u00e9side dans la possibilit\u00e9 de d\u00e9velopper des assistants conversationnels ind\u00e9pendamment du ou des canaux utilis\u00e9s pour lui parler. Il est ainsi possible de cr\u00e9er un bot pour un canal, puis le rendre multicanal par la suite en ajoutant des connecteurs. Connecteurs fournis avec Tock \u00b6 Tock fournit de nombreux connecteurs pour diff\u00e9rents types de canaux (voir ci-dessous). De nouveaux connecteurs sont r\u00e9guli\u00e8rement ajout\u00e9s \u00e0 la plateforme, en fonction des besoins projets mais aussi du calendrier d'ouverture aux bots des canaux grand public. Exemples : arriv\u00e9e de Google Home en France en 2017, Alexa en 2018, ouverture des API WhatsApp puis Business Chat en 2019, etc. Messenger \u00b6 Canal : Facebook Messenger Type : texte (+ voix via l'upload de messages vocaux) Status : connecteur Tock utilis\u00e9 en production depuis 2016 Le guide Connecter son bot \u00e0 Messenger explique comment int\u00e9grer un bot Tock avec une page Facebook / Messenger . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-messenger sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Slack \u00b6 Canal : Slack Type : texte Status : connecteur Tock utilis\u00e9 hors production Le guide Connecter son bot \u00e0 Slack explique comment int\u00e9grer un bot Tock avec une cha\u00eene Slack . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Google Assistant / Google Home \u00b6 Canal : Google Assistant / Google Home Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2017 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-ga sur GitHub. Alexa / Echo \u00b6 Canal : Amazon Alexa Type : voix Status : connecteur Tock utilis\u00e9 en production depuis 2018 Remarque importante : dans le cas d'Alexa, le mod\u00e8le NLP est forc\u00e9ment construit et h\u00e9berg\u00e9 chez Amazon. Seul la partie framework conversationel de Tock peut \u00eatre utilis\u00e9e. Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-alexa sur GitHub. Rocket.Chat \u00b6 Canal : Rocket.Chat Type : texte Status : \u00e0 pr\u00e9ciser Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-rocketchat sur GitHub. WhatsApp \u00b6 Canal : WhatsApp from Facebook Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-whatsapp sur GitHub. Teams \u00b6 Canal : Microsoft Teams Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-teams sur GitHub. Business Chat / Messages \u00b6 Canal : Apple Business Chat (Messages) Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-businesschat sur GitHub. Twitter \u00b6 Canal : Twitter (messages priv\u00e9s) Type : texte Status : connecteur Tock en d\u00e9veloppement Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-twitter sur GitHub. Web \u00b6 Work in progress Test \u00b6 Ce connecteur est interne \u00e0 Tock, il sert \u00e0 dialoguer avec un bot directement dans l'interface Tock Studio (vue Test > Test the bot ). Architecture & gouvernance des mod\u00e8les et donn\u00e9es \u00b6 Dans une optique de gouvernance des mod\u00e8les et donn\u00e9es conversationnelles, l'architecture en connecteurs Tock pr\u00e9sente plusieurs avantages : Le mod\u00e8le est construit dans Tock, il n'est pas partag\u00e9 via les connecteurs Le choix des connecteurs d'un bot permet de maitriser la propagation (ou non) des conversations Par exemple, pour un bot interne \u00e0 une entreprise, on peut choisir de n'utiliser que des connecteurs vers des canaux propres (site Web, etc.) ou internes \u00e0 l'entreprise (applications d'entreprise, espace pro sur un t\u00e9l\u00e9phone Android, etc.). M\u00eame si un bot est connect\u00e9 \u00e0 plusieurs canaux/partenaires externes, seule la plateforme Tock poss\u00e8de l'ensemble des conversations sur tous ces canaux. D\u00e9velopper son propre connecteur \u00b6 Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. La section Bot Framework du manuel d\u00e9veloppeur Tock donne des indications pour impl\u00e9menter son propre connecteur.","title":"Bot multicanal"},{"location":"utilisateur/canaux/#construire-un-bot-multicanal-avec-tock","text":"","title":"Construire un bot multicanal avec Tock"},{"location":"utilisateur/canaux/#notion-de-connecteur","text":"Un connecteur Tock permet d'int\u00e9grer un bot \u00e0 un canal de communication textuel ou vocal externe. Mis \u00e0 part le type connecteur de test , d\u00e9di\u00e9 aux tests via l'interface Tock Studio , les connecteurs sont associ\u00e9s \u00e0 des canaux externes \u00e0 la plateforme Tock. Tout l'int\u00e9r\u00eat des connecteurs Tock r\u00e9side dans la possibilit\u00e9 de d\u00e9velopper des assistants conversationnels ind\u00e9pendamment du ou des canaux utilis\u00e9s pour lui parler. Il est ainsi possible de cr\u00e9er un bot pour un canal, puis le rendre multicanal par la suite en ajoutant des connecteurs.","title":"Notion de connecteur"},{"location":"utilisateur/canaux/#connecteurs-fournis-avec-tock","text":"Tock fournit de nombreux connecteurs pour diff\u00e9rents types de canaux (voir ci-dessous). De nouveaux connecteurs sont r\u00e9guli\u00e8rement ajout\u00e9s \u00e0 la plateforme, en fonction des besoins projets mais aussi du calendrier d'ouverture aux bots des canaux grand public. Exemples : arriv\u00e9e de Google Home en France en 2017, Alexa en 2018, ouverture des API WhatsApp puis Business Chat en 2019, etc.","title":"Connecteurs fournis avec Tock"},{"location":"utilisateur/canaux/#messenger","text":"Canal : Facebook Messenger Type : texte (+ voix via l'upload de messages vocaux) Status : connecteur Tock utilis\u00e9 en production depuis 2016 Le guide Connecter son bot \u00e0 Messenger explique comment int\u00e9grer un bot Tock avec une page Facebook / Messenger . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-messenger sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur.","title":"Messenger"},{"location":"utilisateur/canaux/#slack","text":"Canal : Slack Type : texte Status : connecteur Tock utilis\u00e9 hors production Le guide Connecter son bot \u00e0 Slack explique comment int\u00e9grer un bot Tock avec une cha\u00eene Slack . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur.","title":"Slack"},{"location":"utilisateur/canaux/#google-assistant-google-home","text":"Canal : Google Assistant / Google Home Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2017 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-ga sur GitHub.","title":"Google Assistant / Google Home"},{"location":"utilisateur/canaux/#alexa-echo","text":"Canal : Amazon Alexa Type : voix Status : connecteur Tock utilis\u00e9 en production depuis 2018 Remarque importante : dans le cas d'Alexa, le mod\u00e8le NLP est forc\u00e9ment construit et h\u00e9berg\u00e9 chez Amazon. Seul la partie framework conversationel de Tock peut \u00eatre utilis\u00e9e. Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-alexa sur GitHub.","title":"Alexa / Echo"},{"location":"utilisateur/canaux/#rocketchat","text":"Canal : Rocket.Chat Type : texte Status : \u00e0 pr\u00e9ciser Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-rocketchat sur GitHub.","title":"Rocket.Chat"},{"location":"utilisateur/canaux/#whatsapp","text":"Canal : WhatsApp from Facebook Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-whatsapp sur GitHub.","title":"WhatsApp"},{"location":"utilisateur/canaux/#teams","text":"Canal : Microsoft Teams Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-teams sur GitHub.","title":"Teams"},{"location":"utilisateur/canaux/#business-chat-messages","text":"Canal : Apple Business Chat (Messages) Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-businesschat sur GitHub.","title":"Business Chat / Messages"},{"location":"utilisateur/canaux/#twitter","text":"Canal : Twitter (messages priv\u00e9s) Type : texte Status : connecteur Tock en d\u00e9veloppement Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-twitter sur GitHub.","title":"Twitter"},{"location":"utilisateur/canaux/#web","text":"Work in progress","title":"Web"},{"location":"utilisateur/canaux/#test","text":"Ce connecteur est interne \u00e0 Tock, il sert \u00e0 dialoguer avec un bot directement dans l'interface Tock Studio (vue Test > Test the bot ).","title":"Test"},{"location":"utilisateur/canaux/#architecture-gouvernance-des-modeles-et-donnees","text":"Dans une optique de gouvernance des mod\u00e8les et donn\u00e9es conversationnelles, l'architecture en connecteurs Tock pr\u00e9sente plusieurs avantages : Le mod\u00e8le est construit dans Tock, il n'est pas partag\u00e9 via les connecteurs Le choix des connecteurs d'un bot permet de maitriser la propagation (ou non) des conversations Par exemple, pour un bot interne \u00e0 une entreprise, on peut choisir de n'utiliser que des connecteurs vers des canaux propres (site Web, etc.) ou internes \u00e0 l'entreprise (applications d'entreprise, espace pro sur un t\u00e9l\u00e9phone Android, etc.). M\u00eame si un bot est connect\u00e9 \u00e0 plusieurs canaux/partenaires externes, seule la plateforme Tock poss\u00e8de l'ensemble des conversations sur tous ces canaux.","title":"Architecture &amp; gouvernance des mod\u00e8les et donn\u00e9es"},{"location":"utilisateur/canaux/#developper-son-propre-connecteur","text":"Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. La section Bot Framework du manuel d\u00e9veloppeur Tock donne des indications pour impl\u00e9menter son propre connecteur.","title":"D\u00e9velopper son propre connecteur"},{"location":"utilisateur/concepts/","text":"Concepts conversationnels pour Tock \u00b6 Cette page pr\u00e9sente et vulgarise les principaux concepts et la terminologie conversationnelle utilis\u00e9e dans Tock et sa documentation. Un tableau propose \u00e9galement des \u00e9quivalences et termes similaires dans d'autres solutions conversationnelles. Notions de base \u00b6 Application \u00b6 Une application correspond \u00e0 un corpus de phrases dont Tock va tirer un ensemble de mod\u00e8les statistiques lui permettant d'analyser les phrases utilisateurs. Dans son mode conversationnel, elle correspond aussi \u00e0 diff\u00e9rent param\u00e8tres qui permettent de d\u00e9finir les r\u00e9ponses et le comportement du ou des bots de cette application. Connecteur \u00b6 Un connecteur permet \u00e0 Tock de connecter un bot \u00e0 un canal comme Messenger, Slack, etc. Il se configure dans l'onglet Bot Configurations . Tock permet de mutualiser tr\u00e8s facilement le code d'un bot pour qu'il puisse r\u00e9pondre \u00e0 plusieurs connecteurs. Namespace \u00b6 Le namespace permet d'identifier le groupe organisationnel d'un objet. Il appara\u00eet en g\u00e9n\u00e9ral comme un pr\u00e9fixe suivit de \":\" dans une cha\u00eene de caract\u00e8res. Par exemple l'entit\u00e9 de type \"duckling:datetime\" est l'entit\u00e9 de type \"datetime\" qui vient du module \"duckling\" : ici \"duckling\" est le namespace. Si vous utilisez la plateforme de d\u00e9monstration, votre namespace est votre login Github. Intentions \u00b6 Pour pouvoir d\u00e9finir des actions suite \u00e0 une demande utilisateur, il est n\u00e9cessaire au pr\u00e9alable de classifier ou cat\u00e9goriser cette demande. Ce qu'on appelle une intention est justement cette classification. Par exemple, les phrases \"Quel temps fait-il?\", \"Il fait beau demain ?\", \"J'esp\u00e8re qu'il ne va pas pleuvoir \u00e0 Paris ?\" peuvent toutes \u00eatre cat\u00e9goris\u00e9es avec l'intention \"m\u00e9t\u00e9o\". A partir des phrases classifi\u00e9es manuellement par un utilisateur, Tock va automatiquement construire un mod\u00e8le statistique qui va lui permettre, pour une nouvelle phrase, de d\u00e9terminer quelle est l'intention la plus probable. Pour reprendre l'exemple ci-dessus, avec un mod\u00e8le constitu\u00e9 des trois phrases d'exemple, il est probable qu'une nouvelle phrase du type \"Quel temps fera t'il demain ?\" sera reconnue automatiquement par Tock comme correspondant \u00e0 l'intention \"m\u00e9t\u00e9o\". Entit\u00e9s \u00b6 Une fois l'intention d\u00e9termin\u00e9e, il est souvent utile d'identifier le sens de certains mots de la phrase. Dans la phrase \"Il fait beau demain ?\", le mot \"demain\" a une signification qu'il faudra utiliser pour r\u00e9pondre de mani\u00e8re pertinente \u00e0 la question. On appelle entit\u00e9s ces mots significatifs de la phrase. Une entit\u00e9 \u00e0 un type et un role. Par exemple, dans la phrase \"Je pars \u00e0 11h et j'arrive \u00e0 18h\", les mots \"\u00e0 11h\" et \"\u00e0 18h\" sont tous les deux des entit\u00e9s de type 'datetime' mais \"11h\" aura un r\u00f4le depart l\u00e0 ou \"18h\" aura un r\u00f4le arriv\u00e9e . Dans les cas o\u00f9 le r\u00f4le n'apporte pas d'information suppl\u00e9mentaire, il est souvent \u00e9gal au type. On distingue deux \u00e9tapes dans la prise en compte d'une entit\u00e9 : L' identification : quels sont les mots de la phrase qui constituent l'entit\u00e9 La valorisation : quelle est la valeur de cette entit\u00e9. Par exemple comment traduire \"\u00e0 11h\" en date syst\u00e8me. Tock par d\u00e9faut identifie l'entit\u00e9, mais ne la valorise pas, sauf pour certains types. Par d\u00e9faut, les entit\u00e9s de namespace \"duckling\" seront automatiquement valoris\u00e9es. Sc\u00e9nario (ou Story ) \u00b6 Un sc\u00e9nario ou story est un regroupement fonctionnel qui permet de r\u00e9pondre aux questions sur un sujet bien d\u00e9limit\u00e9. Il est en g\u00e9n\u00e9ral initi\u00e9 par une intention principale et peut aussi utiliser, de mani\u00e8re optionelle, une arborescence d'intentions dites \"secondaires\". Pour reprendre l'exemple de la m\u00e9t\u00e9o, \u00e0 quelqu'un demandant \"Quel temps fait-il ?\", il peut \u00eatre utile de poser la question de l'endroit o\u00f9 il se trouve. Cette question sera prise en compte dans la story \"m\u00e9t\u00e9o\" puisqu'elle n'est qu'une extension de la question initiale. La Story est l'unit\u00e9 principale du framework conversationnel de Tock. Termes & correspondances \u00b6 Le tableau ci-dessous propose des correspondances entre les termes utilis\u00e9s dans Tock et ceux d'autres solutions conversationnelles : Tock DialogFlow Alexa Intent Intent Intent Entity Entity Sentence Query Utterance / Slot Story Connector Integration Application Project / Agent Skill La documentation des connecteurs Tock donne \u00e9galement la correspondance avec d'autres termes propres \u00e0 tel ou tel canal. Continuer... \u00b6 Vous pouvez maintenant entamer le chapitre suivant : Interfaces Tock Studio .","title":"Concepts"},{"location":"utilisateur/concepts/#concepts-conversationnels-pour-tock","text":"Cette page pr\u00e9sente et vulgarise les principaux concepts et la terminologie conversationnelle utilis\u00e9e dans Tock et sa documentation. Un tableau propose \u00e9galement des \u00e9quivalences et termes similaires dans d'autres solutions conversationnelles.","title":"Concepts conversationnels pour Tock"},{"location":"utilisateur/concepts/#notions-de-base","text":"","title":"Notions de base"},{"location":"utilisateur/concepts/#application","text":"Une application correspond \u00e0 un corpus de phrases dont Tock va tirer un ensemble de mod\u00e8les statistiques lui permettant d'analyser les phrases utilisateurs. Dans son mode conversationnel, elle correspond aussi \u00e0 diff\u00e9rent param\u00e8tres qui permettent de d\u00e9finir les r\u00e9ponses et le comportement du ou des bots de cette application.","title":"Application"},{"location":"utilisateur/concepts/#connecteur","text":"Un connecteur permet \u00e0 Tock de connecter un bot \u00e0 un canal comme Messenger, Slack, etc. Il se configure dans l'onglet Bot Configurations . Tock permet de mutualiser tr\u00e8s facilement le code d'un bot pour qu'il puisse r\u00e9pondre \u00e0 plusieurs connecteurs.","title":"Connecteur"},{"location":"utilisateur/concepts/#namespace","text":"Le namespace permet d'identifier le groupe organisationnel d'un objet. Il appara\u00eet en g\u00e9n\u00e9ral comme un pr\u00e9fixe suivit de \":\" dans une cha\u00eene de caract\u00e8res. Par exemple l'entit\u00e9 de type \"duckling:datetime\" est l'entit\u00e9 de type \"datetime\" qui vient du module \"duckling\" : ici \"duckling\" est le namespace. Si vous utilisez la plateforme de d\u00e9monstration, votre namespace est votre login Github.","title":"Namespace"},{"location":"utilisateur/concepts/#intentions","text":"Pour pouvoir d\u00e9finir des actions suite \u00e0 une demande utilisateur, il est n\u00e9cessaire au pr\u00e9alable de classifier ou cat\u00e9goriser cette demande. Ce qu'on appelle une intention est justement cette classification. Par exemple, les phrases \"Quel temps fait-il?\", \"Il fait beau demain ?\", \"J'esp\u00e8re qu'il ne va pas pleuvoir \u00e0 Paris ?\" peuvent toutes \u00eatre cat\u00e9goris\u00e9es avec l'intention \"m\u00e9t\u00e9o\". A partir des phrases classifi\u00e9es manuellement par un utilisateur, Tock va automatiquement construire un mod\u00e8le statistique qui va lui permettre, pour une nouvelle phrase, de d\u00e9terminer quelle est l'intention la plus probable. Pour reprendre l'exemple ci-dessus, avec un mod\u00e8le constitu\u00e9 des trois phrases d'exemple, il est probable qu'une nouvelle phrase du type \"Quel temps fera t'il demain ?\" sera reconnue automatiquement par Tock comme correspondant \u00e0 l'intention \"m\u00e9t\u00e9o\".","title":"Intentions"},{"location":"utilisateur/concepts/#entites","text":"Une fois l'intention d\u00e9termin\u00e9e, il est souvent utile d'identifier le sens de certains mots de la phrase. Dans la phrase \"Il fait beau demain ?\", le mot \"demain\" a une signification qu'il faudra utiliser pour r\u00e9pondre de mani\u00e8re pertinente \u00e0 la question. On appelle entit\u00e9s ces mots significatifs de la phrase. Une entit\u00e9 \u00e0 un type et un role. Par exemple, dans la phrase \"Je pars \u00e0 11h et j'arrive \u00e0 18h\", les mots \"\u00e0 11h\" et \"\u00e0 18h\" sont tous les deux des entit\u00e9s de type 'datetime' mais \"11h\" aura un r\u00f4le depart l\u00e0 ou \"18h\" aura un r\u00f4le arriv\u00e9e . Dans les cas o\u00f9 le r\u00f4le n'apporte pas d'information suppl\u00e9mentaire, il est souvent \u00e9gal au type. On distingue deux \u00e9tapes dans la prise en compte d'une entit\u00e9 : L' identification : quels sont les mots de la phrase qui constituent l'entit\u00e9 La valorisation : quelle est la valeur de cette entit\u00e9. Par exemple comment traduire \"\u00e0 11h\" en date syst\u00e8me. Tock par d\u00e9faut identifie l'entit\u00e9, mais ne la valorise pas, sauf pour certains types. Par d\u00e9faut, les entit\u00e9s de namespace \"duckling\" seront automatiquement valoris\u00e9es.","title":"Entit\u00e9s"},{"location":"utilisateur/concepts/#scenario-ou-story","text":"Un sc\u00e9nario ou story est un regroupement fonctionnel qui permet de r\u00e9pondre aux questions sur un sujet bien d\u00e9limit\u00e9. Il est en g\u00e9n\u00e9ral initi\u00e9 par une intention principale et peut aussi utiliser, de mani\u00e8re optionelle, une arborescence d'intentions dites \"secondaires\". Pour reprendre l'exemple de la m\u00e9t\u00e9o, \u00e0 quelqu'un demandant \"Quel temps fait-il ?\", il peut \u00eatre utile de poser la question de l'endroit o\u00f9 il se trouve. Cette question sera prise en compte dans la story \"m\u00e9t\u00e9o\" puisqu'elle n'est qu'une extension de la question initiale. La Story est l'unit\u00e9 principale du framework conversationnel de Tock.","title":"Sc\u00e9nario (ou Story)"},{"location":"utilisateur/concepts/#termes-correspondances","text":"Le tableau ci-dessous propose des correspondances entre les termes utilis\u00e9s dans Tock et ceux d'autres solutions conversationnelles : Tock DialogFlow Alexa Intent Intent Intent Entity Entity Sentence Query Utterance / Slot Story Connector Integration Application Project / Agent Skill La documentation des connecteurs Tock donne \u00e9galement la correspondance avec d'autres termes propres \u00e0 tel ou tel canal.","title":"Termes &amp; correspondances"},{"location":"utilisateur/concepts/#continuer","text":"Vous pouvez maintenant entamer le chapitre suivant : Interfaces Tock Studio .","title":"Continuer..."},{"location":"utilisateur/i18n/","text":"Construire un bot multilingue avec Tock \u00b6 L'interface Tock Studio permet de traduire et moduler les r\u00e9ponses d'un bot en fonction de la langue mais aussi du canal utilis\u00e9s. Pr\u00e9-requis \u00b6 Tock met \u00e0 disposition un framework complet d'internationalisation. Il est activ\u00e9 par d\u00e9faut en mode Bot API (par exemple sur la plateforme de d\u00e9monstration ). Dans le mode Bot int\u00e9gr\u00e9 (voir le manuel d\u00e9veloppeur ), l'internationalisation est d\u00e9sactiv\u00e9e par d\u00e9faut. Pour l'activer, il est alors n\u00e9cessaire de configurer la plateforme \u00e0 son d\u00e9marrage : Soit via le code de d\u00e9marrage du bot (d\u00e9veloppeur) : Translator . enabled = true Soit avec une propri\u00e9t\u00e9 Syst\u00e8me (administrateur) en passant -Dtock_i18n_enabled=true au d\u00e9marrage de la JVM Activer plusieurs langues pour un bot \u00b6 Il est possible d'ajouter et de g\u00e9rer les langues actives pour un bot dans la section NLU Applications (dans Tock Studio ). Voir Le menu Configuration . A tout moment dans Tock Studio , il est possible de changer la langue s\u00e9lectionn\u00e9e dans la banni\u00e8re en haut de page, notamment pour dialoguer avec un bot dans l'interface Test the bot . Voir Interface g\u00e9n\u00e9rale . Langue et locale utilisateur \u00b6 Quand c'est possible, la locale de l'utilisateur (langue / r\u00e9gion) est import\u00e9e de celle de son compte. Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en Fran\u00e7ais, le Fran\u00e7ais sera automatiquement s\u00e9lectionn\u00e9 par Tock. S'il n'y a pas d'indication de locale, c'est la locale par d\u00e9faut de Tock qui est utilis\u00e9e. Un d\u00e9veloppeur peut modifier la locale de l'utilisateur dans le code du bot lui-m\u00eame : userPreferences . locale = Locale . FRENCH Enfin, la locale par d\u00e9faut peut \u00eatre modifi\u00e9e par un administrateur de la plateforme, en passant la propri\u00e9t\u00e9 Syst\u00e8me -Dtock_default_locale=fr au d\u00e9marrage de la JVM. Traduire et faire varier les r\u00e9ponses du bot \u00b6 Dans Tock Studio , la section Build > Responses permet de g\u00e9rer les libell\u00e9s des r\u00e9ponses du bot. Voir Le menu Build . Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot. Il est possible de concevoir et configurer diff\u00e9rentes variantes : En fonction de la langue En fonction du canal / connecteur Par exemple, certains canaux requi\u00e8rent des libell\u00e9s sp\u00e9cifiques, soit parce que le propri\u00e9taire du canal l'exige (sur Alexa le vouvoiement est requis), soit parce que l'exp\u00e9rience utilisateur diff\u00e8re des autres canaux (par exemple en vocal on \u00e9vitera de trop longues phrases). Al\u00e9atoirement (pour que le bot ne r\u00e9ponde pas toujours la m\u00eame chose) Traduire massivement les mod\u00e8les et r\u00e9ponses \u00b6 Des fonctionnalit\u00e9s sont \u00e0 l'\u00e9tude pour permettre la traduction plus ou moins automatis\u00e9e de nombreuses phrases utilisateur (corpus / mod\u00e8le conversationnel) et r\u00e9ponses (libell\u00e9s / i18n). A suivre... Pour le moment, pour envisager une traduction de masse, on peut par exemple : Exporter les donn\u00e9es en JSON ou CSV avec Tock Studio Traduire les phrases/r\u00e9ponses en dehors de Tock (API SaaS, agence...) Importer les traductions avec Tock Studio Remarque : au moment de l'import seuls les libell\u00e9s marqu\u00e9s valid\u00e9s sont pris en compte. D\u00e9velopper avec l'internationalisation \u00b6 Le manuel d\u00e9veloppeur Tock donne plus de d\u00e9tails sur le d\u00e9veloppement des bots multilingues.","title":"Bot multilingue"},{"location":"utilisateur/i18n/#construire-un-bot-multilingue-avec-tock","text":"L'interface Tock Studio permet de traduire et moduler les r\u00e9ponses d'un bot en fonction de la langue mais aussi du canal utilis\u00e9s.","title":"Construire un bot multilingue avec Tock"},{"location":"utilisateur/i18n/#pre-requis","text":"Tock met \u00e0 disposition un framework complet d'internationalisation. Il est activ\u00e9 par d\u00e9faut en mode Bot API (par exemple sur la plateforme de d\u00e9monstration ). Dans le mode Bot int\u00e9gr\u00e9 (voir le manuel d\u00e9veloppeur ), l'internationalisation est d\u00e9sactiv\u00e9e par d\u00e9faut. Pour l'activer, il est alors n\u00e9cessaire de configurer la plateforme \u00e0 son d\u00e9marrage : Soit via le code de d\u00e9marrage du bot (d\u00e9veloppeur) : Translator . enabled = true Soit avec une propri\u00e9t\u00e9 Syst\u00e8me (administrateur) en passant -Dtock_i18n_enabled=true au d\u00e9marrage de la JVM","title":"Pr\u00e9-requis"},{"location":"utilisateur/i18n/#activer-plusieurs-langues-pour-un-bot","text":"Il est possible d'ajouter et de g\u00e9rer les langues actives pour un bot dans la section NLU Applications (dans Tock Studio ). Voir Le menu Configuration . A tout moment dans Tock Studio , il est possible de changer la langue s\u00e9lectionn\u00e9e dans la banni\u00e8re en haut de page, notamment pour dialoguer avec un bot dans l'interface Test the bot . Voir Interface g\u00e9n\u00e9rale .","title":"Activer plusieurs langues pour un bot"},{"location":"utilisateur/i18n/#langue-et-locale-utilisateur","text":"Quand c'est possible, la locale de l'utilisateur (langue / r\u00e9gion) est import\u00e9e de celle de son compte. Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en Fran\u00e7ais, le Fran\u00e7ais sera automatiquement s\u00e9lectionn\u00e9 par Tock. S'il n'y a pas d'indication de locale, c'est la locale par d\u00e9faut de Tock qui est utilis\u00e9e. Un d\u00e9veloppeur peut modifier la locale de l'utilisateur dans le code du bot lui-m\u00eame : userPreferences . locale = Locale . FRENCH Enfin, la locale par d\u00e9faut peut \u00eatre modifi\u00e9e par un administrateur de la plateforme, en passant la propri\u00e9t\u00e9 Syst\u00e8me -Dtock_default_locale=fr au d\u00e9marrage de la JVM.","title":"Langue et locale utilisateur"},{"location":"utilisateur/i18n/#traduire-et-faire-varier-les-reponses-du-bot","text":"Dans Tock Studio , la section Build > Responses permet de g\u00e9rer les libell\u00e9s des r\u00e9ponses du bot. Voir Le menu Build . Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot. Il est possible de concevoir et configurer diff\u00e9rentes variantes : En fonction de la langue En fonction du canal / connecteur Par exemple, certains canaux requi\u00e8rent des libell\u00e9s sp\u00e9cifiques, soit parce que le propri\u00e9taire du canal l'exige (sur Alexa le vouvoiement est requis), soit parce que l'exp\u00e9rience utilisateur diff\u00e8re des autres canaux (par exemple en vocal on \u00e9vitera de trop longues phrases). Al\u00e9atoirement (pour que le bot ne r\u00e9ponde pas toujours la m\u00eame chose)","title":"Traduire et faire varier les r\u00e9ponses du bot"},{"location":"utilisateur/i18n/#traduire-massivement-les-modeles-et-reponses","text":"Des fonctionnalit\u00e9s sont \u00e0 l'\u00e9tude pour permettre la traduction plus ou moins automatis\u00e9e de nombreuses phrases utilisateur (corpus / mod\u00e8le conversationnel) et r\u00e9ponses (libell\u00e9s / i18n). A suivre... Pour le moment, pour envisager une traduction de masse, on peut par exemple : Exporter les donn\u00e9es en JSON ou CSV avec Tock Studio Traduire les phrases/r\u00e9ponses en dehors de Tock (API SaaS, agence...) Importer les traductions avec Tock Studio Remarque : au moment de l'import seuls les libell\u00e9s marqu\u00e9s valid\u00e9s sont pris en compte.","title":"Traduire massivement les mod\u00e8les et r\u00e9ponses"},{"location":"utilisateur/i18n/#developper-avec-linternationalisation","text":"Le manuel d\u00e9veloppeur Tock donne plus de d\u00e9tails sur le d\u00e9veloppement des bots multilingues.","title":"D\u00e9velopper avec l'internationalisation"},{"location":"utilisateur/studio/","text":"Les interfaces Tock Studio \u00b6 Tock Studio regroupe l'ensemble des interfaces utilisateur, techniques et m\u00e9tier, permettant de concevoir les mod\u00e8les conversationnels, cr\u00e9er des parcours et des r\u00e9ponses, suivre les conversations, analyser les tendances, etc. Dans cette section, vous trouverez la description de chaque vue mais aussi des pages d\u00e9di\u00e9es \u00e0 des th\u00e8mes ou des fonctionnalit\u00e9s particuli\u00e8res : Les interfaces de Tock Studio : Interface g\u00e9n\u00e9rale Le menu Configuration Le menu NLU Le menu NLU QA Le menu Build Le menu Test Le menu Monitoring Voir aussi : Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation) Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Tock Studio"},{"location":"utilisateur/studio/#les-interfaces-tock-studio","text":"Tock Studio regroupe l'ensemble des interfaces utilisateur, techniques et m\u00e9tier, permettant de concevoir les mod\u00e8les conversationnels, cr\u00e9er des parcours et des r\u00e9ponses, suivre les conversations, analyser les tendances, etc. Dans cette section, vous trouverez la description de chaque vue mais aussi des pages d\u00e9di\u00e9es \u00e0 des th\u00e8mes ou des fonctionnalit\u00e9s particuli\u00e8res : Les interfaces de Tock Studio : Interface g\u00e9n\u00e9rale Le menu Configuration Le menu NLU Le menu NLU QA Le menu Build Le menu Test Le menu Monitoring Voir aussi : Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation) Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Les interfaces Tock Studio"},{"location":"utilisateur/studio/build-model/","text":"Construire les mod\u00e8les conversationnels \u00b6 La documentation Tock Studio peut \u00eatre parcourue \u00e9cran par \u00e9cran, notamment les menus NLU et NLU QA pour la gestion des mod\u00e8les conversationnels. N'h\u00e9sitez pas \u00e0 vous y r\u00e9f\u00e9rer si vous avez une question sur un onglet / une option en particulier. Cette page pr\u00e9sente la construction des mod\u00e8les en se focalisant plus sur l'usage et l'apprentissage, s'autorisant \u00e0 passer d'un \u00e9cran \u00e0 un autre sans d\u00e9tailler exhaustivement chaque fonctionnalit\u00e9 de la plateforme. Notez qu'il est possible de d\u00e9ployer la plateforme Tock NLU seule, dans ce cas les interfaces graphiques Tock se limitent aux menus Configuration , NLU et NLU QA . Cette page peut donc servir de tutoriel pour une utilisation de Tock restreinte au NLU , par exemple pour un usage comme l' Internet des objets . Rendez-vous dans la section NLU \u00b6 Le menu NLU renvoie sur l'onglet Inbox par d\u00e9faut. Au d\u00e9part vous n'avez pas de phrases si personne n'a encore parl\u00e9 au bot : Ajoutez et qualifiez des phrases \u00b6 Ajoutez une phrase \u00b6 Rendez-vous dans l'\u00e9cran Try it Saisissez une phrase Cr\u00e9ez une nouvelle intention \u00b6 Attribuez \u00e0 la phrase une nouvelle intention en s\u00e9lectionnant Create a New Intent dans la liste de s\u00e9lection Intent . Sp\u00e9cifiez des entit\u00e9s \u00b6 Selon ce \u00e0 quoi est destin\u00e9e l'intention, vous pouvez sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse dans la phrase : S\u00e9lectionnez une portion de phrase correspondant \u00e0 l'entit\u00e9 (ie. un groupe de mots \u00e0 s\u00e9lectionner avec la souris) Cliquez sur Add New Entity qui vient d'appara\u00eetre Choisissez un type d'entit\u00e9 existant ou cr\u00e9ez-en un nouveau Donnez un r\u00f4le \u00e0 cette entit\u00e9 Exemple : dans la phrase \"je veux aller de Paris \u00e0 New York\", probablement que Paris et New York sont deux entit\u00e9s du m\u00eame type (localit\u00e9) mais n'ont pas le m\u00eame r\u00f4le dans l'intention (origine et destination). Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase. Tirez parti des entit\u00e9s pr\u00e9d\u00e9finies \u00b6 Par d\u00e9faut, Tock propose un certain nombre de types d' entit\u00e9s pr\u00e9d\u00e9finies , notamment les types support\u00e9s par la biblioth\u00e8que Duckling : montants, dates, etc. Si vous s\u00e9lectionnez ces types d'entit\u00e9s, celles-ci seront automatiquement reconnues et valoris\u00e9es. Validez la phrase \u00b6 Lorsque l'intention et les entit\u00e9s sont correctes, terminez la qualification de la phrase en cliquant sur Validate . Qualifiez d'autres phrases \u00b6 Apr\u00e8s deux ou trois phrases pour une intention donn\u00e9e, il est courant que le mod\u00e8le commence \u00e0 reconna\u00eetre les phrases suivantes et d\u00e9tectent bien l'intention (avec un score grandissant, du moment que les phrases sont relativement proches / en rapport avec l'intention bien s\u00fbr) : Si une phrase n'est pas bien qualifi\u00e9e, changez l'intention / les entit\u00e9s puis faites Validate pour appliquer la correction. Si la phrase \u00e9tait bien qualifi\u00e9e, faites directement Validate . Dans les deux cas, vous alimentez ainsi le mod\u00e8le, qui se reconstruit, et devient plus pertinent pour les pharses suivantes. Vous \u00eates en train de construire votre mod\u00e8le conversationnel ! C'est le d\u00e9but de l' apprentissage pour votre bot ou votre application conversationnelle. La qualification de phrases, leur nombre mais aussi leur vari\u00e9t\u00e9 (notamment dans le temps, car les utilisateurs d'aujourd'hui ne sont pas exactement les utilisateurs de demain) sont la base d'un mod\u00e8le pertinent et d'une bonne exp\u00e9rience conversationnelle pour les utilisateurs. Parcourez les phrases du mod\u00e8le \u00b6 L'onglet Search permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res. Le plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res. Chaque phrase \u00e0 un \u00e9tat Status qui peut \u00e9voluer au cours du temps : Inbox : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le Validated : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante) Included in model : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP Cet \u00e9cran permet donc de consulter les phrases faisant d\u00e9j\u00e0 partie du mod\u00e8le (autrement dit d\u00e9j\u00e0 qualifi\u00e9s), et de faire \u00e9voluer les qualifications de phrases au cours du temps. Il est notamment possible de re-qualifier tout un groupe de phrases. Par exemple, vous pourrez cr\u00e9er une nouvelle intention plus tard et d\u00e9cider que toutes les phrases remplissant un certain crit\u00e8re (mot-clef ou autre) devront dor\u00e9navant \u00eatre qualifi\u00e9es dans cette nouvelle intention. Modifiez les caract\u00e9ristiques avanc\u00e9es de l'application \u00b6 Le menu Applications donne acc\u00e8s \u00e0 la liste des applications/bots disponibles sur la plateforme : Avec le bouton de modification, plusieurs options sont disponibles, en particulier : La s\u00e9lection du moteur NLU \u00b6 Vous avez la possibilit\u00e9 de s\u00e9lectionner la biblioth\u00e8que NLU utilis\u00e9e par ce bot (\u00e0 condition que plusieurs moteurs soient pr\u00e9sents dans l'installation de la plateforme). L'activation des mod\u00e8les d'entit\u00e9s \u00b6 Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. Par exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 duckling:datetime , les dates seront automatiquement reconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention. En interne, un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le. Cette option est activ\u00e9e par d\u00e9faut. Il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels la d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s. L'activation des sous-entit\u00e9s \u00b6 Si vous activez cette option, vous pourrez qualifier plusieurs niveaux d'entit\u00e9s : Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4. Valeurs pr\u00e9definies d'entit\u00e9s \u00b6 Une entit\u00e9 donn\u00e9e peut avoir des valeurs pr\u00e9d\u00e9finies . Pour cela vous devez aller dans l'onglet Entities , selectionnez une entit\u00e9. L'ic\u00f4ne \u00e0 cot\u00e9 de l'ic\u00f4ne de suppression montre les types d'entit\u00e9s que vous pouvez modifier : Dans l'exemple ci-dessus, deux labels sont d\u00e9finis pour la valeur de semaine : Semaine hebdomadaire Continuer... \u00b6 Pour en savoir plus sur la gestion des entit\u00e9s, notamment dans des intentions cr\u00e9\u00e9es programmatiquement, out tout simplement pour continuer de parcourir le manuel utilisateur Tock, vous pouvez vous rendre dans le chapitre D\u00e9veloppement .","title":"Construire les mod\u00e8les conversationnels"},{"location":"utilisateur/studio/build-model/#construire-les-modeles-conversationnels","text":"La documentation Tock Studio peut \u00eatre parcourue \u00e9cran par \u00e9cran, notamment les menus NLU et NLU QA pour la gestion des mod\u00e8les conversationnels. N'h\u00e9sitez pas \u00e0 vous y r\u00e9f\u00e9rer si vous avez une question sur un onglet / une option en particulier. Cette page pr\u00e9sente la construction des mod\u00e8les en se focalisant plus sur l'usage et l'apprentissage, s'autorisant \u00e0 passer d'un \u00e9cran \u00e0 un autre sans d\u00e9tailler exhaustivement chaque fonctionnalit\u00e9 de la plateforme. Notez qu'il est possible de d\u00e9ployer la plateforme Tock NLU seule, dans ce cas les interfaces graphiques Tock se limitent aux menus Configuration , NLU et NLU QA . Cette page peut donc servir de tutoriel pour une utilisation de Tock restreinte au NLU , par exemple pour un usage comme l' Internet des objets .","title":"Construire les mod\u00e8les conversationnels"},{"location":"utilisateur/studio/build-model/#rendez-vous-dans-la-section-nlu","text":"Le menu NLU renvoie sur l'onglet Inbox par d\u00e9faut. Au d\u00e9part vous n'avez pas de phrases si personne n'a encore parl\u00e9 au bot :","title":"Rendez-vous dans la section NLU"},{"location":"utilisateur/studio/build-model/#ajoutez-et-qualifiez-des-phrases","text":"","title":"Ajoutez et qualifiez des phrases"},{"location":"utilisateur/studio/build-model/#ajoutez-une-phrase","text":"Rendez-vous dans l'\u00e9cran Try it Saisissez une phrase","title":"Ajoutez une phrase"},{"location":"utilisateur/studio/build-model/#creez-une-nouvelle-intention","text":"Attribuez \u00e0 la phrase une nouvelle intention en s\u00e9lectionnant Create a New Intent dans la liste de s\u00e9lection Intent .","title":"Cr\u00e9ez une nouvelle intention"},{"location":"utilisateur/studio/build-model/#specifiez-des-entites","text":"Selon ce \u00e0 quoi est destin\u00e9e l'intention, vous pouvez sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse dans la phrase : S\u00e9lectionnez une portion de phrase correspondant \u00e0 l'entit\u00e9 (ie. un groupe de mots \u00e0 s\u00e9lectionner avec la souris) Cliquez sur Add New Entity qui vient d'appara\u00eetre Choisissez un type d'entit\u00e9 existant ou cr\u00e9ez-en un nouveau Donnez un r\u00f4le \u00e0 cette entit\u00e9 Exemple : dans la phrase \"je veux aller de Paris \u00e0 New York\", probablement que Paris et New York sont deux entit\u00e9s du m\u00eame type (localit\u00e9) mais n'ont pas le m\u00eame r\u00f4le dans l'intention (origine et destination). Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase.","title":"Sp\u00e9cifiez des entit\u00e9s"},{"location":"utilisateur/studio/build-model/#tirez-parti-des-entites-predefinies","text":"Par d\u00e9faut, Tock propose un certain nombre de types d' entit\u00e9s pr\u00e9d\u00e9finies , notamment les types support\u00e9s par la biblioth\u00e8que Duckling : montants, dates, etc. Si vous s\u00e9lectionnez ces types d'entit\u00e9s, celles-ci seront automatiquement reconnues et valoris\u00e9es.","title":"Tirez parti des entit\u00e9s pr\u00e9d\u00e9finies"},{"location":"utilisateur/studio/build-model/#validez-la-phrase","text":"Lorsque l'intention et les entit\u00e9s sont correctes, terminez la qualification de la phrase en cliquant sur Validate .","title":"Validez la phrase"},{"location":"utilisateur/studio/build-model/#qualifiez-dautres-phrases","text":"Apr\u00e8s deux ou trois phrases pour une intention donn\u00e9e, il est courant que le mod\u00e8le commence \u00e0 reconna\u00eetre les phrases suivantes et d\u00e9tectent bien l'intention (avec un score grandissant, du moment que les phrases sont relativement proches / en rapport avec l'intention bien s\u00fbr) : Si une phrase n'est pas bien qualifi\u00e9e, changez l'intention / les entit\u00e9s puis faites Validate pour appliquer la correction. Si la phrase \u00e9tait bien qualifi\u00e9e, faites directement Validate . Dans les deux cas, vous alimentez ainsi le mod\u00e8le, qui se reconstruit, et devient plus pertinent pour les pharses suivantes. Vous \u00eates en train de construire votre mod\u00e8le conversationnel ! C'est le d\u00e9but de l' apprentissage pour votre bot ou votre application conversationnelle. La qualification de phrases, leur nombre mais aussi leur vari\u00e9t\u00e9 (notamment dans le temps, car les utilisateurs d'aujourd'hui ne sont pas exactement les utilisateurs de demain) sont la base d'un mod\u00e8le pertinent et d'une bonne exp\u00e9rience conversationnelle pour les utilisateurs.","title":"Qualifiez d'autres phrases"},{"location":"utilisateur/studio/build-model/#parcourez-les-phrases-du-modele","text":"L'onglet Search permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res. Le plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res. Chaque phrase \u00e0 un \u00e9tat Status qui peut \u00e9voluer au cours du temps : Inbox : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le Validated : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante) Included in model : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP Cet \u00e9cran permet donc de consulter les phrases faisant d\u00e9j\u00e0 partie du mod\u00e8le (autrement dit d\u00e9j\u00e0 qualifi\u00e9s), et de faire \u00e9voluer les qualifications de phrases au cours du temps. Il est notamment possible de re-qualifier tout un groupe de phrases. Par exemple, vous pourrez cr\u00e9er une nouvelle intention plus tard et d\u00e9cider que toutes les phrases remplissant un certain crit\u00e8re (mot-clef ou autre) devront dor\u00e9navant \u00eatre qualifi\u00e9es dans cette nouvelle intention.","title":"Parcourez les phrases du mod\u00e8le"},{"location":"utilisateur/studio/build-model/#modifiez-les-caracteristiques-avancees-de-lapplication","text":"Le menu Applications donne acc\u00e8s \u00e0 la liste des applications/bots disponibles sur la plateforme : Avec le bouton de modification, plusieurs options sont disponibles, en particulier :","title":"Modifiez les caract\u00e9ristiques avanc\u00e9es de l'application"},{"location":"utilisateur/studio/build-model/#la-selection-du-moteur-nlu","text":"Vous avez la possibilit\u00e9 de s\u00e9lectionner la biblioth\u00e8que NLU utilis\u00e9e par ce bot (\u00e0 condition que plusieurs moteurs soient pr\u00e9sents dans l'installation de la plateforme).","title":"La s\u00e9lection du moteur NLU"},{"location":"utilisateur/studio/build-model/#lactivation-des-modeles-dentites","text":"Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. Par exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 duckling:datetime , les dates seront automatiquement reconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention. En interne, un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le. Cette option est activ\u00e9e par d\u00e9faut. Il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels la d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s.","title":"L'activation des mod\u00e8les d'entit\u00e9s"},{"location":"utilisateur/studio/build-model/#lactivation-des-sous-entites","text":"Si vous activez cette option, vous pourrez qualifier plusieurs niveaux d'entit\u00e9s : Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4.","title":"L'activation des sous-entit\u00e9s"},{"location":"utilisateur/studio/build-model/#valeurs-predefinies-dentites","text":"Une entit\u00e9 donn\u00e9e peut avoir des valeurs pr\u00e9d\u00e9finies . Pour cela vous devez aller dans l'onglet Entities , selectionnez une entit\u00e9. L'ic\u00f4ne \u00e0 cot\u00e9 de l'ic\u00f4ne de suppression montre les types d'entit\u00e9s que vous pouvez modifier : Dans l'exemple ci-dessus, deux labels sont d\u00e9finis pour la valeur de semaine : Semaine hebdomadaire","title":"Valeurs pr\u00e9definies d'entit\u00e9s"},{"location":"utilisateur/studio/build-model/#continuer","text":"Pour en savoir plus sur la gestion des entit\u00e9s, notamment dans des intentions cr\u00e9\u00e9es programmatiquement, out tout simplement pour continuer de parcourir le manuel utilisateur Tock, vous pouvez vous rendre dans le chapitre D\u00e9veloppement .","title":"Continuer..."},{"location":"utilisateur/studio/build/","text":"Le menu Build \u00b6 Le menu Build permet de construire des parcours et des r\u00e9ponses aux phrases utilisateur. Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Cr\u00e9er son premier bot avec Tock Studio pour un exemple de cr\u00e9ation de parcours ou Construire un bot multilingue pour l'utilisation de l'onglet Responses . L'onglet New Story \u00b6 Cr\u00e9er une r\u00e9ponse simple \u00b6 Le guide Cr\u00e9er son premier bot avec Tock Studio pr\u00e9sente un exemple de cr\u00e9ation de parcours avec une r\u00e9ponse simple via New Story . L'onglet Test > Test the bot permet ensuite de rapidement v\u00e9rifier le comportement du bot sur ce parcours. Cr\u00e9er des r\u00e9ponses complexes \u00b6 Il est possible d'indiquer plusieurs r\u00e9ponses et \u00e9galement des r\u00e9ponses \"riches\" appel\u00e9es Media Message . Cela permet, quel que soit le canal d'afficher des images, des titres, des sous-titres et des boutons d'action. Entit\u00e9s obligatoires \u00b6 Il est possible, avant d'afficher la r\u00e9ponse principale, de v\u00e9rifier si certaines entit\u00e9es sont renseign\u00e9es, et si ce n'est pas le cas, d'afficher la question ad\u00e9quate. L'option correspondante est appell\u00e9e Mandatory Entities . Par exemple, supposons que nous ayons besoin de conna\u00eetre la destination de l'utilisateur. Si il ne l'a pas d\u00e9j\u00e0 indiqu\u00e9e, le bot devrait lui demander \"Pour quelle destination ?\". Actions \u00b6 Les actions sont pr\u00e9sent\u00e9es comme des suggestions, quand le canal le permet. Il est possible de pr\u00e9senter une arborescence d'actions pour construire un arbre de d\u00e9cision. L'onglet Search Stories \u00b6 Cette \u00e9cran permet de parcourir et g\u00e9rer les parcours ou stories cr\u00e9\u00e9es. Il peut s'agir des parcours configur\u00e9s via Tock Studio (ie. avec l'onglet New Story ) mais aussi les parcours d\u00e9clar\u00e9s programmatiquement via Bot API . Pour voir ces derniers, d\u00e9cochez l'option Only Configured Stories . L'onglet Story Rules \u00b6 Cet section permet de g\u00e9rer des fonctions activables ou d\u00e9sactivables via l'interface (ou Feature Flipping ). L'onglet Bot Flow \u00b6 Cet \u00e9cran permet d'analyser le flot des intentions et des conversations : Flot des intentions : analyse statique des parcours et arbres de d\u00e9cisions propos\u00e9s par le bot Flot des conversations (en activant le bouton Stats ) : analyse dynamique des parcours r\u00e9ellement effectu\u00e9s par les utilisateurs En d\u00e9veloppant l'interface (fl\u00eache \u00e0 droite du cadre), de nombreux filtres apparaissent : focalisation sur une intention, transitions entrantes/sortantes, toutes les transitions ou seulement les plus repr\u00e9sentatives en terme de trafic, etc. Il est aussi possible de manipuler la repr\u00e9sentation graphique directement dans l'interface, afin de la rendre plus lisible, regrouper des intentions, zoomer/d\u00e9zoomer, etc. L'onglet Responses \u00b6 Cet onglet permet de modifier les r\u00e9ponses du bot, dynamiquement selon plusieurs crit\u00e8res possibles : La langue (c'est ce qu'on appelle internationalisation ou i18n ) Le canal (textuel ou vocal), c'est-\u00e0-dire en pratique le connecteur Selon un roulement : il est possible d'enregistrer plusieurs textes de r\u00e9ponse pour un m\u00eame label dans une m\u00eame langue sur un m\u00eame connecteur - le bot r\u00e9pondra alors al\u00e9atoirement l'un de ces textes, puis effectuera un roulement afin de ne pas toujours r\u00e9pondre la m\u00eame chose. Cela permet de rendre le bot plus agr\u00e9able en variant ses r\u00e9ponses. Voir aussi Construire un bot multilingue pour l'utilisation de l'onglet Responses mais aussi les aspects d\u00e9veloppement sur ce th\u00e8me. Continuer... \u00b6 Rendez-vous dans Menu Test pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _Build_"},{"location":"utilisateur/studio/build/#le-menu-build","text":"Le menu Build permet de construire des parcours et des r\u00e9ponses aux phrases utilisateur. Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Cr\u00e9er son premier bot avec Tock Studio pour un exemple de cr\u00e9ation de parcours ou Construire un bot multilingue pour l'utilisation de l'onglet Responses .","title":"Le menu Build"},{"location":"utilisateur/studio/build/#longlet-new-story","text":"","title":"L'onglet New Story"},{"location":"utilisateur/studio/build/#creer-une-reponse-simple","text":"Le guide Cr\u00e9er son premier bot avec Tock Studio pr\u00e9sente un exemple de cr\u00e9ation de parcours avec une r\u00e9ponse simple via New Story . L'onglet Test > Test the bot permet ensuite de rapidement v\u00e9rifier le comportement du bot sur ce parcours.","title":"Cr\u00e9er une r\u00e9ponse simple"},{"location":"utilisateur/studio/build/#creer-des-reponses-complexes","text":"Il est possible d'indiquer plusieurs r\u00e9ponses et \u00e9galement des r\u00e9ponses \"riches\" appel\u00e9es Media Message . Cela permet, quel que soit le canal d'afficher des images, des titres, des sous-titres et des boutons d'action.","title":"Cr\u00e9er des r\u00e9ponses complexes"},{"location":"utilisateur/studio/build/#entites-obligatoires","text":"Il est possible, avant d'afficher la r\u00e9ponse principale, de v\u00e9rifier si certaines entit\u00e9es sont renseign\u00e9es, et si ce n'est pas le cas, d'afficher la question ad\u00e9quate. L'option correspondante est appell\u00e9e Mandatory Entities . Par exemple, supposons que nous ayons besoin de conna\u00eetre la destination de l'utilisateur. Si il ne l'a pas d\u00e9j\u00e0 indiqu\u00e9e, le bot devrait lui demander \"Pour quelle destination ?\".","title":"Entit\u00e9s obligatoires"},{"location":"utilisateur/studio/build/#actions","text":"Les actions sont pr\u00e9sent\u00e9es comme des suggestions, quand le canal le permet. Il est possible de pr\u00e9senter une arborescence d'actions pour construire un arbre de d\u00e9cision.","title":"Actions"},{"location":"utilisateur/studio/build/#longlet-search-stories","text":"Cette \u00e9cran permet de parcourir et g\u00e9rer les parcours ou stories cr\u00e9\u00e9es. Il peut s'agir des parcours configur\u00e9s via Tock Studio (ie. avec l'onglet New Story ) mais aussi les parcours d\u00e9clar\u00e9s programmatiquement via Bot API . Pour voir ces derniers, d\u00e9cochez l'option Only Configured Stories .","title":"L'onglet Search Stories"},{"location":"utilisateur/studio/build/#longlet-story-rules","text":"Cet section permet de g\u00e9rer des fonctions activables ou d\u00e9sactivables via l'interface (ou Feature Flipping ).","title":"L'onglet Story Rules"},{"location":"utilisateur/studio/build/#longlet-bot-flow","text":"Cet \u00e9cran permet d'analyser le flot des intentions et des conversations : Flot des intentions : analyse statique des parcours et arbres de d\u00e9cisions propos\u00e9s par le bot Flot des conversations (en activant le bouton Stats ) : analyse dynamique des parcours r\u00e9ellement effectu\u00e9s par les utilisateurs En d\u00e9veloppant l'interface (fl\u00eache \u00e0 droite du cadre), de nombreux filtres apparaissent : focalisation sur une intention, transitions entrantes/sortantes, toutes les transitions ou seulement les plus repr\u00e9sentatives en terme de trafic, etc. Il est aussi possible de manipuler la repr\u00e9sentation graphique directement dans l'interface, afin de la rendre plus lisible, regrouper des intentions, zoomer/d\u00e9zoomer, etc.","title":"L'onglet Bot Flow"},{"location":"utilisateur/studio/build/#longlet-responses","text":"Cet onglet permet de modifier les r\u00e9ponses du bot, dynamiquement selon plusieurs crit\u00e8res possibles : La langue (c'est ce qu'on appelle internationalisation ou i18n ) Le canal (textuel ou vocal), c'est-\u00e0-dire en pratique le connecteur Selon un roulement : il est possible d'enregistrer plusieurs textes de r\u00e9ponse pour un m\u00eame label dans une m\u00eame langue sur un m\u00eame connecteur - le bot r\u00e9pondra alors al\u00e9atoirement l'un de ces textes, puis effectuera un roulement afin de ne pas toujours r\u00e9pondre la m\u00eame chose. Cela permet de rendre le bot plus agr\u00e9able en variant ses r\u00e9ponses. Voir aussi Construire un bot multilingue pour l'utilisation de l'onglet Responses mais aussi les aspects d\u00e9veloppement sur ce th\u00e8me.","title":"L'onglet Responses"},{"location":"utilisateur/studio/build/#continuer","text":"Rendez-vous dans Menu Test pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"utilisateur/studio/configuration/","text":"Le menu Configuration \u00b6 Le menu Configuration permet de cr\u00e9er et param\u00e9trer les applications conversationnelles Tock (c'est-\u00e0-dire les mod\u00e8les / bots pouvant co-exister sur une plateforme). Plusieurs fonctions d'administration et de configuration des bots sont \u00e9galement disponibles via ce menu : importer/exporter une configuration, param\u00e9trer la langue, les connecteurs, etc. L'onglet NLU Applications \u00b6 Cet \u00e9cran permet de cr\u00e9er, modifier, supprimer des applications conversationnelles Tock. Lors de la premi\u00e8re connexion \u00e0 la plateforme de d\u00e9monstration , un assistant simplifi\u00e9 permet de cr\u00e9er la premi\u00e8re application (le premier bot). Par la suite, vous pouvez passer par cet \u00e9cran pour ajouter d'autres applications. Cr\u00e9er une application \u00b6 Pour ajouter une application, cliquez sur Create New Application : Saisissez un nom / identifiant pour l'application Choisissez si le mod\u00e8le pourra inclure des entit\u00e9s voire des sous-entit\u00e9s (cf Concepts pour en savoir plus) S\u00e9lectionnez une ou plusieurs langues (voir Construire un bot multilingue pour en savoir plus) S\u00e9lectionnez un moteur NLU ( Apache OpenNLP ou Stanford CoreNLP , voir Installation pour en savoir plus) Modifier, importer et exporter une application \u00b6 Pour chaque application d\u00e9j\u00e0 cr\u00e9\u00e9e, vous pouvez par la suite : Download an application dump : t\u00e9l\u00e9charger sa configuration au format JSON : langue, mod\u00e8le intentions/entit\u00e9s, etc. Download a sentences dump : t\u00e9l\u00e9charger ses phrases qualifi\u00e9es au format JSON Edit : modifier la configuration de l'application Un formulaire permet de modifier la configuraion initiale Une section Advanced options ajoute d'autres param\u00e8tres pour les utilisateurs avertis : Upload dump : charger une configuration ou des phrases qualifi\u00e9es \u00e0 partir d'un fichier au format JSON. Seules les nouvelles intentions/phrases seront ajout\u00e9es, cette fonction ne modifie pas / ne supprime pas les intentions/phrases existantes Trigger build : d\u00e9clencher/forcer la reconstruction du mod\u00e8le NLU Engine configuration : param\u00e9trer finement le moteur NLU sous-jacent (les param\u00e8tres d\u00e9pendant du moteur utilis\u00e9, Apache OpenNLP ou Stanford CoreNLP ) Alexa Export : exporter le mod\u00e8le Tock dans un format utilisable par Alexa La fonction Upload dump (voir ci-dessus) est \u00e9galement accessible directement en bas d'\u00e9cran, permettant : Soit de modifier une application (si l' application name existe) Soit d'en cr\u00e9er/importer une nouvelle L'onglet Bot Configurations \u00b6 Cet \u00e9cran permet d'acc\u00e9der aux connecteurs d'un bot, d'en ajouter, modifier ou supprimer. C'est aussi l\u00e0 que vous trouvez les informations pour se connecter programmatiquement. Se connecter programmatiquement au bot \u00b6 Le param\u00e9trage pour se connecter au bot programmatiquement (ie. via un programme / langage de programmation) se trouve dans cet \u00e9cran : L' API Key peut \u00eatre copi\u00e9e et embarqu\u00e9e dans le code client de la Bot API pour connecter des parcours programm\u00e9s en Kotlin ou dans un autre langage de programmation Une adresse / URL peut \u00eatre configur\u00e9e pour utiliser le mode WebHook de Bot API Pour en savoir plus sur ces param\u00e8tres et le d\u00e9veloppement de parcours, voir Bot API . G\u00e9rer les connecteurs \u00b6 La liste des connecteurs du bot est affich\u00e9e sous la clef d'API. Pour ajouter un connecteur au bot, cliquez sur Create a new Configuration . Tous les connecteurs poss\u00e8dent la configuration suivante : Configuration name : le nom/identifiant du bot Connector type : le type de canal (par exemple Messenger, Slack, etc.) Connector identifier : un identifiant pour le connecteur, unique pour le bot Relative REST path : un chemin relatif unique pour la plateforme, pour communiquer avec le bot sur ce canal. Par d\u00e9faut, le chemin est de la forme /io/{organisation}/{application}/{canal} ce qui le rend unique sur la plateforme (\u00e0 moins que deux connecteurs du m\u00eame type soient d\u00e9clar\u00e9s pour le m\u00eame bot). Chaque connecteur poss\u00e8de \u00e9galement une configuration suppl\u00e9mentaire sp\u00e9cifique \u00e0 ce type de connecteur. Ces param\u00e8tres sont dans Connector Custom Configuration . Ces param\u00e8tres sp\u00e9cifiques sont document\u00e9s avec chaque type de connecteur/canal, voir Les connecteurs . Connecteurs de test \u00b6 Pour chaque connecteur ajout\u00e9 au bot, un connecteur de test est aussi cr\u00e9\u00e9 et configur\u00e9. Il sert \u00e0 \"simuler\" le connecteur lorsqu'on teste le bot directement dans l'interface Tock Studio (menu Test > Test the bot ). Par d\u00e9faut, les connecteurs de test ne sont pas affich\u00e9s dans l'\u00e9cran Bot Configurations . Cliquez sur Display test configurations pour les voir et \u00e9ventuellement les modifier. En particulier, si vous obtenez des messages d'erreur de connexion dans la page Test the bot , n'h\u00e9sitez pas \u00e0 v\u00e9rfier la configuration de test notamment l'adresse Application base url (pour une plateforme d\u00e9ploy\u00e9e avec Docker Compose par d\u00e9faut, ce devrait \u00eatre http://bot_api:8080 avec le nom du conteneur et le port d\u00e9clar\u00e9s dans le descripteur docker-compose-bot.yml ). Continuer... \u00b6 Rendez-vous dans Menu NLU pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _Configuration_"},{"location":"utilisateur/studio/configuration/#le-menu-configuration","text":"Le menu Configuration permet de cr\u00e9er et param\u00e9trer les applications conversationnelles Tock (c'est-\u00e0-dire les mod\u00e8les / bots pouvant co-exister sur une plateforme). Plusieurs fonctions d'administration et de configuration des bots sont \u00e9galement disponibles via ce menu : importer/exporter une configuration, param\u00e9trer la langue, les connecteurs, etc.","title":"Le menu Configuration"},{"location":"utilisateur/studio/configuration/#longlet-nlu-applications","text":"Cet \u00e9cran permet de cr\u00e9er, modifier, supprimer des applications conversationnelles Tock. Lors de la premi\u00e8re connexion \u00e0 la plateforme de d\u00e9monstration , un assistant simplifi\u00e9 permet de cr\u00e9er la premi\u00e8re application (le premier bot). Par la suite, vous pouvez passer par cet \u00e9cran pour ajouter d'autres applications.","title":"L'onglet NLU Applications"},{"location":"utilisateur/studio/configuration/#creer-une-application","text":"Pour ajouter une application, cliquez sur Create New Application : Saisissez un nom / identifiant pour l'application Choisissez si le mod\u00e8le pourra inclure des entit\u00e9s voire des sous-entit\u00e9s (cf Concepts pour en savoir plus) S\u00e9lectionnez une ou plusieurs langues (voir Construire un bot multilingue pour en savoir plus) S\u00e9lectionnez un moteur NLU ( Apache OpenNLP ou Stanford CoreNLP , voir Installation pour en savoir plus)","title":"Cr\u00e9er une application"},{"location":"utilisateur/studio/configuration/#modifier-importer-et-exporter-une-application","text":"Pour chaque application d\u00e9j\u00e0 cr\u00e9\u00e9e, vous pouvez par la suite : Download an application dump : t\u00e9l\u00e9charger sa configuration au format JSON : langue, mod\u00e8le intentions/entit\u00e9s, etc. Download a sentences dump : t\u00e9l\u00e9charger ses phrases qualifi\u00e9es au format JSON Edit : modifier la configuration de l'application Un formulaire permet de modifier la configuraion initiale Une section Advanced options ajoute d'autres param\u00e8tres pour les utilisateurs avertis : Upload dump : charger une configuration ou des phrases qualifi\u00e9es \u00e0 partir d'un fichier au format JSON. Seules les nouvelles intentions/phrases seront ajout\u00e9es, cette fonction ne modifie pas / ne supprime pas les intentions/phrases existantes Trigger build : d\u00e9clencher/forcer la reconstruction du mod\u00e8le NLU Engine configuration : param\u00e9trer finement le moteur NLU sous-jacent (les param\u00e8tres d\u00e9pendant du moteur utilis\u00e9, Apache OpenNLP ou Stanford CoreNLP ) Alexa Export : exporter le mod\u00e8le Tock dans un format utilisable par Alexa La fonction Upload dump (voir ci-dessus) est \u00e9galement accessible directement en bas d'\u00e9cran, permettant : Soit de modifier une application (si l' application name existe) Soit d'en cr\u00e9er/importer une nouvelle","title":"Modifier, importer et exporter une application"},{"location":"utilisateur/studio/configuration/#longlet-bot-configurations","text":"Cet \u00e9cran permet d'acc\u00e9der aux connecteurs d'un bot, d'en ajouter, modifier ou supprimer. C'est aussi l\u00e0 que vous trouvez les informations pour se connecter programmatiquement.","title":"L'onglet Bot Configurations"},{"location":"utilisateur/studio/configuration/#se-connecter-programmatiquement-au-bot","text":"Le param\u00e9trage pour se connecter au bot programmatiquement (ie. via un programme / langage de programmation) se trouve dans cet \u00e9cran : L' API Key peut \u00eatre copi\u00e9e et embarqu\u00e9e dans le code client de la Bot API pour connecter des parcours programm\u00e9s en Kotlin ou dans un autre langage de programmation Une adresse / URL peut \u00eatre configur\u00e9e pour utiliser le mode WebHook de Bot API Pour en savoir plus sur ces param\u00e8tres et le d\u00e9veloppement de parcours, voir Bot API .","title":"Se connecter programmatiquement au bot"},{"location":"utilisateur/studio/configuration/#gerer-les-connecteurs","text":"La liste des connecteurs du bot est affich\u00e9e sous la clef d'API. Pour ajouter un connecteur au bot, cliquez sur Create a new Configuration . Tous les connecteurs poss\u00e8dent la configuration suivante : Configuration name : le nom/identifiant du bot Connector type : le type de canal (par exemple Messenger, Slack, etc.) Connector identifier : un identifiant pour le connecteur, unique pour le bot Relative REST path : un chemin relatif unique pour la plateforme, pour communiquer avec le bot sur ce canal. Par d\u00e9faut, le chemin est de la forme /io/{organisation}/{application}/{canal} ce qui le rend unique sur la plateforme (\u00e0 moins que deux connecteurs du m\u00eame type soient d\u00e9clar\u00e9s pour le m\u00eame bot). Chaque connecteur poss\u00e8de \u00e9galement une configuration suppl\u00e9mentaire sp\u00e9cifique \u00e0 ce type de connecteur. Ces param\u00e8tres sont dans Connector Custom Configuration . Ces param\u00e8tres sp\u00e9cifiques sont document\u00e9s avec chaque type de connecteur/canal, voir Les connecteurs .","title":"G\u00e9rer les connecteurs"},{"location":"utilisateur/studio/configuration/#connecteurs-de-test","text":"Pour chaque connecteur ajout\u00e9 au bot, un connecteur de test est aussi cr\u00e9\u00e9 et configur\u00e9. Il sert \u00e0 \"simuler\" le connecteur lorsqu'on teste le bot directement dans l'interface Tock Studio (menu Test > Test the bot ). Par d\u00e9faut, les connecteurs de test ne sont pas affich\u00e9s dans l'\u00e9cran Bot Configurations . Cliquez sur Display test configurations pour les voir et \u00e9ventuellement les modifier. En particulier, si vous obtenez des messages d'erreur de connexion dans la page Test the bot , n'h\u00e9sitez pas \u00e0 v\u00e9rfier la configuration de test notamment l'adresse Application base url (pour une plateforme d\u00e9ploy\u00e9e avec Docker Compose par d\u00e9faut, ce devrait \u00eatre http://bot_api:8080 avec le nom du conteneur et le port d\u00e9clar\u00e9s dans le descripteur docker-compose-bot.yml ).","title":"Connecteurs de test"},{"location":"utilisateur/studio/configuration/#continuer","text":"Rendez-vous dans Menu NLU pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"utilisateur/studio/general/","text":"L'interface Tock Studio \u00b6 Cette page pr\u00e9sente les caract\u00e9ristiques g\u00e9n\u00e9rales de Tock Studio . Les pages suivantes couvrent les diff\u00e9rents menus de l'application et diff\u00e9rentes fonctionnalit\u00e9s. Connexion \u00e0 l'application \u00b6 Un navigateur standard suffit pour acc\u00e9der \u00e0 Tock Studio . L'utilisateur est invit\u00e9 \u00e0 s'authentifier : Sur la plateforme Tock de d\u00e9monstration , l'utilisateur est invit\u00e9 \u00e0 s'authentifier via son compte GitHub. Celui-ci doit alors accepter que Tock acc\u00e8de \u00e0 son compte - seul l'identifiant du compte GitHub est lu par Tock. Sur une plateforme Tock par d\u00e9faut, les identifiants sont admin@app.com / password . Les identifiants par d\u00e9faut sont d\u00e9finis dans fichier source bot/admin/web/src/environments/environment.ts et il est recommand\u00e9 de les modifier. Il est aussi possible, en alternative, d'utiliser un m\u00e9canisme d'authentification en amont de l'application, par exemple via un service Apache HTTPd ou un service cloud comme AWS Cognito d'une part et un annuaire type LDAP d'autre part. Le bandeau applicatif \u00b6 En haut \u00e0 gauche de l'interface se trouvent : Un bouton permettant d'afficher (ou de masquer) les diff\u00e9rents menus Tock Studio Le nom de l'interface En haut \u00e0 droite de l'interface se trouvent : L'application / le bot couramment s\u00e9lectionn\u00e9 (utile lorsque plusieurs bots co-existent sur la plateforme) La langue couramment s\u00e9lectionn\u00e9e (utile pour tester un bot multilingue) Un lien pour se d\u00e9connecter Continuer... \u00b6 Rendez-vous dans Menu Configuration pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"L'interface _Tock Studio_"},{"location":"utilisateur/studio/general/#linterface-tock-studio","text":"Cette page pr\u00e9sente les caract\u00e9ristiques g\u00e9n\u00e9rales de Tock Studio . Les pages suivantes couvrent les diff\u00e9rents menus de l'application et diff\u00e9rentes fonctionnalit\u00e9s.","title":"L'interface Tock Studio"},{"location":"utilisateur/studio/general/#connexion-a-lapplication","text":"Un navigateur standard suffit pour acc\u00e9der \u00e0 Tock Studio . L'utilisateur est invit\u00e9 \u00e0 s'authentifier : Sur la plateforme Tock de d\u00e9monstration , l'utilisateur est invit\u00e9 \u00e0 s'authentifier via son compte GitHub. Celui-ci doit alors accepter que Tock acc\u00e8de \u00e0 son compte - seul l'identifiant du compte GitHub est lu par Tock. Sur une plateforme Tock par d\u00e9faut, les identifiants sont admin@app.com / password . Les identifiants par d\u00e9faut sont d\u00e9finis dans fichier source bot/admin/web/src/environments/environment.ts et il est recommand\u00e9 de les modifier. Il est aussi possible, en alternative, d'utiliser un m\u00e9canisme d'authentification en amont de l'application, par exemple via un service Apache HTTPd ou un service cloud comme AWS Cognito d'une part et un annuaire type LDAP d'autre part.","title":"Connexion \u00e0 l'application"},{"location":"utilisateur/studio/general/#le-bandeau-applicatif","text":"En haut \u00e0 gauche de l'interface se trouvent : Un bouton permettant d'afficher (ou de masquer) les diff\u00e9rents menus Tock Studio Le nom de l'interface En haut \u00e0 droite de l'interface se trouvent : L'application / le bot couramment s\u00e9lectionn\u00e9 (utile lorsque plusieurs bots co-existent sur la plateforme) La langue couramment s\u00e9lectionn\u00e9e (utile pour tester un bot multilingue) Un lien pour se d\u00e9connecter","title":"Le bandeau applicatif"},{"location":"utilisateur/studio/general/#continuer","text":"Rendez-vous dans Menu Configuration pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"utilisateur/studio/monitoring/","text":"Le menu Monitoring \u00b6 Le menu Monitoring permet de suivre et observer les utilisateurs connect\u00e9s ainsi que les conversations. L'onglet Users \u00b6 Cet onglet vous permet de voir les derniers utilisateurs connect\u00e9s au bot : Nombre d'utilisateurs connect\u00e9s Date du dernier \u00e9change avec un utilisateur Dernier message envoy\u00e9 Etc. En cliquant sur Display dialog , vous pouvez voir la conversation de cet utilisateur. L'onglet Dialogs \u00b6 A l'instar de la vue Users , cette \u00e9cran permet d'observer les derni\u00e8res conversations. Il est possible de les filtrer par connecteur, intention, etc. Continuer... \u00b6 Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _Monitoring_"},{"location":"utilisateur/studio/monitoring/#le-menu-monitoring","text":"Le menu Monitoring permet de suivre et observer les utilisateurs connect\u00e9s ainsi que les conversations.","title":"Le menu Monitoring"},{"location":"utilisateur/studio/monitoring/#longlet-users","text":"Cet onglet vous permet de voir les derniers utilisateurs connect\u00e9s au bot : Nombre d'utilisateurs connect\u00e9s Date du dernier \u00e9change avec un utilisateur Dernier message envoy\u00e9 Etc. En cliquant sur Display dialog , vous pouvez voir la conversation de cet utilisateur.","title":"L'onglet Users"},{"location":"utilisateur/studio/monitoring/#longlet-dialogs","text":"A l'instar de la vue Users , cette \u00e9cran permet d'observer les derni\u00e8res conversations. Il est possible de les filtrer par connecteur, intention, etc.","title":"L'onglet Dialogs"},{"location":"utilisateur/studio/monitoring/#continuer","text":"Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"utilisateur/studio/nlu-qa/","text":"Le menu NLU QA \u00b6 Le menu NLU QA permet d'\u00e9valuer et de suivre dans le temps la qualit\u00e9/pertinence/performance des mod\u00e8les conversationnels. L'onglet Stats \u00b6 Cet \u00e9cran pr\u00e9sente des graphes pour suivre l'\u00e9volution de plusieurs indicateurs de la qualit\u00e9 du mod\u00e8le conversationnel : Pertinence : les scores des algorithmes de d\u00e9tection sur les intentions ( Intent average probability ) et sur les entit\u00e9s ( Entity average probability ) Trafic / erreurs : le nombre de sollicitations du mod\u00e8le ( Calls ) et le nombre d'erreurs ( Errors ) Performance : le temps de r\u00e9ponse du mod\u00e8le ( Average call duration ) L'onglet Intent distance \u00b6 Les m\u00e9triques pr\u00e9sent\u00e9es en tableau dans cet page ( Occurrences et Average Diff ) permettent d'identifier les intentions plus ou moins proches dans le mod\u00e8le, notamment afin d'optimiser la mod\u00e9lisation. L'onglet Model Builds \u00b6 Cet \u00e9cran pr\u00e9sente des statistiques sur les derni\u00e8res reconstructions du mod\u00e8le. Il s'agit donc d'indications sur la performance du mod\u00e8le. L'onglet Tests Trend \u00b6 Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification, ou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles. Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire un mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le. Le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois pour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel. Pr\u00e9cision que ces tests ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents. Cet onglet donne l'\u00e9volution de la pertinence des tests partiels de mod\u00e8le. Par d\u00e9faut, les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes. Il est possible de configurer ce comportement avec la propri\u00e9t\u00e9 tock_test_model_timeframe (par d\u00e9faut : 0,5 ). L'onglet Intent Test Errors \u00b6 Cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection d'intentions (voir ci-dessus), avec le d\u00e9tails des phrases/expressions reconnues diff\u00e9remment du mod\u00e8le r\u00e9el. Dans cet exemple, aucune \"vraie\" erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. On peut toutefois constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement, avec une probabilit\u00e9 \u00e9lev\u00e9e. Pour chaque phrase il est possible via la colonne Actions de confirmer que le mod\u00e8le de base est correct (avec Validate Intent ) ou de corriger l'erreur d\u00e9tect\u00e9e ( Change The Intent ). Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le. L'onglet Entity Test Errors \u00b6 A l'instar de Intent Test Errors pour les entit\u00e9s, cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection des entit\u00e9s. Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le. Continuer... \u00b6 Rendez-vous dans Menu Build pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _NLU QA_"},{"location":"utilisateur/studio/nlu-qa/#le-menu-nlu-qa","text":"Le menu NLU QA permet d'\u00e9valuer et de suivre dans le temps la qualit\u00e9/pertinence/performance des mod\u00e8les conversationnels.","title":"Le menu NLU QA"},{"location":"utilisateur/studio/nlu-qa/#longlet-stats","text":"Cet \u00e9cran pr\u00e9sente des graphes pour suivre l'\u00e9volution de plusieurs indicateurs de la qualit\u00e9 du mod\u00e8le conversationnel : Pertinence : les scores des algorithmes de d\u00e9tection sur les intentions ( Intent average probability ) et sur les entit\u00e9s ( Entity average probability ) Trafic / erreurs : le nombre de sollicitations du mod\u00e8le ( Calls ) et le nombre d'erreurs ( Errors ) Performance : le temps de r\u00e9ponse du mod\u00e8le ( Average call duration )","title":"L'onglet Stats"},{"location":"utilisateur/studio/nlu-qa/#longlet-intent-distance","text":"Les m\u00e9triques pr\u00e9sent\u00e9es en tableau dans cet page ( Occurrences et Average Diff ) permettent d'identifier les intentions plus ou moins proches dans le mod\u00e8le, notamment afin d'optimiser la mod\u00e9lisation.","title":"L'onglet Intent distance"},{"location":"utilisateur/studio/nlu-qa/#longlet-model-builds","text":"Cet \u00e9cran pr\u00e9sente des statistiques sur les derni\u00e8res reconstructions du mod\u00e8le. Il s'agit donc d'indications sur la performance du mod\u00e8le.","title":"L'onglet Model Builds"},{"location":"utilisateur/studio/nlu-qa/#longlet-tests-trend","text":"Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification, ou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles. Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire un mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le. Le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois pour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel. Pr\u00e9cision que ces tests ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents. Cet onglet donne l'\u00e9volution de la pertinence des tests partiels de mod\u00e8le. Par d\u00e9faut, les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes. Il est possible de configurer ce comportement avec la propri\u00e9t\u00e9 tock_test_model_timeframe (par d\u00e9faut : 0,5 ).","title":"L'onglet Tests Trend"},{"location":"utilisateur/studio/nlu-qa/#longlet-intent-test-errors","text":"Cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection d'intentions (voir ci-dessus), avec le d\u00e9tails des phrases/expressions reconnues diff\u00e9remment du mod\u00e8le r\u00e9el. Dans cet exemple, aucune \"vraie\" erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. On peut toutefois constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement, avec une probabilit\u00e9 \u00e9lev\u00e9e. Pour chaque phrase il est possible via la colonne Actions de confirmer que le mod\u00e8le de base est correct (avec Validate Intent ) ou de corriger l'erreur d\u00e9tect\u00e9e ( Change The Intent ). Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le.","title":"L'onglet Intent Test Errors"},{"location":"utilisateur/studio/nlu-qa/#longlet-entity-test-errors","text":"A l'instar de Intent Test Errors pour les entit\u00e9s, cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection des entit\u00e9s. Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le.","title":"L'onglet Entity Test Errors"},{"location":"utilisateur/studio/nlu-qa/#continuer","text":"Rendez-vous dans Menu Build pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"utilisateur/studio/nlu/","text":"Le menu NLU \u00b6 Le menu NLU (Natural Language Understanding) permet de cr\u00e9er, modifier, enrichir les mod\u00e8les conversationnels : d\u00e9clarer des intentions et des entit\u00e9s , qualifier des phrases, etc. (voir Concepts pour en savoir plus). Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Construire les mod\u00e8les conversationnels pour une pr\u00e9sentation plus guid\u00e9e par l'usage. L'onglet Try it \u00b6 Cet \u00e9cran permet d'entrer des phrases et et de v\u00e9rifier quelle intention/entit\u00e9s sont d\u00e9tect\u00e9es. Saisissez une phrase et validez pour voir la d\u00e9tection r\u00e9sultant du mod\u00e8le conversationnel (en pratique : comment le bot interpr\u00e8te la phrase). S'affichent alors : Intent : l'intention reconnue Language : la langue d\u00e9tect\u00e9e Le(s) score(s) retourn\u00e9(s) par les algorithmes (selon leur niveau de confiance sur l'intention et sur les \u00e9ventuelles entit\u00e9s) Le cas \u00e9ch\u00e9ant, chaque entit\u00e9 d\u00e9tect\u00e9e avec son r\u00f4le/type et son score Il est possible de modifier tous les \u00e9l\u00e9ments d\u00e9tect\u00e9s depuis cet \u00e9cran : Pour modifier l'intention (voire en cr\u00e9er une nouvelle \u00e0 la vol\u00e9e) ou la langue d\u00e9tect\u00e9es, utilisez les champs / listes de s\u00e9lection sous la phrase Pour supprimer une entit\u00e9, utilisez le bouton \u00e0 c\u00f4t\u00e9 du score de l'entit\u00e9 Pour ajouter une entit\u00e9, s\u00e9lectionnez avec la souris un bloc de mots dansla phrase puis pr\u00e9cisez son r\u00f4le/type. Remarque : si vous avez activ\u00e9 cette option au niveau de l'application/bot, il est possible de d\u00e9clarer des sous-entit\u00e9s . Vous en apprendrez plus dans Construire les mod\u00e8les conversationnels . Les boutons et commandes suivantes sont disponibles pour la phrase dans sa globalit\u00e9 : Delete : supprime la phrase Unknown : qualifier la phrase en intention inconnue (r\u00e9ponse par d\u00e9faut) Validate : confirmer l'intention/entit\u00e9s d\u00e9tect\u00e9es et enregistrer la phrase dans le mod\u00e8le (provoquant in fine une reconstruction du mod\u00e8le, son corpus \u00e9tant enrichi de cette phrase) D'autres liens sont accessibles pour afficher les conversations contenant cette phrase, copier le contenu de la phrase, cr\u00e9er un parcours \u00e0 partir de cette phrase. L'onglet Inbox \u00b6 Cet onglet montre (avec de la pagination et quelques options d'affichage) l'ensemble des phrases re\u00e7ues par le mod\u00e8le NLU avec les intentions/entit\u00e9s/langue/scores d\u00e9tect\u00e9s. Ces phrases peuvent provenir de v\u00e9ritables utilisateurs quelques soient les canaux, d'une saisie dans l'onglet Try it ou encore d'une conversation via la page Test the bot dans Tock Studio . Lorsque vous faites des tests depuis un canal externe, n'h\u00e9sitez pas \u00e0 cliquer sur le bouton Refresh (en haut \u00e0 gauche de l'\u00e9cran) pour rafra\u00eechir la liste des phrases. Les boutons et commandes sous chaque phrase sont identiques \u00e0 ceux de l'onglet Try it (voir ci-dessus). L'onglet Unknown \u00b6 Cet \u00e9cran permet de parcourir les phrases dont l'intention n'a pas \u00e9t\u00e9 reconnue (intention unknown ). L'onglet Search \u00b6 Cet \u00e9cran permet de faire des recherches dans l'ensemble des phrases : Inbox mais aussi phrases qualifi\u00e9es enregistr\u00e9es dans le mod\u00e8le. L'onglet Intents \u00b6 Cet \u00e9cran permet de g\u00e9rer les intentions. L'onglet Entities \u00b6 Cet \u00e9cran permet de g\u00e9rer les entit\u00e9s, notamment les notions d'entit\u00e9s partag\u00e9es. L'onglet Logs \u00b6 Cet \u00e9cran pr\u00e9sente le journal complet des phrases re\u00e7ues et permet de remonter aux conversations (ie. l'ensemble des phrases re\u00e7ues et r\u00e9ponses du bot pour un utilisateur). Remarque : contrairement \u00e0 la vue Inbox , les Logs montrent les phrases re\u00e7ues m\u00eame lorsqu'elles existent d\u00e9j\u00e0 \u00e0 l'identique dans le mod\u00e8le (dans ce cas, le mod\u00e8le et les algorithmes ne sont m\u00eame pas interrog\u00e9s, la r\u00e9ponse \u00e9tant connue). Continuer... \u00b6 Rendez-vous dans Menu NLU QA pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _NLU_"},{"location":"utilisateur/studio/nlu/#le-menu-nlu","text":"Le menu NLU (Natural Language Understanding) permet de cr\u00e9er, modifier, enrichir les mod\u00e8les conversationnels : d\u00e9clarer des intentions et des entit\u00e9s , qualifier des phrases, etc. (voir Concepts pour en savoir plus). Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Construire les mod\u00e8les conversationnels pour une pr\u00e9sentation plus guid\u00e9e par l'usage.","title":"Le menu NLU"},{"location":"utilisateur/studio/nlu/#longlet-try-it","text":"Cet \u00e9cran permet d'entrer des phrases et et de v\u00e9rifier quelle intention/entit\u00e9s sont d\u00e9tect\u00e9es. Saisissez une phrase et validez pour voir la d\u00e9tection r\u00e9sultant du mod\u00e8le conversationnel (en pratique : comment le bot interpr\u00e8te la phrase). S'affichent alors : Intent : l'intention reconnue Language : la langue d\u00e9tect\u00e9e Le(s) score(s) retourn\u00e9(s) par les algorithmes (selon leur niveau de confiance sur l'intention et sur les \u00e9ventuelles entit\u00e9s) Le cas \u00e9ch\u00e9ant, chaque entit\u00e9 d\u00e9tect\u00e9e avec son r\u00f4le/type et son score Il est possible de modifier tous les \u00e9l\u00e9ments d\u00e9tect\u00e9s depuis cet \u00e9cran : Pour modifier l'intention (voire en cr\u00e9er une nouvelle \u00e0 la vol\u00e9e) ou la langue d\u00e9tect\u00e9es, utilisez les champs / listes de s\u00e9lection sous la phrase Pour supprimer une entit\u00e9, utilisez le bouton \u00e0 c\u00f4t\u00e9 du score de l'entit\u00e9 Pour ajouter une entit\u00e9, s\u00e9lectionnez avec la souris un bloc de mots dansla phrase puis pr\u00e9cisez son r\u00f4le/type. Remarque : si vous avez activ\u00e9 cette option au niveau de l'application/bot, il est possible de d\u00e9clarer des sous-entit\u00e9s . Vous en apprendrez plus dans Construire les mod\u00e8les conversationnels . Les boutons et commandes suivantes sont disponibles pour la phrase dans sa globalit\u00e9 : Delete : supprime la phrase Unknown : qualifier la phrase en intention inconnue (r\u00e9ponse par d\u00e9faut) Validate : confirmer l'intention/entit\u00e9s d\u00e9tect\u00e9es et enregistrer la phrase dans le mod\u00e8le (provoquant in fine une reconstruction du mod\u00e8le, son corpus \u00e9tant enrichi de cette phrase) D'autres liens sont accessibles pour afficher les conversations contenant cette phrase, copier le contenu de la phrase, cr\u00e9er un parcours \u00e0 partir de cette phrase.","title":"L'onglet Try it"},{"location":"utilisateur/studio/nlu/#longlet-inbox","text":"Cet onglet montre (avec de la pagination et quelques options d'affichage) l'ensemble des phrases re\u00e7ues par le mod\u00e8le NLU avec les intentions/entit\u00e9s/langue/scores d\u00e9tect\u00e9s. Ces phrases peuvent provenir de v\u00e9ritables utilisateurs quelques soient les canaux, d'une saisie dans l'onglet Try it ou encore d'une conversation via la page Test the bot dans Tock Studio . Lorsque vous faites des tests depuis un canal externe, n'h\u00e9sitez pas \u00e0 cliquer sur le bouton Refresh (en haut \u00e0 gauche de l'\u00e9cran) pour rafra\u00eechir la liste des phrases. Les boutons et commandes sous chaque phrase sont identiques \u00e0 ceux de l'onglet Try it (voir ci-dessus).","title":"L'onglet Inbox"},{"location":"utilisateur/studio/nlu/#longlet-unknown","text":"Cet \u00e9cran permet de parcourir les phrases dont l'intention n'a pas \u00e9t\u00e9 reconnue (intention unknown ).","title":"L'onglet Unknown"},{"location":"utilisateur/studio/nlu/#longlet-search","text":"Cet \u00e9cran permet de faire des recherches dans l'ensemble des phrases : Inbox mais aussi phrases qualifi\u00e9es enregistr\u00e9es dans le mod\u00e8le.","title":"L'onglet Search"},{"location":"utilisateur/studio/nlu/#longlet-intents","text":"Cet \u00e9cran permet de g\u00e9rer les intentions.","title":"L'onglet Intents"},{"location":"utilisateur/studio/nlu/#longlet-entities","text":"Cet \u00e9cran permet de g\u00e9rer les entit\u00e9s, notamment les notions d'entit\u00e9s partag\u00e9es.","title":"L'onglet Entities"},{"location":"utilisateur/studio/nlu/#longlet-logs","text":"Cet \u00e9cran pr\u00e9sente le journal complet des phrases re\u00e7ues et permet de remonter aux conversations (ie. l'ensemble des phrases re\u00e7ues et r\u00e9ponses du bot pour un utilisateur). Remarque : contrairement \u00e0 la vue Inbox , les Logs montrent les phrases re\u00e7ues m\u00eame lorsqu'elles existent d\u00e9j\u00e0 \u00e0 l'identique dans le mod\u00e8le (dans ce cas, le mod\u00e8le et les algorithmes ne sont m\u00eame pas interrog\u00e9s, la r\u00e9ponse \u00e9tant connue).","title":"L'onglet Logs"},{"location":"utilisateur/studio/nlu/#continuer","text":"Rendez-vous dans Menu NLU QA pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"utilisateur/studio/test/","text":"Le menu Test \u00b6 Le menu Test permet de tester un bot directement dans l'interface Tock Studio , ainsi que de g\u00e9rer des plans de tests automatiques. L'onglet Test the bot \u00b6 Via ce menu, vous pouvez parler directement au bot en simulant diff\u00e9rentes langues et connecteurs. Cela permet de tester rapidement et simplement un bot dans l'interface Tock Studio , sans avoir \u00e0 utiliser de logiciels et canaux externes. L'interface reste minimale car l'objectif est de tester rapidement le bot, pas d'obtenir une v\u00e9ritable interface utilisateur ni m\u00eame un rendu identique \u00e0 celui de tel ou tel connecteur. Selon le type de messages renvoy\u00e9s par le bot et selon le connecteur utilis\u00e9, il se peut que le rendu dans l'\u00e9cran Test the bot ne soit pas satisfaisant. En effet, pour une compatibilit\u00e9 parfaite avec cet \u00e9cran, les connecteurs doivent respecter certaines r\u00e8gles d'impl\u00e9mentation. Si vous constatez qu'un certain type de message pour un connecteur donn\u00e9 n'est pas bien g\u00e9r\u00e9 dans cette interface, n'h\u00e9sitez pas \u00e0 remonter une issue GitHub . Pour parler \u00e0 un bot dans l'interface, une fois dans Test > Test the bot : V\u00e9rifiez la langue (en haut \u00e0 droite de l'interface) S\u00e9lectionnez une application/un bot S\u00e9lectionnez un connecteur \u00e0 \u00e9muler Commencez \u00e0 saisir des phrases... Voici un autre exemple avec une conversation comprenant des composants riches du connecteur Messenger, avec leur rendu dans l'interface g\u00e9n\u00e9rique Tock Studio : Pour chaque \u00e9change de messages avec le bot, la langue d\u00e9tect\u00e9e est indiqu\u00e9e. En cliquant sur View Nlp Stats vous pouvez voir le d\u00e9tail de la r\u00e9ponse du mod\u00e8le : intention, entit\u00e9s, scores, etc. L'onglet Test Plans \u00b6 Cet outil permet de cr\u00e9er et de suivre l'ex\u00e9cution de tests de conversations automatis\u00e9s, afin de v\u00e9rifier automatiquement et r\u00e9guli\u00e8rement la non-r\u00e9gression du bot. Cette partie est en plein d\u00e9veloppement et une documentation compl\u00e8te arrivera prochainement. Continuer... \u00b6 Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _Test_"},{"location":"utilisateur/studio/test/#le-menu-test","text":"Le menu Test permet de tester un bot directement dans l'interface Tock Studio , ainsi que de g\u00e9rer des plans de tests automatiques.","title":"Le menu Test"},{"location":"utilisateur/studio/test/#longlet-test-the-bot","text":"Via ce menu, vous pouvez parler directement au bot en simulant diff\u00e9rentes langues et connecteurs. Cela permet de tester rapidement et simplement un bot dans l'interface Tock Studio , sans avoir \u00e0 utiliser de logiciels et canaux externes. L'interface reste minimale car l'objectif est de tester rapidement le bot, pas d'obtenir une v\u00e9ritable interface utilisateur ni m\u00eame un rendu identique \u00e0 celui de tel ou tel connecteur. Selon le type de messages renvoy\u00e9s par le bot et selon le connecteur utilis\u00e9, il se peut que le rendu dans l'\u00e9cran Test the bot ne soit pas satisfaisant. En effet, pour une compatibilit\u00e9 parfaite avec cet \u00e9cran, les connecteurs doivent respecter certaines r\u00e8gles d'impl\u00e9mentation. Si vous constatez qu'un certain type de message pour un connecteur donn\u00e9 n'est pas bien g\u00e9r\u00e9 dans cette interface, n'h\u00e9sitez pas \u00e0 remonter une issue GitHub . Pour parler \u00e0 un bot dans l'interface, une fois dans Test > Test the bot : V\u00e9rifiez la langue (en haut \u00e0 droite de l'interface) S\u00e9lectionnez une application/un bot S\u00e9lectionnez un connecteur \u00e0 \u00e9muler Commencez \u00e0 saisir des phrases... Voici un autre exemple avec une conversation comprenant des composants riches du connecteur Messenger, avec leur rendu dans l'interface g\u00e9n\u00e9rique Tock Studio : Pour chaque \u00e9change de messages avec le bot, la langue d\u00e9tect\u00e9e est indiqu\u00e9e. En cliquant sur View Nlp Stats vous pouvez voir le d\u00e9tail de la r\u00e9ponse du mod\u00e8le : intention, entit\u00e9s, scores, etc.","title":"L'onglet Test the bot"},{"location":"utilisateur/studio/test/#longlet-test-plans","text":"Cet outil permet de cr\u00e9er et de suivre l'ex\u00e9cution de tests de conversations automatis\u00e9s, afin de v\u00e9rifier automatiquement et r\u00e9guli\u00e8rement la non-r\u00e9gression du bot. Cette partie est en plein d\u00e9veloppement et une documentation compl\u00e8te arrivera prochainement.","title":"L'onglet Test Plans"},{"location":"utilisateur/studio/test/#continuer","text":"Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."}]}