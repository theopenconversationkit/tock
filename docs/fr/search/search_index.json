{"config":{"lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur Tock : une plateforme conversationnelle ouverte \u00b6 Tock ( The Open Conversation Kit ) est une plateforme compl\u00e8te pour construire des agents conversationnels - souvent appel\u00e9s bots . Le site Tock.ai est un bon point d'entr\u00e9e pour d\u00e9couvrir la solution, ses applications et sa communaut\u00e9 grandissante. Contrairement \u00e0 la plupart des solutions conversationnelles, Tock ne d\u00e9pend pas d'API tierces, bien qu'il soit possible d'en int\u00e9grer. L'utilisateur choisit les composants qu'il embarque et peut ainsi conserver la ma\u00eetrise de ses mod\u00e8les et donn\u00e9es conversationnelles. Tock est utilis\u00e9 en production depuis plusieurs ann\u00e9es par OUI.sncf pour proposer des assistants sur des canaux propres (Web, mobile), r\u00e9seaux sociaux et enceintes connect\u00e9es. L'ensemble du code source est disponible sur GitHub sous une licence Apache 2 . Pour en savoir plus sur le service AlloCovid (con\u00e7u avec Tock) rendez-vous sur www.allocovid.com ou sur cette page pour les aspects techniques et davantage de liens notamment vers les sources. Fonctionnalit\u00e9s \u00b6 Assistants autonomes ou int\u00e9gr\u00e9s \u00e0 des sites Web, applications mobiles, r\u00e9seaux sociaux, enceintes connect\u00e9es etc. sans d\u00e9pendre d'un canal particulier Plateforme NLU compl\u00e8te ( Natural Language Understanding ou TAL en fran\u00e7ais) Utilisant des briques open-source comme OpenNLP , Stanford CoreNLP , Duckling , Rasa (demain Spacy , CamemBERT , ...) D\u00e9ployable seule si besoin pour des usages comme l' Internet des objets Interfaces Tock Studio : Gestion des mod\u00e8les, entra\u00eenement du bot et performances Construction de parcours conversationnels et arbres de d\u00e9cision sans code Support de l'internationalisation ( i18n ) pour les bots multilingues Suivi des conversations et tendances / parcours utilisateurs ( Analytics ) Frameworks pour d\u00e9velopper des parcours complexes et int\u00e9grer des services tiers : DSLs en Kotlin , Javascript/Nodejs , Python et API tous langages (voir Bot API ) Nombreux connecteurs texte et voix : Messenger , WhatsApp , Google Assistant , Alexa , Twitter , Apple Business Chat , Teams , Slack ... (voir canaux ) Installation cloud ou on-premise , avec ou sans Docker , m\u00eame \"embarqu\u00e9\" sans Internet Technologies \u00b6 L'ensemble de la plateforme peut fonctionner conteneuris\u00e9e (impl\u00e9mentation Docker fournie). La plateforme applicative par d\u00e9faut est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. C\u00f4t\u00e9 serveur, Tock utilise Vert.x et MongoDB (alt. DocumentDB ) . Diff\u00e9rentes briques NLU peuvent \u00eatre utilis\u00e9es, mais Tock n'a pas de d\u00e9pendance forte envers l'une d'elles. Les interfaces graphiques Tock Studio sont \u00e9crites avec Angular en Typescript . Des int\u00e9grations React et Flutter sont fournies pour les interfaces Web et Mobile. D\u00e9marrer... \u00b6 Table des mati\u00e8res Guides et plateforme de d\u00e9monstration Manuels utilisateur , d\u00e9veloppeur , administrateur Ressources (supports, video) et exemples de code","title":"Accueil"},{"location":"#bienvenue-sur-tock-une-plateforme-conversationnelle-ouverte","text":"Tock ( The Open Conversation Kit ) est une plateforme compl\u00e8te pour construire des agents conversationnels - souvent appel\u00e9s bots . Le site Tock.ai est un bon point d'entr\u00e9e pour d\u00e9couvrir la solution, ses applications et sa communaut\u00e9 grandissante. Contrairement \u00e0 la plupart des solutions conversationnelles, Tock ne d\u00e9pend pas d'API tierces, bien qu'il soit possible d'en int\u00e9grer. L'utilisateur choisit les composants qu'il embarque et peut ainsi conserver la ma\u00eetrise de ses mod\u00e8les et donn\u00e9es conversationnelles. Tock est utilis\u00e9 en production depuis plusieurs ann\u00e9es par OUI.sncf pour proposer des assistants sur des canaux propres (Web, mobile), r\u00e9seaux sociaux et enceintes connect\u00e9es. L'ensemble du code source est disponible sur GitHub sous une licence Apache 2 . Pour en savoir plus sur le service AlloCovid (con\u00e7u avec Tock) rendez-vous sur www.allocovid.com ou sur cette page pour les aspects techniques et davantage de liens notamment vers les sources.","title":"Bienvenue sur Tock : une plateforme conversationnelle ouverte"},{"location":"#fonctionnalites","text":"Assistants autonomes ou int\u00e9gr\u00e9s \u00e0 des sites Web, applications mobiles, r\u00e9seaux sociaux, enceintes connect\u00e9es etc. sans d\u00e9pendre d'un canal particulier Plateforme NLU compl\u00e8te ( Natural Language Understanding ou TAL en fran\u00e7ais) Utilisant des briques open-source comme OpenNLP , Stanford CoreNLP , Duckling , Rasa (demain Spacy , CamemBERT , ...) D\u00e9ployable seule si besoin pour des usages comme l' Internet des objets Interfaces Tock Studio : Gestion des mod\u00e8les, entra\u00eenement du bot et performances Construction de parcours conversationnels et arbres de d\u00e9cision sans code Support de l'internationalisation ( i18n ) pour les bots multilingues Suivi des conversations et tendances / parcours utilisateurs ( Analytics ) Frameworks pour d\u00e9velopper des parcours complexes et int\u00e9grer des services tiers : DSLs en Kotlin , Javascript/Nodejs , Python et API tous langages (voir Bot API ) Nombreux connecteurs texte et voix : Messenger , WhatsApp , Google Assistant , Alexa , Twitter , Apple Business Chat , Teams , Slack ... (voir canaux ) Installation cloud ou on-premise , avec ou sans Docker , m\u00eame \"embarqu\u00e9\" sans Internet","title":"Fonctionnalit\u00e9s"},{"location":"#technologies","text":"L'ensemble de la plateforme peut fonctionner conteneuris\u00e9e (impl\u00e9mentation Docker fournie). La plateforme applicative par d\u00e9faut est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. C\u00f4t\u00e9 serveur, Tock utilise Vert.x et MongoDB (alt. DocumentDB ) . Diff\u00e9rentes briques NLU peuvent \u00eatre utilis\u00e9es, mais Tock n'a pas de d\u00e9pendance forte envers l'une d'elles. Les interfaces graphiques Tock Studio sont \u00e9crites avec Angular en Typescript . Des int\u00e9grations React et Flutter sont fournies pour les interfaces Web et Mobile.","title":"Technologies"},{"location":"#demarrer","text":"Table des mati\u00e8res Guides et plateforme de d\u00e9monstration Manuels utilisateur , d\u00e9veloppeur , administrateur Ressources (supports, video) et exemples de code","title":"D\u00e9marrer..."},{"location":"toc/","text":"Documentation Tock \u00b6 Accueil Table des mati\u00e8res D\u00e9couvrir Tock : Cr\u00e9er son premier bot avec Tock Studio Configurer son bot pour Slack Configurer son bot pour Messenger Programmer des parcours en mode Bot API D\u00e9ployer une plateforme Tock avec Docker Utiliser Tock : Concepts conversationnels pour Tock Interfaces Tock Studio : Interface g\u00e9n\u00e9rale Le menu Language Understanding Le menu Stories & Answers Le menu Test Le menu Analytics Le menu Model Quality Le menu Settings Guides : Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation) D\u00e9velopper avec Tock : Modes disponibles Tock Bot API Tock Bot int\u00e9gr\u00e9 Tests Unitaires Connecteurs Internationalisation ( i18n ) Liste des APIs Tock Exemples de code Administrer Tock : Architecture fonctionnelle et technique Installation S\u00e9curit\u00e9 Disponibilit\u00e9 Supervision Cloud A propos de Tock : Pourquoi Tock Vitrine utilisateurs Ressources & kit presse Nous contacter Communaut\u00e9 Contribuer Emploi","title":"Table des mati\u00e8res"},{"location":"toc/#documentation-tock","text":"Accueil Table des mati\u00e8res D\u00e9couvrir Tock : Cr\u00e9er son premier bot avec Tock Studio Configurer son bot pour Slack Configurer son bot pour Messenger Programmer des parcours en mode Bot API D\u00e9ployer une plateforme Tock avec Docker Utiliser Tock : Concepts conversationnels pour Tock Interfaces Tock Studio : Interface g\u00e9n\u00e9rale Le menu Language Understanding Le menu Stories & Answers Le menu Test Le menu Analytics Le menu Model Quality Le menu Settings Guides : Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation) D\u00e9velopper avec Tock : Modes disponibles Tock Bot API Tock Bot int\u00e9gr\u00e9 Tests Unitaires Connecteurs Internationalisation ( i18n ) Liste des APIs Tock Exemples de code Administrer Tock : Architecture fonctionnelle et technique Installation S\u00e9curit\u00e9 Disponibilit\u00e9 Supervision Cloud A propos de Tock : Pourquoi Tock Vitrine utilisateurs Ressources & kit presse Nous contacter Communaut\u00e9 Contribuer Emploi","title":"Documentation Tock"},{"location":"admin/architecture/","text":"Architecture de Tock \u00b6 Ce chapitre pr\u00e9sente l'architecture g\u00e9n\u00e9rale d'une plateforme Tock : composants et d\u00e9pendances, flux, configuration de proxies, etc. Architecture fonctionnelle \u00b6 Deux composants majeurs sont disponibles : le moteur NLU : Natural Language Understanding (voir Tock Studio ) le framework conversationnel int\u00e9gr\u00e9 aux services NLU et \u00e0 diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack (voir manuel d\u00e9veloppeur et connecteurs ). La plateforme NLU est ind\u00e9pendante de la partie conversationnelle. Il est possible d'utiliser le NLU sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l' Internet des objets , l'utilisation d'un mod\u00e8le NLU seule est pertinente. Architecture technique \u00b6 Tock est compos\u00e9 de plusieurs composants applicatifs ( conteneurs lorsqu'on utilise Docker) et d'une base de donn\u00e9e MongoDB . Les descripteurs Docker et Docker Compose fournis (ie. les Dockerfile et docker-compose.yml ) d\u00e9crivent l'architecture de Tock. Un exemple complet se trouve dans le fichier docker-compose-bot-open-data.yml disponible dans le d\u00e9p\u00f4t tock-docker . Base de donn\u00e9es MongoDB \u00b6 La base Mongo doit \u00eatre configur\u00e9e en replica set , c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. C'est obligatoire car Tock utilise la fonctionnalit\u00e9 des Change Streams qui a comme pr\u00e9-requis l'installation en replica set. Il s'agit \u00e9galement d'une bonne pratique afin d'assurer une haute disponibilit\u00e9 de la base de donn\u00e9es. Composants applicatifs \u00b6 Voici une description rapide des diff\u00e9rents composants applicatifs (et images Docker fournies avec Tock) : Interfaces et outils Tock Studio : tock/bot_admin : Tock Studio Partie NLU : tock/build_worker : reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire tock/duckling : analyse les dates et types primitifs en utilisant Duckling tock/nlp_api : analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio Partie conversationnelle : tock/bot_api : API pour d\u00e9velopper des bots (mode Tock Bot API ) tock/kotlin_compiler (facultatif) : compilateur de scripts pour les saisir directement dans l'interface Build de Tock Studio Un dernier composant, le bot lui-m\u00eame, doit \u00eatre ajout\u00e9 et rendu accessible aux partenaires et canaux externes auxquels on souhaite s'int\u00e9grer. Bien entendu l'impl\u00e9mentation du bot n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin) mais un exemple est disponible dans docker-compose-bot-open-data.yml . Modes de d\u00e9ploiement \u00b6 Le mode plateforme NLU seul (sans partie conversationnelle) : Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas), permettant de d\u00e9velopper en Kotlin ou un autre langage \u00e0 travers l'API conversationnelle de Tock : Le mode Tock Bot int\u00e9gr\u00e9 (historique) permettant de d\u00e9velopper en Kotlin uniquement en utilisant toutes les possibilit\u00e9s de Tock mais en acc\u00e9dant \u00e0 la base MongoDB directement depuis le bot : Voir aussi... \u00b6 Installation S\u00e9curit\u00e9 Supervision Cloud Haute disponibilit\u00e9","title":"Architecture"},{"location":"admin/architecture/#architecture-de-tock","text":"Ce chapitre pr\u00e9sente l'architecture g\u00e9n\u00e9rale d'une plateforme Tock : composants et d\u00e9pendances, flux, configuration de proxies, etc.","title":"Architecture de Tock"},{"location":"admin/architecture/#architecture-fonctionnelle","text":"Deux composants majeurs sont disponibles : le moteur NLU : Natural Language Understanding (voir Tock Studio ) le framework conversationnel int\u00e9gr\u00e9 aux services NLU et \u00e0 diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack (voir manuel d\u00e9veloppeur et connecteurs ). La plateforme NLU est ind\u00e9pendante de la partie conversationnelle. Il est possible d'utiliser le NLU sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l' Internet des objets , l'utilisation d'un mod\u00e8le NLU seule est pertinente.","title":"Architecture fonctionnelle"},{"location":"admin/architecture/#architecture-technique","text":"Tock est compos\u00e9 de plusieurs composants applicatifs ( conteneurs lorsqu'on utilise Docker) et d'une base de donn\u00e9e MongoDB . Les descripteurs Docker et Docker Compose fournis (ie. les Dockerfile et docker-compose.yml ) d\u00e9crivent l'architecture de Tock. Un exemple complet se trouve dans le fichier docker-compose-bot-open-data.yml disponible dans le d\u00e9p\u00f4t tock-docker .","title":"Architecture technique"},{"location":"admin/architecture/#base-de-donnees-mongodb","text":"La base Mongo doit \u00eatre configur\u00e9e en replica set , c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. C'est obligatoire car Tock utilise la fonctionnalit\u00e9 des Change Streams qui a comme pr\u00e9-requis l'installation en replica set. Il s'agit \u00e9galement d'une bonne pratique afin d'assurer une haute disponibilit\u00e9 de la base de donn\u00e9es.","title":"Base de donn\u00e9es MongoDB"},{"location":"admin/architecture/#composants-applicatifs","text":"Voici une description rapide des diff\u00e9rents composants applicatifs (et images Docker fournies avec Tock) : Interfaces et outils Tock Studio : tock/bot_admin : Tock Studio Partie NLU : tock/build_worker : reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire tock/duckling : analyse les dates et types primitifs en utilisant Duckling tock/nlp_api : analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio Partie conversationnelle : tock/bot_api : API pour d\u00e9velopper des bots (mode Tock Bot API ) tock/kotlin_compiler (facultatif) : compilateur de scripts pour les saisir directement dans l'interface Build de Tock Studio Un dernier composant, le bot lui-m\u00eame, doit \u00eatre ajout\u00e9 et rendu accessible aux partenaires et canaux externes auxquels on souhaite s'int\u00e9grer. Bien entendu l'impl\u00e9mentation du bot n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin) mais un exemple est disponible dans docker-compose-bot-open-data.yml .","title":"Composants applicatifs"},{"location":"admin/architecture/#modes-de-deploiement","text":"Le mode plateforme NLU seul (sans partie conversationnelle) : Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas), permettant de d\u00e9velopper en Kotlin ou un autre langage \u00e0 travers l'API conversationnelle de Tock : Le mode Tock Bot int\u00e9gr\u00e9 (historique) permettant de d\u00e9velopper en Kotlin uniquement en utilisant toutes les possibilit\u00e9s de Tock mais en acc\u00e9dant \u00e0 la base MongoDB directement depuis le bot :","title":"Modes de d\u00e9ploiement"},{"location":"admin/architecture/#voir-aussi","text":"Installation S\u00e9curit\u00e9 Supervision Cloud Haute disponibilit\u00e9","title":"Voir aussi..."},{"location":"admin/cloud/","text":"Cloud \u00b6 Cette page pr\u00e9sente les aspects li\u00e9s \u00e0 l'utilisation de services Cloud (priv\u00e9s ou publiques) pour d\u00e9ployer et h\u00e9berger plateformes et bots Tock. En effet, nous avons l'exp\u00e9rience d'utilisations de Tock en production sur des h\u00e9bergements classiques on-premise et bare metal , mais aussi sur des Clouds priv\u00e9s comme OpenStack ou Clouds publiques comme AWS . A venir : des d\u00e9tails, exemples et retours d'exp\u00e9rience sur l\"utilisation de Tock sur des h\u00e9bergements de type Cloud . Nous esp\u00e9rons m\u00eame pouvoir partager avec la communaut\u00e9 du code : infra as code , dashboards, etc.","title":"Cloud"},{"location":"admin/cloud/#cloud","text":"Cette page pr\u00e9sente les aspects li\u00e9s \u00e0 l'utilisation de services Cloud (priv\u00e9s ou publiques) pour d\u00e9ployer et h\u00e9berger plateformes et bots Tock. En effet, nous avons l'exp\u00e9rience d'utilisations de Tock en production sur des h\u00e9bergements classiques on-premise et bare metal , mais aussi sur des Clouds priv\u00e9s comme OpenStack ou Clouds publiques comme AWS . A venir : des d\u00e9tails, exemples et retours d'exp\u00e9rience sur l\"utilisation de Tock sur des h\u00e9bergements de type Cloud . Nous esp\u00e9rons m\u00eame pouvoir partager avec la communaut\u00e9 du code : infra as code , dashboards, etc.","title":"Cloud"},{"location":"admin/disponibilite/","text":"Haute disponibilit\u00e9 \u00b6 Cette page est destin\u00e9e \u00e0 fournir des conseils et des retours d'ex\u00e9prience sur les configurations haute disponibilit\u00e9 (ou HA - High Availability ) de bots et plateformes Tock. A venir : plus de d\u00e9tails sur les mani\u00e8res d'obtenir une haute disponibilit\u00e9 sur les diff\u00e9rents composants Tock, et des retours sur notre utilisation en production depuis plusieurs ann\u00e9es (cf vitrine / utilisateurs ). Redondance et r\u00e9silience \u00b6 Une seule instance de tock/build_worker doit exister. Il est recommand\u00e9 d'utiliser une seule instance de tock/bot_admin et tock/kotlin_compiler . Pour les autres composants, en particulier le composant bot (non fourni) mais \u00e9galement tock/nlp_api et tock/duckling , il est recommand\u00e9 de d\u00e9ployer plusieurs instances pour assurer une meilleure disponibilit\u00e9 voire de meilleures performances. Performance \u00b6 Comme indiqu\u00e9 dans la section installation , le premier param\u00e8tre \u00e0 surveiller est la m\u00e9moire disponible. A forte charge - nous avons exp\u00e9riment\u00e9 plus de 80 req/s sur nos propres bots - le facteur limitant devient la base de donn\u00e9es MongoDB, qu'il faut alors redimensionner en cons\u00e9quence quand le besoin s'en fait sentir.","title":"Disponibilit\u00e9"},{"location":"admin/disponibilite/#haute-disponibilite","text":"Cette page est destin\u00e9e \u00e0 fournir des conseils et des retours d'ex\u00e9prience sur les configurations haute disponibilit\u00e9 (ou HA - High Availability ) de bots et plateformes Tock. A venir : plus de d\u00e9tails sur les mani\u00e8res d'obtenir une haute disponibilit\u00e9 sur les diff\u00e9rents composants Tock, et des retours sur notre utilisation en production depuis plusieurs ann\u00e9es (cf vitrine / utilisateurs ).","title":"Haute disponibilit\u00e9"},{"location":"admin/disponibilite/#redondance-et-resilience","text":"Une seule instance de tock/build_worker doit exister. Il est recommand\u00e9 d'utiliser une seule instance de tock/bot_admin et tock/kotlin_compiler . Pour les autres composants, en particulier le composant bot (non fourni) mais \u00e9galement tock/nlp_api et tock/duckling , il est recommand\u00e9 de d\u00e9ployer plusieurs instances pour assurer une meilleure disponibilit\u00e9 voire de meilleures performances.","title":"Redondance et r\u00e9silience"},{"location":"admin/disponibilite/#performance","text":"Comme indiqu\u00e9 dans la section installation , le premier param\u00e8tre \u00e0 surveiller est la m\u00e9moire disponible. A forte charge - nous avons exp\u00e9riment\u00e9 plus de 80 req/s sur nos propres bots - le facteur limitant devient la base de donn\u00e9es MongoDB, qu'il faut alors redimensionner en cons\u00e9quence quand le besoin s'en fait sentir.","title":"Performance"},{"location":"admin/installation/","text":"Installation Tock \u00b6 La page architecture pr\u00e9sente l'architecture fonctionnelle et technique Tock, le r\u00f4le des diff\u00e9rents composants ainsi que les diff\u00e9rents modes de d\u00e9ploiement. Ce chapitre pr\u00e9sente les diff\u00e9rentes options d'installation de Tock. En particulier, il s'agit d'\u00e9voquer le cas d'une installation en production ainsi que partager quelques retours d'exp\u00e9rience sur les performances, la r\u00e9silience, la capacit\u00e9 de Tock \u00e0 monter en charge, les d\u00e9ploiementsde type Cloud , la supervision, etc. Si vous cherchez seulement \u00e0 tester Tock avec des donn\u00e9es non sensibles, vous pouvez pr\u00e9f\u00e9rer utiliser la plateforme de d\u00e9monstration Tock . Installation avec Docker \u00b6 Le d\u00e9p\u00f4t tock-docker fournit une impl\u00e9mentation compl\u00e8te de Tock pour les technologies Docker et Docker Compose . Tock est compos\u00e9 par d\u00e9faut de plusieurs conteneurs/images Docker et d'une base de donn\u00e9e MongoDB . Pour en savoir plus sur l'installation de Tock avec Docker, voir les instructions du d\u00e9p\u00f4t tock-docker . Le guide d\u00e9ployer Tock avec Docker dans la section D\u00e9couvrir Tock donne un exemple de d\u00e9ploiement d'une plateforme compl\u00e8te en quelques minutes avec une empreinte minimale en utilisant Docker et Docker Compose. Cependant, cette m\u00e9thode n'est pas envisageable pour un d\u00e9ploiement p\u00e9renne comme une plateforme de production. Si vous souhaitez utiliser Docker Compose en production, merci de lire cet article et de revoir la configuration, qui est uniquement donn\u00e9e dans le projet tock-docker \u00e0 titre d'exemple. En particulier, la configuration des instances MongoDB doit \u00eatre revue attentivement. Installation sans Docker \u00b6 Il est tout \u00e0 fait possible d'installer Tock sans utiliser Docker. En analysant les descripteurs fournis dans tock-docker (ie. les fichiers pom.xml , les Dockerfile et docker-compose.yml ) on peut facilement concevoir une installation sans Docker. Hormis la base de donn\u00e9es MongoDB, tous les autres composants peuvent d\u00e9marrer comme des applications Java/JVM classiques, par exemple : directement en ligne de commande au sein d'un serveur d'applications Java depuis un outil de d\u00e9veloppement int\u00e9gr\u00e9 (IDE) etc. Pour en savoir plus sur les param\u00e8tres de lancement des diff\u00e9rents composants Tock, vous pouvez vous inspirer des commandes pr\u00e9sentes dans les descripteurs de tock-docker ou encore des configurations fournies pour IntelliJ (voir ci-dessous). Ligne de commande \u00b6 Une technique consiste \u00e0 rassembler les diff\u00e9rentes d\u00e9pendances et archives JAR dans un dossier puis d\u00e9marrer le composant ou l'application avec une commande Java classique. Pour exemple, le descripteur du composant tock-docker-nlp-api (voir pom.xml ) avec la commande suivante : java $JAVA_ARGS -Dfile.encoding = UTF-8 -cp '/maven/*' ai.tock.nlp.api.StartNlpServiceKt JAR ex\u00e9cutable \u00b6 Ce n'est pas la technique que nous recommandons, mais il est possible d'ex\u00e9cuter un JAR unique contenant toutes les d\u00e9pendances (parfois appel\u00e9 \"fat JAR\" ). Voici comment proc\u00e9der pour cr\u00e9er un tel JAR, en reprenant l'exemple du composant Tock NLP-API. Dans le POM du composant ( nlp/api/service/pom.xml ), ajoutez la d\u00e9claration suivante : <build> <plugins> <plugin> <artifactId> maven-assembly-plugin </artifactId> <executions> <execution> <phase> package </phase> <goals> <goal> single </goal> </goals> <configuration> <archive> <manifest> <mainClass> ai.tock.nlp.api.StartNlpServiceKt </mainClass> </manifest> </archive> <descriptors> <descriptor> src/main/assembly/jar-with-dependencies.xml </descriptor> </descriptors> </configuration> </execution> </executions> </plugin> </plugins> </build> Cr\u00e9ez \u00e9galement un descripteur d'archive nlp/api/service/src/main/assembly/jar-with-dependencies.xml avec le contenu suivant : <assembly xmlns= \"http://maven.apache.org/ASSEMBLY/2.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\" > <id> jar-with-dependencies </id> <formats> <format> jar </format> </formats> <includeBaseDirectory> false </includeBaseDirectory> <dependencySets> <dependencySet> <outputDirectory> / </outputDirectory> <useProjectArtifact> true </useProjectArtifact> <unpack> true </unpack> <scope> runtime </scope> </dependencySet> </dependencySets> <containerDescriptorHandlers> <containerDescriptorHandler> <!-- Merge service implementations from dependencies --> <handlerName> metaInf-services </handlerName> </containerDescriptorHandler> </containerDescriptorHandlers> </assembly> Pour finir, construisez l'archive \"jar-with-dependencies\" avec mvn package . Dans un IDE \u00b6 Pour le d\u00e9veloppement, il est possible d'ex\u00e9cuter les diff\u00e9rents composants Tock (NLU, Studio, bot...) depuis un IDE comme IntelliJ , Eclipse ou Visual Studio Code par exemple. Outre les images Docker , des configurations pour IntelliJ sont fournies avec les sources de Tock : Configuration Services Tock Studio complets (Bot + NLP) / BotAdmin Configuration Services Tock Studio (NLP uniquement) / Admin Configuration Service NLP / NlpService Configuration Service d'entit\u00e9s / Duckling Configuration Service construction des mod\u00e8les NLP / BuildWorker Configuration Service de compilation des scripts / KotlinCompilerServer Enfin pour lancer les interfaces utilisateur ( Tock Studio ), les commandes sont d\u00e9crites dans les liens suivants : Instructions Interface Tock Studio compl\u00e8te (Bot + NLP) Instructions Interface Tock Studio (NLP uniquement) Base de donn\u00e9es MongoDB \u00b6 Architecture replica set \u00b6 La base MongoDB doit \u00eatre configur\u00e9e en replica set , car Tock tire parti des change streams . Cela implique qu'au minimum 3 noeuds doivent \u00eatre d\u00e9ploy\u00e9s, ce qui am\u00e9liore la r\u00e9silience. Diff\u00e9rents sc\u00e9narios sont possibles pour la base de donn\u00e9es : Installer les noeuds MongoDB sur un ou plusieurs serveurs (m\u00e9thode classique) Instancier les noeuds MongoDB avec Docker (pour des tests ou le d\u00e9veloppement en local) Utiliser un service cloud MongoDB en SaaS (Software-as-a-Service) , par exemple MongoDB Atlas disponible sur AWS, Azure et GCP Un tutoriel d'installation en replica set est disponible sur le site de MongoDB. Conservation des donn\u00e9es \u00b6 Tock conserve en base diff\u00e9rents types de donn\u00e9es et applique des TTL (Time To Live) , afin que certaines expirent et soient purg\u00e9es automatiquement apr\u00e8s un certain temps. En pratique, les variables d'environnement et l'application des TTL ont lieu \u00e0 l'initialisation des composant DAO (Data Access Object) , au d\u00e9marrage de Tock. Les TTL de Tock poss\u00e8dent une valeur par d\u00e9faut et sont configurables au moyen de variables d'environnement. Certaines concernent un composant Tock en particulier, d'autres doivent \u00eatre d\u00e9finies sur plusieurs composants. Tock pouvant \u00eatre utilis\u00e9 comme plateforme conversationnelle compl\u00e8te ou uniquement la partie NLU/NLP, on indique les variables sp\u00e9cifiques au conversationnel (not\u00e9es Bot ) ou utilisables sur tous les types de plateformes (not\u00e9es * ). Plateforme(s) Variable d'environnement Valeur par d\u00e9faut Description Composant(s) concern\u00e9(s) * tock_nlp_classified_sentences_index_ttl_days -1 (pas d'expiration) Phrases non valid\u00e9es ( Inbox ). nlp_api , nlp_admin / bot_admin , worker * tock_nlp_classified_sentences_index_ttl_intent_names Vide (toutes intentions) Phrases non valid\u00e9es ( Inbox ) >> restriction \u00e0 certaines intentions, s\u00e9par\u00e9es par des virgules. (Exemple ci-dessous). nlp_api * tock_nlp_log_index_ttl_days 7 Logs NLP : phrase, intentions, scores, d\u00e9tail des entit\u00e9s, etc. nlp_api * tock_nlp_log_stats_index_ttl_days 30 Statistiques NLP : nombre d'occurrences d'une phrase, scores, etc. nlp_api * tock_user_log_index_ttl_days 365 Log des actions dans Tock Studio : modifications de Stories , etc. nlp_admin / bot_admin Bot tock_bot_alternative_index_ttl_hours 1 Index sur les alternatives d'un label ( Answers ). bot / bot_api Bot tock_bot_dialog_index_ttl_days 7 Conversations ( Analytics > Users/Search ). bot / bot_api , nlp_admin / bot_admin Bot tock_bot_dialog_max_validity_in_seconds 60 * 60 * 24 (24h) Contextes des conversations (intention courante, entit\u00e9s dans le bus , etc.). bot / bot_api , nlp_admin / bot_admin Bot tock_bot_flow_stats_index_ttl_days 365 Statistiques de navigation ( Analytics > Activity/Behavior ). bot / bot_api , nlp_admin / bot_admin Bot tock_bot_timeline_index_ttl_days 365 Profils/historique utilisateurs : pr\u00e9f\u00e9rences, locale, derni\u00e8re connexion, etc. (hors d\u00e9tail des conversations) bot / bot_api , nlp_admin / bot_admin Selon le mode de d\u00e9ploiement utilis\u00e9, ces variables d'environnement peuvent \u00eatre ajout\u00e9es soit directement en ligne de commande, soit dans un descripteur type docker-compose.yml , dockerrun.aws.json ou autre (exemple ci-dessous). Il est possible de supprimer automatiquement les phrases non valid\u00e9es ( Inbox ) pour certaines intentions uniquement, gr\u00e2ce \u00e0 tock_nlp_classified_sentences_index_ttl_intent_names : docker-compose.yml version : '3' services : admin_web : image : tock/bot_admin:$TAG environment : - tock_nlp_classified_sentences_index_ttl_days=10 - tock_nlp_classified_sentences_index_ttl_intent_names=greetings,unknown dockerrun.aws.json { \"AWSEBDockerrunVersion\" : 2 , \"containerDefinitions\" : [ { \"name\" : \"admin_web\" , \"image\" : \"tock/bot_admin:${TAG}\" , \"environment\" : [ { \"name\" : \"tock_nlp_classified_sentences_index_ttl_days\" , \"value\" : \"10\" }, { \"name\" : \"tock_nlp_classified_sentences_index_ttl_intent_names\" , \"value\" : \"greetings,unknown\" } ] } ] } Dans cet exemple, seules les phrases d\u00e9tect\u00e9es comme intentions greetings ou unknown (mais non valid\u00e9es) seront supprim\u00e9es au bout de 10 jours ; les autres phrases ne seront pas supprim\u00e9es. Seules les phrases valid\u00e9es par un utilisateur dans Tock Studio , int\u00e9grant le mod\u00e8le NLP du bot, n'expirent jamais par d\u00e9faut (m\u00eame s'il reste possible de les supprimer du mod\u00e8le via la vue Search > Status: Included in model ) : il est donc important de ne pas valider des phrases comportant des donn\u00e9es personnelles par exemple. La conservation des donn\u00e9es, le chiffrement et l'anonymisation sont essentiels \u00e0 la protection des donn\u00e9es, en particulier si elles sont personnelles. Pour en savoir plus, voir la section S\u00e9curit\u00e9 > Donn\u00e9es . Composants applicatifs \u00b6 Selon les composants applicatifs de Tock, obligatoires ou facultatifs, certains doivent \u00eatre mono-instance et d'autres peuvent \u00eatre d\u00e9ploy\u00e9s en plusieurs instances (voir la section haute disponibilit\u00e9 pour en savoir plus). Pour plus de commodit\u00e9, les composants ci-dessous sont nomm\u00e9 comme les images Docker fournies avec Tock, bien que l'utilisation de Docker ne soit pas obligatoire pour installer Tock. Exposition r\u00e9seau \u00b6 Par d\u00e9faut, les composants ou conteneurs de la plateforme Tock ne doivent pas \u00eatre expos\u00e9s \u00e0 l'ext\u00e9rieur du VPN ou VPC . Seul le bot lui-m\u00eame doit \u00eatre accessible des partenaires et canaux externes auxquels on veut s'int\u00e9grer, pour le fonctionnement des WebHooks . Composant / Image Exposition r\u00e9seau Description tock/bot_admin VPN / VPC uniquement Interfaces et outils Tock Studio tock/build_worker VPN / VPC uniquement Reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire tock/duckling VPN / VPC uniquement Analyse les dates et types primitifs en utilisant Duckling tock/nlp_api VPN / VPC uniquement Analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio tock/bot_api VPN / VPC uniquement API pour d\u00e9velopper des bots (mode Tock Bot API ) tock/kotlin_compiler VPN / VPC uniquement (Facultatif) Compilateur de scripts pour les saisir directement dans l'interface Build de Tock Studio bot (non fourni) Internet / partenaires Le bot lui-m\u00eame, impl\u00e9mentant les parcours programmatiques, accessible des partenaires/canaux externes via des WebHooks Bien s\u00fbr, l'impl\u00e9mentation du bot lui-m\u00eame n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin). Proxies HTTP \u00b6 Les propri\u00e9t\u00e9s syst\u00e8me Java https.proxyHost , http.proxyHost et http.nonProxyHosts sont la m\u00e9thode recommand\u00e9e pour configurer un proxy. Packaging du bot \u00b6 Un exemple de bot en mode Tock Bot int\u00e9gr\u00e9 est disponible dans docker-compose-bot-open-data.yml . Des exemples et indications pour packager des bots en mode Tock Bot API ( WebHooks , WebSockets ) seront bient\u00f4t disponibles. Configurations minimales \u00b6 L'architecture Tock est compos\u00e9e de plusieurs composants qui peuvent \u00eatre d\u00e9ploy\u00e9s ensemble sur un m\u00eame serveur, ou r\u00e9partis sur plusieurs machines/instances. Le param\u00e8tre principal \u00e0 surveiller est la m\u00e9moire vive disponible. Construction des mod\u00e8les \u00b6 Plus vos mod\u00e8les sont importants, plus il est n\u00e9cessaire d'augmenter la m\u00e9moire pour reconstruire les mod\u00e8les (composant tock/build_worker ). Pour donner un ordre de grandeur, un mod\u00e8le de 50000 phrases avec plusieurs intentions, comportant une vingtaine d'entit\u00e9s, n\u00e9cessitera de provisionner environ 8 Go de RAM pour le composant tock/build_worker . Cependant, des mod\u00e8les importants mais contenant peu d'entit\u00e9s fonctionnent facilement avec seulement 1 Go de RAM. M\u00e9moire JVM & Docker \u00b6 Pour garantir que les conteneurs/instances Docker ne d\u00e9passent pas la m\u00e9moire disponible, il est recommand\u00e9 de limiter la m\u00e9moire des JVMs en suivant l'exemple suivant : JAVA_ARGS = -Xmx1g -XX:MaxMetaspaceSize = 256m Optimisation machines \u00b6 Il est possible d'optimiser d\u00e9ploiements et infrastructures en prenant en compte diff\u00e9rents \u00e9l\u00e9ments comme : les besoins des composants respectifs en ressources machines : CPU, m\u00e9moire, disque l'int\u00e9r\u00eat d'avoir une ou plusieurs instances de chaque composant suivant son r\u00f4le les contraintes/objectifs de r\u00e9silience et haute disponibilit\u00e9 les mod\u00e8les de co\u00fbts, notamment chez les fournisseurs de clouds publics Exemples \u00b6 A titre indicatif, voici quelques exemples de configurations actuellement en production. Il s'agit des composants \"applicatifs\" de l'architecture Tock sans la base de donn\u00e9e MongoDB. Les types d'instances EC2 sont donn\u00e9s \u00e0 titre indicatif. Tock n'a pas de d\u00e9pendance \u00e0 AWS. Pour en savoir plus voir la documentation AWS . Mod\u00e8les de taille limit\u00e9e \u00b6 Composants Tock Nombre d'instances Nombre de CPU ou vCPU M\u00e9moire RAM Exemple type d'instance EC2 admin-web + build-worker + kotlin-compiler + duckling 1 2 4 Go t3a.medium (usage g\u00e9n\u00e9ral) bot + nlp-api + duckling 3 2 4 Go t3a.medium (usage g\u00e9n\u00e9ral) Mod\u00e8les de taille importante \u00b6 Composants Tock Nombre d'instances Nombre de CPU ou vCPU M\u00e9moire RAM Exemple type d'instance EC2 admin-web + build-worker + kotlin-compiler + duckling 1 2 16 Go r5a.large (m\u00e9moire optimis\u00e9e) bot + nlp-api + duckling 3 2 4 Go t3a.medium (usage g\u00e9n\u00e9ral) Questions fr\u00e9quentes \u00b6 Mettre \u00e0 disposition l'interface d'administration dans un sous-repertoire \u00b6 Par d\u00e9faut l'interface d'administration est servie \u00e0 la racine (Exemple : https://[domain host] ) Si vous souhaitez la rendre disponible sur un chemin relatif ( https://[domain host]/tock ), utilisez dans la configuration de l'image docker tock_admin la variable d'environnement botadminverticle_base_href . Par exemple : botadminverticle_base_href=tock Voir aussi... \u00b6 Pour une utilisation de Tock en production, nous vous recommandons de parcourir \u00e9galement les pages suivantes : S\u00e9curit\u00e9 Supervision Cloud Haute disponibilit\u00e9","title":"Installation"},{"location":"admin/installation/#installation-tock","text":"La page architecture pr\u00e9sente l'architecture fonctionnelle et technique Tock, le r\u00f4le des diff\u00e9rents composants ainsi que les diff\u00e9rents modes de d\u00e9ploiement. Ce chapitre pr\u00e9sente les diff\u00e9rentes options d'installation de Tock. En particulier, il s'agit d'\u00e9voquer le cas d'une installation en production ainsi que partager quelques retours d'exp\u00e9rience sur les performances, la r\u00e9silience, la capacit\u00e9 de Tock \u00e0 monter en charge, les d\u00e9ploiementsde type Cloud , la supervision, etc. Si vous cherchez seulement \u00e0 tester Tock avec des donn\u00e9es non sensibles, vous pouvez pr\u00e9f\u00e9rer utiliser la plateforme de d\u00e9monstration Tock .","title":"Installation Tock"},{"location":"admin/installation/#installation-avec-docker","text":"Le d\u00e9p\u00f4t tock-docker fournit une impl\u00e9mentation compl\u00e8te de Tock pour les technologies Docker et Docker Compose . Tock est compos\u00e9 par d\u00e9faut de plusieurs conteneurs/images Docker et d'une base de donn\u00e9e MongoDB . Pour en savoir plus sur l'installation de Tock avec Docker, voir les instructions du d\u00e9p\u00f4t tock-docker . Le guide d\u00e9ployer Tock avec Docker dans la section D\u00e9couvrir Tock donne un exemple de d\u00e9ploiement d'une plateforme compl\u00e8te en quelques minutes avec une empreinte minimale en utilisant Docker et Docker Compose. Cependant, cette m\u00e9thode n'est pas envisageable pour un d\u00e9ploiement p\u00e9renne comme une plateforme de production. Si vous souhaitez utiliser Docker Compose en production, merci de lire cet article et de revoir la configuration, qui est uniquement donn\u00e9e dans le projet tock-docker \u00e0 titre d'exemple. En particulier, la configuration des instances MongoDB doit \u00eatre revue attentivement.","title":"Installation avec Docker"},{"location":"admin/installation/#installation-sans-docker","text":"Il est tout \u00e0 fait possible d'installer Tock sans utiliser Docker. En analysant les descripteurs fournis dans tock-docker (ie. les fichiers pom.xml , les Dockerfile et docker-compose.yml ) on peut facilement concevoir une installation sans Docker. Hormis la base de donn\u00e9es MongoDB, tous les autres composants peuvent d\u00e9marrer comme des applications Java/JVM classiques, par exemple : directement en ligne de commande au sein d'un serveur d'applications Java depuis un outil de d\u00e9veloppement int\u00e9gr\u00e9 (IDE) etc. Pour en savoir plus sur les param\u00e8tres de lancement des diff\u00e9rents composants Tock, vous pouvez vous inspirer des commandes pr\u00e9sentes dans les descripteurs de tock-docker ou encore des configurations fournies pour IntelliJ (voir ci-dessous).","title":"Installation sans Docker"},{"location":"admin/installation/#ligne-de-commande","text":"Une technique consiste \u00e0 rassembler les diff\u00e9rentes d\u00e9pendances et archives JAR dans un dossier puis d\u00e9marrer le composant ou l'application avec une commande Java classique. Pour exemple, le descripteur du composant tock-docker-nlp-api (voir pom.xml ) avec la commande suivante : java $JAVA_ARGS -Dfile.encoding = UTF-8 -cp '/maven/*' ai.tock.nlp.api.StartNlpServiceKt","title":"Ligne de commande"},{"location":"admin/installation/#jar-executable","text":"Ce n'est pas la technique que nous recommandons, mais il est possible d'ex\u00e9cuter un JAR unique contenant toutes les d\u00e9pendances (parfois appel\u00e9 \"fat JAR\" ). Voici comment proc\u00e9der pour cr\u00e9er un tel JAR, en reprenant l'exemple du composant Tock NLP-API. Dans le POM du composant ( nlp/api/service/pom.xml ), ajoutez la d\u00e9claration suivante : <build> <plugins> <plugin> <artifactId> maven-assembly-plugin </artifactId> <executions> <execution> <phase> package </phase> <goals> <goal> single </goal> </goals> <configuration> <archive> <manifest> <mainClass> ai.tock.nlp.api.StartNlpServiceKt </mainClass> </manifest> </archive> <descriptors> <descriptor> src/main/assembly/jar-with-dependencies.xml </descriptor> </descriptors> </configuration> </execution> </executions> </plugin> </plugins> </build> Cr\u00e9ez \u00e9galement un descripteur d'archive nlp/api/service/src/main/assembly/jar-with-dependencies.xml avec le contenu suivant : <assembly xmlns= \"http://maven.apache.org/ASSEMBLY/2.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\" > <id> jar-with-dependencies </id> <formats> <format> jar </format> </formats> <includeBaseDirectory> false </includeBaseDirectory> <dependencySets> <dependencySet> <outputDirectory> / </outputDirectory> <useProjectArtifact> true </useProjectArtifact> <unpack> true </unpack> <scope> runtime </scope> </dependencySet> </dependencySets> <containerDescriptorHandlers> <containerDescriptorHandler> <!-- Merge service implementations from dependencies --> <handlerName> metaInf-services </handlerName> </containerDescriptorHandler> </containerDescriptorHandlers> </assembly> Pour finir, construisez l'archive \"jar-with-dependencies\" avec mvn package .","title":"JAR ex\u00e9cutable"},{"location":"admin/installation/#dans-un-ide","text":"Pour le d\u00e9veloppement, il est possible d'ex\u00e9cuter les diff\u00e9rents composants Tock (NLU, Studio, bot...) depuis un IDE comme IntelliJ , Eclipse ou Visual Studio Code par exemple. Outre les images Docker , des configurations pour IntelliJ sont fournies avec les sources de Tock : Configuration Services Tock Studio complets (Bot + NLP) / BotAdmin Configuration Services Tock Studio (NLP uniquement) / Admin Configuration Service NLP / NlpService Configuration Service d'entit\u00e9s / Duckling Configuration Service construction des mod\u00e8les NLP / BuildWorker Configuration Service de compilation des scripts / KotlinCompilerServer Enfin pour lancer les interfaces utilisateur ( Tock Studio ), les commandes sont d\u00e9crites dans les liens suivants : Instructions Interface Tock Studio compl\u00e8te (Bot + NLP) Instructions Interface Tock Studio (NLP uniquement)","title":"Dans un IDE"},{"location":"admin/installation/#base-de-donnees-mongodb","text":"","title":"Base de donn\u00e9es MongoDB"},{"location":"admin/installation/#architecture-replica-set","text":"La base MongoDB doit \u00eatre configur\u00e9e en replica set , car Tock tire parti des change streams . Cela implique qu'au minimum 3 noeuds doivent \u00eatre d\u00e9ploy\u00e9s, ce qui am\u00e9liore la r\u00e9silience. Diff\u00e9rents sc\u00e9narios sont possibles pour la base de donn\u00e9es : Installer les noeuds MongoDB sur un ou plusieurs serveurs (m\u00e9thode classique) Instancier les noeuds MongoDB avec Docker (pour des tests ou le d\u00e9veloppement en local) Utiliser un service cloud MongoDB en SaaS (Software-as-a-Service) , par exemple MongoDB Atlas disponible sur AWS, Azure et GCP Un tutoriel d'installation en replica set est disponible sur le site de MongoDB.","title":"Architecture replica set"},{"location":"admin/installation/#conservation-des-donnees","text":"Tock conserve en base diff\u00e9rents types de donn\u00e9es et applique des TTL (Time To Live) , afin que certaines expirent et soient purg\u00e9es automatiquement apr\u00e8s un certain temps. En pratique, les variables d'environnement et l'application des TTL ont lieu \u00e0 l'initialisation des composant DAO (Data Access Object) , au d\u00e9marrage de Tock. Les TTL de Tock poss\u00e8dent une valeur par d\u00e9faut et sont configurables au moyen de variables d'environnement. Certaines concernent un composant Tock en particulier, d'autres doivent \u00eatre d\u00e9finies sur plusieurs composants. Tock pouvant \u00eatre utilis\u00e9 comme plateforme conversationnelle compl\u00e8te ou uniquement la partie NLU/NLP, on indique les variables sp\u00e9cifiques au conversationnel (not\u00e9es Bot ) ou utilisables sur tous les types de plateformes (not\u00e9es * ). Plateforme(s) Variable d'environnement Valeur par d\u00e9faut Description Composant(s) concern\u00e9(s) * tock_nlp_classified_sentences_index_ttl_days -1 (pas d'expiration) Phrases non valid\u00e9es ( Inbox ). nlp_api , nlp_admin / bot_admin , worker * tock_nlp_classified_sentences_index_ttl_intent_names Vide (toutes intentions) Phrases non valid\u00e9es ( Inbox ) >> restriction \u00e0 certaines intentions, s\u00e9par\u00e9es par des virgules. (Exemple ci-dessous). nlp_api * tock_nlp_log_index_ttl_days 7 Logs NLP : phrase, intentions, scores, d\u00e9tail des entit\u00e9s, etc. nlp_api * tock_nlp_log_stats_index_ttl_days 30 Statistiques NLP : nombre d'occurrences d'une phrase, scores, etc. nlp_api * tock_user_log_index_ttl_days 365 Log des actions dans Tock Studio : modifications de Stories , etc. nlp_admin / bot_admin Bot tock_bot_alternative_index_ttl_hours 1 Index sur les alternatives d'un label ( Answers ). bot / bot_api Bot tock_bot_dialog_index_ttl_days 7 Conversations ( Analytics > Users/Search ). bot / bot_api , nlp_admin / bot_admin Bot tock_bot_dialog_max_validity_in_seconds 60 * 60 * 24 (24h) Contextes des conversations (intention courante, entit\u00e9s dans le bus , etc.). bot / bot_api , nlp_admin / bot_admin Bot tock_bot_flow_stats_index_ttl_days 365 Statistiques de navigation ( Analytics > Activity/Behavior ). bot / bot_api , nlp_admin / bot_admin Bot tock_bot_timeline_index_ttl_days 365 Profils/historique utilisateurs : pr\u00e9f\u00e9rences, locale, derni\u00e8re connexion, etc. (hors d\u00e9tail des conversations) bot / bot_api , nlp_admin / bot_admin Selon le mode de d\u00e9ploiement utilis\u00e9, ces variables d'environnement peuvent \u00eatre ajout\u00e9es soit directement en ligne de commande, soit dans un descripteur type docker-compose.yml , dockerrun.aws.json ou autre (exemple ci-dessous). Il est possible de supprimer automatiquement les phrases non valid\u00e9es ( Inbox ) pour certaines intentions uniquement, gr\u00e2ce \u00e0 tock_nlp_classified_sentences_index_ttl_intent_names : docker-compose.yml version : '3' services : admin_web : image : tock/bot_admin:$TAG environment : - tock_nlp_classified_sentences_index_ttl_days=10 - tock_nlp_classified_sentences_index_ttl_intent_names=greetings,unknown dockerrun.aws.json { \"AWSEBDockerrunVersion\" : 2 , \"containerDefinitions\" : [ { \"name\" : \"admin_web\" , \"image\" : \"tock/bot_admin:${TAG}\" , \"environment\" : [ { \"name\" : \"tock_nlp_classified_sentences_index_ttl_days\" , \"value\" : \"10\" }, { \"name\" : \"tock_nlp_classified_sentences_index_ttl_intent_names\" , \"value\" : \"greetings,unknown\" } ] } ] } Dans cet exemple, seules les phrases d\u00e9tect\u00e9es comme intentions greetings ou unknown (mais non valid\u00e9es) seront supprim\u00e9es au bout de 10 jours ; les autres phrases ne seront pas supprim\u00e9es. Seules les phrases valid\u00e9es par un utilisateur dans Tock Studio , int\u00e9grant le mod\u00e8le NLP du bot, n'expirent jamais par d\u00e9faut (m\u00eame s'il reste possible de les supprimer du mod\u00e8le via la vue Search > Status: Included in model ) : il est donc important de ne pas valider des phrases comportant des donn\u00e9es personnelles par exemple. La conservation des donn\u00e9es, le chiffrement et l'anonymisation sont essentiels \u00e0 la protection des donn\u00e9es, en particulier si elles sont personnelles. Pour en savoir plus, voir la section S\u00e9curit\u00e9 > Donn\u00e9es .","title":"Conservation des donn\u00e9es"},{"location":"admin/installation/#composants-applicatifs","text":"Selon les composants applicatifs de Tock, obligatoires ou facultatifs, certains doivent \u00eatre mono-instance et d'autres peuvent \u00eatre d\u00e9ploy\u00e9s en plusieurs instances (voir la section haute disponibilit\u00e9 pour en savoir plus). Pour plus de commodit\u00e9, les composants ci-dessous sont nomm\u00e9 comme les images Docker fournies avec Tock, bien que l'utilisation de Docker ne soit pas obligatoire pour installer Tock.","title":"Composants applicatifs"},{"location":"admin/installation/#exposition-reseau","text":"Par d\u00e9faut, les composants ou conteneurs de la plateforme Tock ne doivent pas \u00eatre expos\u00e9s \u00e0 l'ext\u00e9rieur du VPN ou VPC . Seul le bot lui-m\u00eame doit \u00eatre accessible des partenaires et canaux externes auxquels on veut s'int\u00e9grer, pour le fonctionnement des WebHooks . Composant / Image Exposition r\u00e9seau Description tock/bot_admin VPN / VPC uniquement Interfaces et outils Tock Studio tock/build_worker VPN / VPC uniquement Reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire tock/duckling VPN / VPC uniquement Analyse les dates et types primitifs en utilisant Duckling tock/nlp_api VPN / VPC uniquement Analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio tock/bot_api VPN / VPC uniquement API pour d\u00e9velopper des bots (mode Tock Bot API ) tock/kotlin_compiler VPN / VPC uniquement (Facultatif) Compilateur de scripts pour les saisir directement dans l'interface Build de Tock Studio bot (non fourni) Internet / partenaires Le bot lui-m\u00eame, impl\u00e9mentant les parcours programmatiques, accessible des partenaires/canaux externes via des WebHooks Bien s\u00fbr, l'impl\u00e9mentation du bot lui-m\u00eame n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin).","title":"Exposition r\u00e9seau"},{"location":"admin/installation/#proxies-http","text":"Les propri\u00e9t\u00e9s syst\u00e8me Java https.proxyHost , http.proxyHost et http.nonProxyHosts sont la m\u00e9thode recommand\u00e9e pour configurer un proxy.","title":"Proxies HTTP"},{"location":"admin/installation/#packaging-du-bot","text":"Un exemple de bot en mode Tock Bot int\u00e9gr\u00e9 est disponible dans docker-compose-bot-open-data.yml . Des exemples et indications pour packager des bots en mode Tock Bot API ( WebHooks , WebSockets ) seront bient\u00f4t disponibles.","title":"Packaging du bot"},{"location":"admin/installation/#configurations-minimales","text":"L'architecture Tock est compos\u00e9e de plusieurs composants qui peuvent \u00eatre d\u00e9ploy\u00e9s ensemble sur un m\u00eame serveur, ou r\u00e9partis sur plusieurs machines/instances. Le param\u00e8tre principal \u00e0 surveiller est la m\u00e9moire vive disponible.","title":"Configurations minimales"},{"location":"admin/installation/#construction-des-modeles","text":"Plus vos mod\u00e8les sont importants, plus il est n\u00e9cessaire d'augmenter la m\u00e9moire pour reconstruire les mod\u00e8les (composant tock/build_worker ). Pour donner un ordre de grandeur, un mod\u00e8le de 50000 phrases avec plusieurs intentions, comportant une vingtaine d'entit\u00e9s, n\u00e9cessitera de provisionner environ 8 Go de RAM pour le composant tock/build_worker . Cependant, des mod\u00e8les importants mais contenant peu d'entit\u00e9s fonctionnent facilement avec seulement 1 Go de RAM.","title":"Construction des mod\u00e8les"},{"location":"admin/installation/#memoire-jvm-docker","text":"Pour garantir que les conteneurs/instances Docker ne d\u00e9passent pas la m\u00e9moire disponible, il est recommand\u00e9 de limiter la m\u00e9moire des JVMs en suivant l'exemple suivant : JAVA_ARGS = -Xmx1g -XX:MaxMetaspaceSize = 256m","title":"M\u00e9moire JVM &amp; Docker"},{"location":"admin/installation/#optimisation-machines","text":"Il est possible d'optimiser d\u00e9ploiements et infrastructures en prenant en compte diff\u00e9rents \u00e9l\u00e9ments comme : les besoins des composants respectifs en ressources machines : CPU, m\u00e9moire, disque l'int\u00e9r\u00eat d'avoir une ou plusieurs instances de chaque composant suivant son r\u00f4le les contraintes/objectifs de r\u00e9silience et haute disponibilit\u00e9 les mod\u00e8les de co\u00fbts, notamment chez les fournisseurs de clouds publics","title":"Optimisation machines"},{"location":"admin/installation/#exemples","text":"A titre indicatif, voici quelques exemples de configurations actuellement en production. Il s'agit des composants \"applicatifs\" de l'architecture Tock sans la base de donn\u00e9e MongoDB. Les types d'instances EC2 sont donn\u00e9s \u00e0 titre indicatif. Tock n'a pas de d\u00e9pendance \u00e0 AWS. Pour en savoir plus voir la documentation AWS .","title":"Exemples"},{"location":"admin/installation/#modeles-de-taille-limitee","text":"Composants Tock Nombre d'instances Nombre de CPU ou vCPU M\u00e9moire RAM Exemple type d'instance EC2 admin-web + build-worker + kotlin-compiler + duckling 1 2 4 Go t3a.medium (usage g\u00e9n\u00e9ral) bot + nlp-api + duckling 3 2 4 Go t3a.medium (usage g\u00e9n\u00e9ral)","title":"Mod\u00e8les de taille limit\u00e9e"},{"location":"admin/installation/#modeles-de-taille-importante","text":"Composants Tock Nombre d'instances Nombre de CPU ou vCPU M\u00e9moire RAM Exemple type d'instance EC2 admin-web + build-worker + kotlin-compiler + duckling 1 2 16 Go r5a.large (m\u00e9moire optimis\u00e9e) bot + nlp-api + duckling 3 2 4 Go t3a.medium (usage g\u00e9n\u00e9ral)","title":"Mod\u00e8les de taille importante"},{"location":"admin/installation/#questions-frequentes","text":"","title":"Questions fr\u00e9quentes"},{"location":"admin/installation/#mettre-a-disposition-linterface-dadministration-dans-un-sous-repertoire","text":"Par d\u00e9faut l'interface d'administration est servie \u00e0 la racine (Exemple : https://[domain host] ) Si vous souhaitez la rendre disponible sur un chemin relatif ( https://[domain host]/tock ), utilisez dans la configuration de l'image docker tock_admin la variable d'environnement botadminverticle_base_href . Par exemple : botadminverticle_base_href=tock","title":"Mettre \u00e0 disposition l'interface d'administration dans un sous-repertoire"},{"location":"admin/installation/#voir-aussi","text":"Pour une utilisation de Tock en production, nous vous recommandons de parcourir \u00e9galement les pages suivantes : S\u00e9curit\u00e9 Supervision Cloud Haute disponibilit\u00e9","title":"Voir aussi..."},{"location":"admin/securite/","text":"S\u00e9curit\u00e9 \u00b6 Utilisateurs Tock Studio \u00b6 Authentification \u00b6 Tock supporte plusieurs syst\u00e8mes d'authentification pour l'interface d'administration. Il utilise les librairies vert.x correspondantes. Voici les syst\u00e8mes disponibles par d\u00e9faut (tous impl\u00e9mentations de TockAuthProvider ) : Un mod\u00e8le par \"propri\u00e9t\u00e9s\", utilis\u00e9 par d\u00e9faut. Le code est disponible dans la classe PropertyBasedAuthProvider Un mod\u00e8le OAuth2 dont un exemple est donn\u00e9 par GithubOAuthProvider Un mod\u00e8le bas\u00e9 sur des jetons JWT , dont une impl\u00e9mentation pour AWS est disponible dans AWSJWTAuthProvider Des d\u00e9tails et exemples de configuration sont donn\u00e9s plus bas dans cette page. Si ces mod\u00e8les ne correspondent pas \u00e0 votre besoin, il est relativement simple d'en d\u00e9velopper d'autres en se basant sur les exemples ci-dessus. N'h\u00e9sitez pas \u00e0 contribuer au projet et \u00e0 nous contacter pour toute question! R\u00f4les \u00b6 Tock permet d'affecter plusieurs r\u00f4les ou niveaux d'habilitations aux utilisateurs dans les interfaces Tock Studio . En fonction du syst\u00e8me d'authentification utilis\u00e9 (par propri\u00e9t\u00e9s, 0Auth , etc.) chaque utilisateur se voit assign\u00e9 un ou plusieurs de ces r\u00f4les, lui donnant diff\u00e9rents acc\u00e8s dans l'application. Les r\u00f4les disponibles sont d\u00e9finis dans l'enum TockUserRole : R\u00f4le Description nlpUser NLP platform user, allowed to qualify and search sentences. botUser Bot platform user, allowed to create and modify stories, rules and answers. admin Allowed to update applications and configurations/connectors, import/export intents, sentences, stories, etc.. technicalAdmin Allowed to access encrypted data, import/export application dumps, etc. La mani\u00e8re de configurer quel utilisateur Tock Studio a quel r\u00f4le d\u00e9pend du mode d'authentification, autrement dit l'impl\u00e9mentation de TockAuthProvider utilis\u00e9e. Impl\u00e9mentation par propri\u00e9t\u00e9s \u00b6 La configuration par \"propri\u00e9t\u00e9s\" est utilis\u00e9e par d\u00e9faut. Elle ne d\u00e9pend d'aucun syst\u00e8me tiers pour fonctionner. Ce mode consiste a configurer utilisateurs et r\u00f4les par des propri\u00e9t\u00e9s ou variables d'environnement. Selon le mode de d\u00e9ploiement utilis\u00e9, ces variables peuvent \u00eatre d\u00e9finies soit directement en ligne de commande, soit dans un descripteur type docker-compose.yml , dockerrun.aws.json ou autre. Si aucune variable n'est d\u00e9finie (par exemple dans les descripteurs fournis dans le d\u00e9p\u00f4t tock-docker ), des valeurs par d\u00e9faut sont utilis\u00e9es. Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut : Variable d'environnement Valeur par d\u00e9faut Description tock_users admin@app.com Identifiants (s\u00e9par\u00e9s par des virgules). tock_passwords password Mots de passe (s\u00e9par\u00e9s par des virgules). tock_organizations app Organisations (s\u00e9par\u00e9es par des virgules). tock_roles Vide (ie. tous les r\u00f4les) R\u00f4les s\u00e9par\u00e9s par des | (puis par des virgules). Pour d\u00e9finir l'identit\u00e9 et les r\u00f4les de plusieurs utilisateurs, on s\u00e9pare les valeurs par des virgules. Attention : chacune de ces propri\u00e9t\u00e9s doit poss\u00e9der le m\u00eame nombre de valeurs (et dans le m\u00eame ordre) pour permettre de corr\u00e9ler ces valeurs (index par index, pour chaque utilisateur). Ci-dessous un exemple au format Docker-Compose : { \"name\" : \"tock_users\" , \"value\" : \"alice@tock.ai,bob@tock.ai\" } , { \"name\" : \"tock_passwords\" , \"value\" : \"secret1,secret2\" } , { \"name\" : \"tock_organizations\" , \"value\" : \"tock,tock\" } , { \"name\" : \"tock_roles\" , \"value\" : \"botUser,nlpUser|botUser|admin|technicalAdmin\" } , Dans cet exemple, Alice a le r\u00f4le botUser , alors que Bob a tous les r\u00f4les. Pour en savoir plus sur le fonctionnement pr\u00e9cis de cette impl\u00e9mentation, voir la classe PropertyBasedAuthProvider . Impl\u00e9mentation 0Auth/GitHub \u00b6 Cette impl\u00e9mentation assez simpliste est utilis\u00e9e \u00e0 titre d'exemple, ainsi que pour la plateforme publique de d\u00e9mo https://demo.tock.ai . Elle consiste \u00e0 interroger l'API GitHub pour v\u00e9rifier l'identit\u00e9 d'un utilisateur \u00e0 partir de son jeton ( access_token ). Remarque : aucune autre donn\u00e9e du profil GitHub n'est acc\u00e9d\u00e9e par Tock, \u00e0 part l'identifiant. Dans ce mode, activ\u00e9 par la propri\u00e9t\u00e9 tock_github_oauth_enabled , chaque utilisateur re\u00e7oit automatiquement tous les r\u00f4les Tock Studio et une organisation (ie. namespace) du m\u00eame nom que son identifiant. Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut : Variable d'environnement Valeur par d\u00e9faut Description tock_github_oauth_enabled false Activation de l'authentification 0Auth/GitHub. tock_github_oauth_client_id CLIENT_ID Identifiant pour interroger l'API GitHub. tock_github_oauth_secret_key SECRET_KEY Mot de passe pour interroger l'API GitHub. tock_github_api_request_timeout_ms 5000 Timeout v\u00e9rification de l'identit\u00e9 (API GitHub). Pour en savoir plus sur le fonctionnement pr\u00e9cis de cette impl\u00e9mentation, voir la classe GithubOAuthProvider . Impl\u00e9mentation AWS/JWT \u00b6 Une impl\u00e9mentation est fournie utilisant des jetons au format JWT v\u00e9rifi\u00e9s par un service AWS (Amazon Web Services) . Ce mode permet de cr\u00e9er une authentification unique ( SSO (Single Sign-On) ou F\u00e9d\u00e9ration d'identit\u00e9 ) dans une infrastructure Cloud AWS. Par d\u00e9faut, la r\u00e9gion cibl\u00e9e pour v\u00e9rifier les clefs publiques est la r\u00e9gion Irlande ( eu-west-1 ). Dans ce mode, activ\u00e9 par la propri\u00e9t\u00e9 tock_aws_jwt_enabled , l'affectation des r\u00f4les Tock Studio aux utilisateurs se fait \u00e0 travers leur jeton JWT et la propri\u00e9t\u00e9 tock_jwt_custom_roles_mapping . Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut : Variable d'environnement Valeur par d\u00e9faut Description tock_aws_jwt_enabled false Activation de l'authentification AWS/JWT. tock_jwt_custom_namespace_mapping Vide Organisations (s\u00e9par\u00e9es par des virgules). tock_jwt_custom_roles_mapping Vide Correspondances groupe=r\u00f4les s\u00e9par\u00e9s par des virgules (puis par des | ). jwt_algorithm ES256 Algorithme de d\u00e9codage du jeton JWT. tock_aws_public_key_request_timeout_ms 30000 Timeout v\u00e9rification des clefs (API AWS). Ci-dessous un exemple au format Docker-Compose : { \"name\" : \"tock_jwt_custom_roles_mapping\" , \"value\" : \"MY_USER_GROUP=nlpUser,botUser|MY_ADMIN_GROUP=nlpUser,botUser,admin,technicalAdmin\" } , Dans cet exemple, les utilisateurs appartenant au groupe MY_USER_GROUP poss\u00e8dent les r\u00f4les nlpUser et botUser , alors que les membres de MY_ADMIN_GROUP ont tous les r\u00f4les. Pour en savoir plus sur le fonctionnement pr\u00e9cis de cette impl\u00e9mentation, voir la classe AWSJWTAuthProvider . Donn\u00e9es \u00b6 Les utilisateurs pouvant transmettre aux bots des donn\u00e9es personnelles \u00e0 travers leurs conversations, il est important de r\u00e9fl\u00e9chir \u00e0 la nature des donn\u00e9es manipul\u00e9es dans Tock Studio ou stock\u00e9es par Tock, et de mettre en oeuvre des m\u00e9canismes de protection appropri\u00e9s (anonymisation, chiffrement, dur\u00e9e de r\u00e9tention, restrictions d'acc\u00e8s bas\u00e9es sur des r\u00f4les, etc.). Voir en particulier la r\u00e9glementation RGPD . Chiffrement des donn\u00e9es \u00b6 Chiffrement de la base \u00b6 Il est recommand\u00e9 de d\u00e9ployer vos bases de donn\u00e9es MongoDB en mode chiffr\u00e9 . Chiffrement applicatif \u00b6 Tock peut r\u00e9aliser un chiffrement applicatif (facultatif) de certains champs en base de donn\u00e9es, ind\u00e9pendamment du chiffrement de la base elle-m\u00eame. C'est le r\u00f4le de la variable d'environnement tock_encrypt_pass , qui permet d'indiquer un mot de passe pour chiffrer et d\u00e9chiffrer ces champs. Par d\u00e9faut en environnement prod , Tock chiffre toutes les donn\u00e9es utilisateurs jug\u00e9es sensibles \u00e0 condition que tock_encrypt_pass soit d\u00e9fini. Pour plus de d\u00e9tails, vous pouvez vous r\u00e9ferrer au code source . Remarque : d\u00e9finir tock_encrypt_pass est requis pour utiliser les fonctions d'anonymisation d'entit\u00e9s NLP dans les interfaces Tock Studio . Anonymisation \u00b6 Il est souvent souhaitable que certaines phrases soient anonymis\u00e9es que ce soit dans les logs (journalisation) ou dans l'interface ( Tock Studio ). Par exemple, des coordonn\u00e9es, num\u00e9ros de cartes de fid\u00e9lit\u00e9, etc. ne devraient \u00eatre lus ni par les utilisateurs de Tock Studio ni par les administrateurs de la plateforme. Par le framework \u00b6 Pour anonymiser ces donn\u00e9es, Tock met \u00e0 disposition dans son framework une solution bas\u00e9e sur des expressions r\u00e9guli\u00e8res (RegExp) dont l'interface de base est StringObfuscator . Par le mod\u00e8le NLP \u00b6 Tock permet \u00e9galement d'anonymiser dans Tock Studio (vue Inbox notamment.) les valeurs des entit\u00e9s reconnues par le mod\u00e8le NLP. Cette anonymisation par types d'entit\u00e9s se configure dans la vue Language Understanding > Entities . Seuls les utilisateurs ayant un r\u00f4le admin ou technicalAdmin dans Tock Studio peuvent activer/d\u00e9sactiver cette fonctionnalit\u00e9. Pour en savoir plus, voir R\u00f4les . Dans les vues o\u00f9 les phrases sont affich\u00e9es anonymis\u00e9es ( Inbox , Search par exemple), un admin ou technicalAdmin peut d\u00e9cider d'afficher quand m\u00eame (pour lui-m\u00eame uniquement) une phrase non anonymis\u00e9e gr\u00e2ce \u00e0 l'action Reveal the sentence (oeil ouvert). Remarque : d\u00e9finir tock_encrypt_pass est requis pour utiliser les fonctions d'anonymisation d'entit\u00e9s NLP dans les interfaces Tock Studio . Stockage & conservation \u00b6 Tock stocke automatiquement diff\u00e9rents types de donn\u00e9es, allant d'informations peu sensibles (configuration de Stories et r\u00e9ponses du bot, structure des intentions, statistiques de navigation tous utilisateurs confondus, etc.) \u00e0 des donn\u00e9es plus personnelles (d\u00e9tails des conversations, pr\u00e9f\u00e9rences utilisateurs, etc.). En fonction de leur nature et leur utilisation dans le fonctionnement de Tock (NLP, supervision, debug...), ces donn\u00e9es ont des dur\u00e9es de r\u00e9tention sp\u00e9cifiques, et configurables. Chaque utilisateur de Tock d\u00e9cide et configure combien de temps les donn\u00e9es stock\u00e9es sont conserv\u00e9es, en fonction de ses besoins. La section Installation > Conservation des donn\u00e9es d\u00e9crit les diff\u00e9rents types de donn\u00e9es conserv\u00e9es et comment modifier leur dur\u00e9e de r\u00e9tention.","title":"S\u00e9curit\u00e9"},{"location":"admin/securite/#securite","text":"","title":"S\u00e9curit\u00e9"},{"location":"admin/securite/#utilisateurs-tock-studio","text":"","title":"Utilisateurs Tock Studio"},{"location":"admin/securite/#authentification","text":"Tock supporte plusieurs syst\u00e8mes d'authentification pour l'interface d'administration. Il utilise les librairies vert.x correspondantes. Voici les syst\u00e8mes disponibles par d\u00e9faut (tous impl\u00e9mentations de TockAuthProvider ) : Un mod\u00e8le par \"propri\u00e9t\u00e9s\", utilis\u00e9 par d\u00e9faut. Le code est disponible dans la classe PropertyBasedAuthProvider Un mod\u00e8le OAuth2 dont un exemple est donn\u00e9 par GithubOAuthProvider Un mod\u00e8le bas\u00e9 sur des jetons JWT , dont une impl\u00e9mentation pour AWS est disponible dans AWSJWTAuthProvider Des d\u00e9tails et exemples de configuration sont donn\u00e9s plus bas dans cette page. Si ces mod\u00e8les ne correspondent pas \u00e0 votre besoin, il est relativement simple d'en d\u00e9velopper d'autres en se basant sur les exemples ci-dessus. N'h\u00e9sitez pas \u00e0 contribuer au projet et \u00e0 nous contacter pour toute question!","title":"Authentification"},{"location":"admin/securite/#roles","text":"Tock permet d'affecter plusieurs r\u00f4les ou niveaux d'habilitations aux utilisateurs dans les interfaces Tock Studio . En fonction du syst\u00e8me d'authentification utilis\u00e9 (par propri\u00e9t\u00e9s, 0Auth , etc.) chaque utilisateur se voit assign\u00e9 un ou plusieurs de ces r\u00f4les, lui donnant diff\u00e9rents acc\u00e8s dans l'application. Les r\u00f4les disponibles sont d\u00e9finis dans l'enum TockUserRole : R\u00f4le Description nlpUser NLP platform user, allowed to qualify and search sentences. botUser Bot platform user, allowed to create and modify stories, rules and answers. admin Allowed to update applications and configurations/connectors, import/export intents, sentences, stories, etc.. technicalAdmin Allowed to access encrypted data, import/export application dumps, etc. La mani\u00e8re de configurer quel utilisateur Tock Studio a quel r\u00f4le d\u00e9pend du mode d'authentification, autrement dit l'impl\u00e9mentation de TockAuthProvider utilis\u00e9e.","title":"R\u00f4les"},{"location":"admin/securite/#implementation-par-proprietes","text":"La configuration par \"propri\u00e9t\u00e9s\" est utilis\u00e9e par d\u00e9faut. Elle ne d\u00e9pend d'aucun syst\u00e8me tiers pour fonctionner. Ce mode consiste a configurer utilisateurs et r\u00f4les par des propri\u00e9t\u00e9s ou variables d'environnement. Selon le mode de d\u00e9ploiement utilis\u00e9, ces variables peuvent \u00eatre d\u00e9finies soit directement en ligne de commande, soit dans un descripteur type docker-compose.yml , dockerrun.aws.json ou autre. Si aucune variable n'est d\u00e9finie (par exemple dans les descripteurs fournis dans le d\u00e9p\u00f4t tock-docker ), des valeurs par d\u00e9faut sont utilis\u00e9es. Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut : Variable d'environnement Valeur par d\u00e9faut Description tock_users admin@app.com Identifiants (s\u00e9par\u00e9s par des virgules). tock_passwords password Mots de passe (s\u00e9par\u00e9s par des virgules). tock_organizations app Organisations (s\u00e9par\u00e9es par des virgules). tock_roles Vide (ie. tous les r\u00f4les) R\u00f4les s\u00e9par\u00e9s par des | (puis par des virgules). Pour d\u00e9finir l'identit\u00e9 et les r\u00f4les de plusieurs utilisateurs, on s\u00e9pare les valeurs par des virgules. Attention : chacune de ces propri\u00e9t\u00e9s doit poss\u00e9der le m\u00eame nombre de valeurs (et dans le m\u00eame ordre) pour permettre de corr\u00e9ler ces valeurs (index par index, pour chaque utilisateur). Ci-dessous un exemple au format Docker-Compose : { \"name\" : \"tock_users\" , \"value\" : \"alice@tock.ai,bob@tock.ai\" } , { \"name\" : \"tock_passwords\" , \"value\" : \"secret1,secret2\" } , { \"name\" : \"tock_organizations\" , \"value\" : \"tock,tock\" } , { \"name\" : \"tock_roles\" , \"value\" : \"botUser,nlpUser|botUser|admin|technicalAdmin\" } , Dans cet exemple, Alice a le r\u00f4le botUser , alors que Bob a tous les r\u00f4les. Pour en savoir plus sur le fonctionnement pr\u00e9cis de cette impl\u00e9mentation, voir la classe PropertyBasedAuthProvider .","title":"Impl\u00e9mentation par propri\u00e9t\u00e9s"},{"location":"admin/securite/#implementation-0authgithub","text":"Cette impl\u00e9mentation assez simpliste est utilis\u00e9e \u00e0 titre d'exemple, ainsi que pour la plateforme publique de d\u00e9mo https://demo.tock.ai . Elle consiste \u00e0 interroger l'API GitHub pour v\u00e9rifier l'identit\u00e9 d'un utilisateur \u00e0 partir de son jeton ( access_token ). Remarque : aucune autre donn\u00e9e du profil GitHub n'est acc\u00e9d\u00e9e par Tock, \u00e0 part l'identifiant. Dans ce mode, activ\u00e9 par la propri\u00e9t\u00e9 tock_github_oauth_enabled , chaque utilisateur re\u00e7oit automatiquement tous les r\u00f4les Tock Studio et une organisation (ie. namespace) du m\u00eame nom que son identifiant. Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut : Variable d'environnement Valeur par d\u00e9faut Description tock_github_oauth_enabled false Activation de l'authentification 0Auth/GitHub. tock_github_oauth_client_id CLIENT_ID Identifiant pour interroger l'API GitHub. tock_github_oauth_secret_key SECRET_KEY Mot de passe pour interroger l'API GitHub. tock_github_api_request_timeout_ms 5000 Timeout v\u00e9rification de l'identit\u00e9 (API GitHub). Pour en savoir plus sur le fonctionnement pr\u00e9cis de cette impl\u00e9mentation, voir la classe GithubOAuthProvider .","title":"Impl\u00e9mentation 0Auth/GitHub"},{"location":"admin/securite/#implementation-awsjwt","text":"Une impl\u00e9mentation est fournie utilisant des jetons au format JWT v\u00e9rifi\u00e9s par un service AWS (Amazon Web Services) . Ce mode permet de cr\u00e9er une authentification unique ( SSO (Single Sign-On) ou F\u00e9d\u00e9ration d'identit\u00e9 ) dans une infrastructure Cloud AWS. Par d\u00e9faut, la r\u00e9gion cibl\u00e9e pour v\u00e9rifier les clefs publiques est la r\u00e9gion Irlande ( eu-west-1 ). Dans ce mode, activ\u00e9 par la propri\u00e9t\u00e9 tock_aws_jwt_enabled , l'affectation des r\u00f4les Tock Studio aux utilisateurs se fait \u00e0 travers leur jeton JWT et la propri\u00e9t\u00e9 tock_jwt_custom_roles_mapping . Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut : Variable d'environnement Valeur par d\u00e9faut Description tock_aws_jwt_enabled false Activation de l'authentification AWS/JWT. tock_jwt_custom_namespace_mapping Vide Organisations (s\u00e9par\u00e9es par des virgules). tock_jwt_custom_roles_mapping Vide Correspondances groupe=r\u00f4les s\u00e9par\u00e9s par des virgules (puis par des | ). jwt_algorithm ES256 Algorithme de d\u00e9codage du jeton JWT. tock_aws_public_key_request_timeout_ms 30000 Timeout v\u00e9rification des clefs (API AWS). Ci-dessous un exemple au format Docker-Compose : { \"name\" : \"tock_jwt_custom_roles_mapping\" , \"value\" : \"MY_USER_GROUP=nlpUser,botUser|MY_ADMIN_GROUP=nlpUser,botUser,admin,technicalAdmin\" } , Dans cet exemple, les utilisateurs appartenant au groupe MY_USER_GROUP poss\u00e8dent les r\u00f4les nlpUser et botUser , alors que les membres de MY_ADMIN_GROUP ont tous les r\u00f4les. Pour en savoir plus sur le fonctionnement pr\u00e9cis de cette impl\u00e9mentation, voir la classe AWSJWTAuthProvider .","title":"Impl\u00e9mentation AWS/JWT"},{"location":"admin/securite/#donnees","text":"Les utilisateurs pouvant transmettre aux bots des donn\u00e9es personnelles \u00e0 travers leurs conversations, il est important de r\u00e9fl\u00e9chir \u00e0 la nature des donn\u00e9es manipul\u00e9es dans Tock Studio ou stock\u00e9es par Tock, et de mettre en oeuvre des m\u00e9canismes de protection appropri\u00e9s (anonymisation, chiffrement, dur\u00e9e de r\u00e9tention, restrictions d'acc\u00e8s bas\u00e9es sur des r\u00f4les, etc.). Voir en particulier la r\u00e9glementation RGPD .","title":"Donn\u00e9es"},{"location":"admin/securite/#chiffrement-des-donnees","text":"","title":"Chiffrement des donn\u00e9es"},{"location":"admin/securite/#chiffrement-de-la-base","text":"Il est recommand\u00e9 de d\u00e9ployer vos bases de donn\u00e9es MongoDB en mode chiffr\u00e9 .","title":"Chiffrement de la base"},{"location":"admin/securite/#chiffrement-applicatif","text":"Tock peut r\u00e9aliser un chiffrement applicatif (facultatif) de certains champs en base de donn\u00e9es, ind\u00e9pendamment du chiffrement de la base elle-m\u00eame. C'est le r\u00f4le de la variable d'environnement tock_encrypt_pass , qui permet d'indiquer un mot de passe pour chiffrer et d\u00e9chiffrer ces champs. Par d\u00e9faut en environnement prod , Tock chiffre toutes les donn\u00e9es utilisateurs jug\u00e9es sensibles \u00e0 condition que tock_encrypt_pass soit d\u00e9fini. Pour plus de d\u00e9tails, vous pouvez vous r\u00e9ferrer au code source . Remarque : d\u00e9finir tock_encrypt_pass est requis pour utiliser les fonctions d'anonymisation d'entit\u00e9s NLP dans les interfaces Tock Studio .","title":"Chiffrement applicatif"},{"location":"admin/securite/#anonymisation","text":"Il est souvent souhaitable que certaines phrases soient anonymis\u00e9es que ce soit dans les logs (journalisation) ou dans l'interface ( Tock Studio ). Par exemple, des coordonn\u00e9es, num\u00e9ros de cartes de fid\u00e9lit\u00e9, etc. ne devraient \u00eatre lus ni par les utilisateurs de Tock Studio ni par les administrateurs de la plateforme.","title":"Anonymisation"},{"location":"admin/securite/#par-le-framework","text":"Pour anonymiser ces donn\u00e9es, Tock met \u00e0 disposition dans son framework une solution bas\u00e9e sur des expressions r\u00e9guli\u00e8res (RegExp) dont l'interface de base est StringObfuscator .","title":"Par le framework"},{"location":"admin/securite/#par-le-modele-nlp","text":"Tock permet \u00e9galement d'anonymiser dans Tock Studio (vue Inbox notamment.) les valeurs des entit\u00e9s reconnues par le mod\u00e8le NLP. Cette anonymisation par types d'entit\u00e9s se configure dans la vue Language Understanding > Entities . Seuls les utilisateurs ayant un r\u00f4le admin ou technicalAdmin dans Tock Studio peuvent activer/d\u00e9sactiver cette fonctionnalit\u00e9. Pour en savoir plus, voir R\u00f4les . Dans les vues o\u00f9 les phrases sont affich\u00e9es anonymis\u00e9es ( Inbox , Search par exemple), un admin ou technicalAdmin peut d\u00e9cider d'afficher quand m\u00eame (pour lui-m\u00eame uniquement) une phrase non anonymis\u00e9e gr\u00e2ce \u00e0 l'action Reveal the sentence (oeil ouvert). Remarque : d\u00e9finir tock_encrypt_pass est requis pour utiliser les fonctions d'anonymisation d'entit\u00e9s NLP dans les interfaces Tock Studio .","title":"Par le mod\u00e8le NLP"},{"location":"admin/securite/#stockage-conservation","text":"Tock stocke automatiquement diff\u00e9rents types de donn\u00e9es, allant d'informations peu sensibles (configuration de Stories et r\u00e9ponses du bot, structure des intentions, statistiques de navigation tous utilisateurs confondus, etc.) \u00e0 des donn\u00e9es plus personnelles (d\u00e9tails des conversations, pr\u00e9f\u00e9rences utilisateurs, etc.). En fonction de leur nature et leur utilisation dans le fonctionnement de Tock (NLP, supervision, debug...), ces donn\u00e9es ont des dur\u00e9es de r\u00e9tention sp\u00e9cifiques, et configurables. Chaque utilisateur de Tock d\u00e9cide et configure combien de temps les donn\u00e9es stock\u00e9es sont conserv\u00e9es, en fonction de ses besoins. La section Installation > Conservation des donn\u00e9es d\u00e9crit les diff\u00e9rents types de donn\u00e9es conserv\u00e9es et comment modifier leur dur\u00e9e de r\u00e9tention.","title":"Stockage &amp; conservation"},{"location":"admin/supervision/","text":"Supervision \u00b6 Ce chapitre pr\u00e9sente quelques aspects supervision et monitoring du fonctionnement de la plateforme et des bots Tock. A venir : plus de d\u00e9tails sur la mani\u00e8re de monitorer les bots, voire des exemples de dashboards pour quelques technologies de monitoring classiques. N'h\u00e9sitez pas \u00e0 partager les v\u00f4tres. Lignes de vie (healthchecks) \u00b6 L'url /healthcheck renvoie une code HTTP 200 si tout est correct. Pour certaines images, le ligne de vie peut ne pas \u00eatre pr\u00e9sente \u00e0 la racine. En particulier : Pour tock/admin , la ligne de vie est localis\u00e9e par d\u00e9faut dans /rest/admin/healthcheck Pour tock/nlp_api , la ligne de vie est /rest/nlp/healthcheck Journalisation (logs) \u00b6 Logs applicatifs \u00b6 Tock utilise SLF4J et Logback pour g\u00e9n\u00e9rer ses logs applicatifs c\u00f4t\u00e9 serveur. Par d\u00e9faut Tock configure automatiquement ses logs et quelques propri\u00e9t\u00e9s permettent de modifier la configuration. Il est possible de configurer finement les logs en fonction des besoins, notamment avec des fichiers de configuration Logback ou avec Docker Compose. Auto-configuration \u00b6 Par d\u00e9faut, en l'absence de configuration sp\u00e9cifique, Tock configure ses logs automatiquement gr\u00e2ce \u00e0 la classe LogbackConfigurator . Celle-ci configure Logback programmatiquement, avec le comportement suivant : Niveau de log g\u00e9n\u00e9ral DEBUG si tock_env=dev (par d\u00e9faut), ou INFO pour les autres environnements et la production Exception pour les logs org.mongodb.driver toujours \u00e0 INFO Exception pour les logs io.netty toujours \u00e0 INFO Exception pour les logs okhttp3 toujours \u00e0 INFO Exception pour les logs io.mockk toujours \u00e0 INFO Logs dirig\u00e9s vers la console (sortie standard) par d\u00e9faut, mais possibilit\u00e9 d'\u00e9crire dans des fichiers En mode logs fichiers, \u00e9criture dans log/logFile.log , archivage d'un fichier chaque jour ( log/logFile.%d{yyyy-MM-dd}.log ), maximum 30 jours ou 3GB de logs conserv\u00e9s Pour en savoir plus sur la configuration automatiques des logs Tock, se r\u00e9f\u00e9rer \u00e0 l'impl\u00e9mentation LogbackConfigurator . Des variables d'environnement permettent de configurer ces diff\u00e9rents modes de journalisation. Elles peuvent \u00eatre d\u00e9finies ind\u00e9pendamment sur chaque composant produisant des logs. Variable d'environnement Valeur par d\u00e9faut Description tock_env dev Environnement (attention : contr\u00f4le d'autres m\u00e9canismes que les logs). tock_logback_enabled true Activation des logs. tock_default_log_level DEBUG si tock_env=dev (autrement INFO ) Niveau de log g\u00e9n\u00e9ral (hors exceptions, voir plus haut). tock_logback_file_appender false Logs fichiers (voir d\u00e9tails plus haut) \u00e0 la place des logs console (sortie standard). Selon le mode de d\u00e9ploiement utilis\u00e9, ces variables d'environnement peuvent \u00eatre ajout\u00e9es soit directement en ligne de commande, soit dans un descripteur type docker-compose.yml , dockerrun.aws.json ou autre. Voici un exemple configurant les logs de Tock Studio ( admin_web ) dans Docker : docker-compose.yml version : '3' services : admin_web : image : tock/bot_admin:$TAG environment : - tock_default_log_level=WARN - tock_logback_file_appender=true dockerrun.aws.json { \"AWSEBDockerrunVersion\" : 2 , \"containerDefinitions\" : [ { \"name\" : \"admin_web\" , \"image\" : \"tock/bot_admin:${TAG}\" , \"environment\" : [ { \"name\" : \"tock_default_log_level\" , \"value\" : \"WARN\" }, { \"name\" : \"tock_logback_file_appender\" , \"value\" : \"true\" } ] } ] } Fichiers Logback \u00b6 Il est possible de configurer finement les logs Tock en configurant directement Logback . Pour cela, diff\u00e9rentes possibilit\u00e9s existent, notamment des fichiers de configuration en format XML ou Groovy. Ci-dessous un exemple de configuration : logback.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration debug= \"false\" > <logger name= \"ai.tock\" level= \"DEBUG\" /> <logger name= \"org.mongodb\" level= \"WARN\" /> <appender name= \"console\" class= \"ch.qos.logback.core.ConsoleAppender\" > <encoder> <pattern> %d %-5level [%thread] %logger{1}: %msg%n </pattern> </encoder> </appender> <root level= \"INFO\" > <appender-ref ref= \"console\" /> </root> </configuration> logback.groovy import ch.qos.logback.classic.encoder.PatternLayoutEncoder import ch.qos.logback.core.ConsoleAppender import static ch . qos . logback . classic . Level . DEBUG import static ch . qos . logback . classic . Level . INFO import static ch . qos . logback . classic . Level . WARN appender ( \"console\" , ConsoleAppender ) { encoder ( PatternLayoutEncoder ) { pattern = \"%d %-5level [%thread] %logger{1}: %msg%n\" } } logger ( \"ai.tock\" , DEBUG ) logger ( \"org.mongodb\" , WARN ) root ( INFO , [ \"console\" ]) Dans cet exemple : Le niveau de log g\u00e9n\u00e9ral est INFO , avec des exceptions : Exception pour les logs ai.tock toujours \u00e0 DEBUG Exception pour les logs org.mongodb toujours \u00e0 WARN Les logs sont dirig\u00e9s vers la console (sortie standard) De nombreuses possibilit\u00e9s sont offertes pour configurer les logs gr\u00e2ce \u00e0 ces fichiers de configuration : niveaux de logs ajust\u00e9s en fonction des packages/frameworks embarqu\u00e9s, modification du pattern par d\u00e9faut, journalisation de logs fichiers et archivage auto avec un RollingFileAppender , redirection des logs vers un serveur de base de donn\u00e9es ou email, etc. Pour en savoir plus, se r\u00e9f\u00e9rer \u00e0 la documentation Logback . Une fois le fichier de configuration Logback cr\u00e9\u00e9, il faut s'assurer que celui-ci est dans la classpath du composant Tock et que Logback l'identifie comme la configuration \u00e0 suivre (pour cela on utilise g\u00e9n\u00e9ralement la propri\u00e9t\u00e9 -Dlogback.configurationFile au d\u00e9marrage du composant Java). Ci-dessous un exemple complet dans Docker Compose avec : Un fichier logback.xml embarqu\u00e9 par Maven ( pom.xml ) dans l'image Docker Quelques variables d'environnement d\u00e9finies pour pouvoir rapidement ajuste les principaux niveaux de log directement dans Docker-Compose (sans avoir \u00e0 modifier le fichier XML ni l'image Docker)' logback.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration debug= \"false\" > <!-- Leverage env variables with defaults, for more flexibility --> <variable name= \"tock_default_log_level\" value= \"${tock_default_log_level:-WARN}\" /> <variable name= \"tock_service_log_level\" value= \"${tock_service_log_level:-INFO}\" /> <variable name= \"tock_database_log_level\" value= \"${tock_database_log_level:-WARN}\" /> <logger name= \"ai.tock\" level= \"${tock_service_log_level}\" /> <logger name= \"org.mongodb\" level= \"${tock_database_log_level}\" /> <appender name= \"console\" class= \"ch.qos.logback.core.ConsoleAppender\" > <encoder> <pattern> %d %-5level [%thread] %logger{1}: %msg%n </pattern> </encoder> </appender> <root level= \"${tock_default_log_level}\" > <appender-ref ref= \"console\" /> </root> </configuration> pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <artifactId> tock-docker-bot-admin </artifactId> <build> <plugins> <plugin> <groupId> io.fabric8 </groupId> <artifactId> docker-maven-plugin </artifactId> <configuration> <images> <image> <name> tock/bot_admin:${project.version} </name> <build> <assembly> <inline> <dependencySets> ... </dependencySets> <files> <file> <source> logback.xml </source> <outputDirectory> . </outputDirectory> </file> </files> </inline> </assembly> <cmd> <shell> java $JAVA_ARGS -Dlogback.configurationFile='file:///maven/logback.xml' -Dfile.encoding=UTF-8 -Dtock_nlp_model_refresh_rate=10 -cp '/maven/*' ai.tock.bot.admin.StartBotAdminServerKt </shell> </cmd> ... docker-compose.yml version : '3' services : admin_web : image : tock/bot_admin:$TAG environment : - tock_default_log_level=WARN # Default, see logback.xml - tock_service_log_level=INFO # Default, see logback.xml - tock_database_log_level=WARN # Default, see logback.xml Le code complet de cet exemple appliqu\u00e9 \u00e0 tous les modules Tock est disponible dans le d\u00e9p\u00f4t tock-docker sur la branche logbackxml . Docker Compose \u00b6 Pour les utilisateurs de Docker Compose , un m\u00e9canisme permet de configurer les logs directement dans les descripteurs en YAML. Voir le d\u00e9pot tock-docker pour un exemple d'impl\u00e9mentation de Tock dans Docker Compose. Chaque composant applicatif peut avoir sa propre configuration : docker-compose.yml logging : driver : \"json-file\" options : max-size : \"10m\" max-file : \"5\" L'exemple ci-dessus configure une rotation automatique des fichiers de logs, de mani\u00e8re \u00e0 avoir maximum 5 fichiers de logs de maximum 10 Mo chacun (le plus ancien \u00e9tant supprim\u00e9 pour en cr\u00e9er un nouveau si besoin). Pour en savoir plus, voir la documentation Docker Compose de ce m\u00e9canisme. Chiffrement et anonymisation \u00b6 Voir la page s\u00e9curit\u00e9 concernant les possibilit\u00e9s de chiffrement et anonymisation des logs.","title":"Supervision"},{"location":"admin/supervision/#supervision","text":"Ce chapitre pr\u00e9sente quelques aspects supervision et monitoring du fonctionnement de la plateforme et des bots Tock. A venir : plus de d\u00e9tails sur la mani\u00e8re de monitorer les bots, voire des exemples de dashboards pour quelques technologies de monitoring classiques. N'h\u00e9sitez pas \u00e0 partager les v\u00f4tres.","title":"Supervision"},{"location":"admin/supervision/#lignes-de-vie-healthchecks","text":"L'url /healthcheck renvoie une code HTTP 200 si tout est correct. Pour certaines images, le ligne de vie peut ne pas \u00eatre pr\u00e9sente \u00e0 la racine. En particulier : Pour tock/admin , la ligne de vie est localis\u00e9e par d\u00e9faut dans /rest/admin/healthcheck Pour tock/nlp_api , la ligne de vie est /rest/nlp/healthcheck","title":"Lignes de vie (healthchecks)"},{"location":"admin/supervision/#journalisation-logs","text":"","title":"Journalisation (logs)"},{"location":"admin/supervision/#logs-applicatifs","text":"Tock utilise SLF4J et Logback pour g\u00e9n\u00e9rer ses logs applicatifs c\u00f4t\u00e9 serveur. Par d\u00e9faut Tock configure automatiquement ses logs et quelques propri\u00e9t\u00e9s permettent de modifier la configuration. Il est possible de configurer finement les logs en fonction des besoins, notamment avec des fichiers de configuration Logback ou avec Docker Compose.","title":"Logs applicatifs"},{"location":"admin/supervision/#auto-configuration","text":"Par d\u00e9faut, en l'absence de configuration sp\u00e9cifique, Tock configure ses logs automatiquement gr\u00e2ce \u00e0 la classe LogbackConfigurator . Celle-ci configure Logback programmatiquement, avec le comportement suivant : Niveau de log g\u00e9n\u00e9ral DEBUG si tock_env=dev (par d\u00e9faut), ou INFO pour les autres environnements et la production Exception pour les logs org.mongodb.driver toujours \u00e0 INFO Exception pour les logs io.netty toujours \u00e0 INFO Exception pour les logs okhttp3 toujours \u00e0 INFO Exception pour les logs io.mockk toujours \u00e0 INFO Logs dirig\u00e9s vers la console (sortie standard) par d\u00e9faut, mais possibilit\u00e9 d'\u00e9crire dans des fichiers En mode logs fichiers, \u00e9criture dans log/logFile.log , archivage d'un fichier chaque jour ( log/logFile.%d{yyyy-MM-dd}.log ), maximum 30 jours ou 3GB de logs conserv\u00e9s Pour en savoir plus sur la configuration automatiques des logs Tock, se r\u00e9f\u00e9rer \u00e0 l'impl\u00e9mentation LogbackConfigurator . Des variables d'environnement permettent de configurer ces diff\u00e9rents modes de journalisation. Elles peuvent \u00eatre d\u00e9finies ind\u00e9pendamment sur chaque composant produisant des logs. Variable d'environnement Valeur par d\u00e9faut Description tock_env dev Environnement (attention : contr\u00f4le d'autres m\u00e9canismes que les logs). tock_logback_enabled true Activation des logs. tock_default_log_level DEBUG si tock_env=dev (autrement INFO ) Niveau de log g\u00e9n\u00e9ral (hors exceptions, voir plus haut). tock_logback_file_appender false Logs fichiers (voir d\u00e9tails plus haut) \u00e0 la place des logs console (sortie standard). Selon le mode de d\u00e9ploiement utilis\u00e9, ces variables d'environnement peuvent \u00eatre ajout\u00e9es soit directement en ligne de commande, soit dans un descripteur type docker-compose.yml , dockerrun.aws.json ou autre. Voici un exemple configurant les logs de Tock Studio ( admin_web ) dans Docker : docker-compose.yml version : '3' services : admin_web : image : tock/bot_admin:$TAG environment : - tock_default_log_level=WARN - tock_logback_file_appender=true dockerrun.aws.json { \"AWSEBDockerrunVersion\" : 2 , \"containerDefinitions\" : [ { \"name\" : \"admin_web\" , \"image\" : \"tock/bot_admin:${TAG}\" , \"environment\" : [ { \"name\" : \"tock_default_log_level\" , \"value\" : \"WARN\" }, { \"name\" : \"tock_logback_file_appender\" , \"value\" : \"true\" } ] } ] }","title":"Auto-configuration"},{"location":"admin/supervision/#fichiers-logback","text":"Il est possible de configurer finement les logs Tock en configurant directement Logback . Pour cela, diff\u00e9rentes possibilit\u00e9s existent, notamment des fichiers de configuration en format XML ou Groovy. Ci-dessous un exemple de configuration : logback.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration debug= \"false\" > <logger name= \"ai.tock\" level= \"DEBUG\" /> <logger name= \"org.mongodb\" level= \"WARN\" /> <appender name= \"console\" class= \"ch.qos.logback.core.ConsoleAppender\" > <encoder> <pattern> %d %-5level [%thread] %logger{1}: %msg%n </pattern> </encoder> </appender> <root level= \"INFO\" > <appender-ref ref= \"console\" /> </root> </configuration> logback.groovy import ch.qos.logback.classic.encoder.PatternLayoutEncoder import ch.qos.logback.core.ConsoleAppender import static ch . qos . logback . classic . Level . DEBUG import static ch . qos . logback . classic . Level . INFO import static ch . qos . logback . classic . Level . WARN appender ( \"console\" , ConsoleAppender ) { encoder ( PatternLayoutEncoder ) { pattern = \"%d %-5level [%thread] %logger{1}: %msg%n\" } } logger ( \"ai.tock\" , DEBUG ) logger ( \"org.mongodb\" , WARN ) root ( INFO , [ \"console\" ]) Dans cet exemple : Le niveau de log g\u00e9n\u00e9ral est INFO , avec des exceptions : Exception pour les logs ai.tock toujours \u00e0 DEBUG Exception pour les logs org.mongodb toujours \u00e0 WARN Les logs sont dirig\u00e9s vers la console (sortie standard) De nombreuses possibilit\u00e9s sont offertes pour configurer les logs gr\u00e2ce \u00e0 ces fichiers de configuration : niveaux de logs ajust\u00e9s en fonction des packages/frameworks embarqu\u00e9s, modification du pattern par d\u00e9faut, journalisation de logs fichiers et archivage auto avec un RollingFileAppender , redirection des logs vers un serveur de base de donn\u00e9es ou email, etc. Pour en savoir plus, se r\u00e9f\u00e9rer \u00e0 la documentation Logback . Une fois le fichier de configuration Logback cr\u00e9\u00e9, il faut s'assurer que celui-ci est dans la classpath du composant Tock et que Logback l'identifie comme la configuration \u00e0 suivre (pour cela on utilise g\u00e9n\u00e9ralement la propri\u00e9t\u00e9 -Dlogback.configurationFile au d\u00e9marrage du composant Java). Ci-dessous un exemple complet dans Docker Compose avec : Un fichier logback.xml embarqu\u00e9 par Maven ( pom.xml ) dans l'image Docker Quelques variables d'environnement d\u00e9finies pour pouvoir rapidement ajuste les principaux niveaux de log directement dans Docker-Compose (sans avoir \u00e0 modifier le fichier XML ni l'image Docker)' logback.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration debug= \"false\" > <!-- Leverage env variables with defaults, for more flexibility --> <variable name= \"tock_default_log_level\" value= \"${tock_default_log_level:-WARN}\" /> <variable name= \"tock_service_log_level\" value= \"${tock_service_log_level:-INFO}\" /> <variable name= \"tock_database_log_level\" value= \"${tock_database_log_level:-WARN}\" /> <logger name= \"ai.tock\" level= \"${tock_service_log_level}\" /> <logger name= \"org.mongodb\" level= \"${tock_database_log_level}\" /> <appender name= \"console\" class= \"ch.qos.logback.core.ConsoleAppender\" > <encoder> <pattern> %d %-5level [%thread] %logger{1}: %msg%n </pattern> </encoder> </appender> <root level= \"${tock_default_log_level}\" > <appender-ref ref= \"console\" /> </root> </configuration> pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <artifactId> tock-docker-bot-admin </artifactId> <build> <plugins> <plugin> <groupId> io.fabric8 </groupId> <artifactId> docker-maven-plugin </artifactId> <configuration> <images> <image> <name> tock/bot_admin:${project.version} </name> <build> <assembly> <inline> <dependencySets> ... </dependencySets> <files> <file> <source> logback.xml </source> <outputDirectory> . </outputDirectory> </file> </files> </inline> </assembly> <cmd> <shell> java $JAVA_ARGS -Dlogback.configurationFile='file:///maven/logback.xml' -Dfile.encoding=UTF-8 -Dtock_nlp_model_refresh_rate=10 -cp '/maven/*' ai.tock.bot.admin.StartBotAdminServerKt </shell> </cmd> ... docker-compose.yml version : '3' services : admin_web : image : tock/bot_admin:$TAG environment : - tock_default_log_level=WARN # Default, see logback.xml - tock_service_log_level=INFO # Default, see logback.xml - tock_database_log_level=WARN # Default, see logback.xml Le code complet de cet exemple appliqu\u00e9 \u00e0 tous les modules Tock est disponible dans le d\u00e9p\u00f4t tock-docker sur la branche logbackxml .","title":"Fichiers Logback"},{"location":"admin/supervision/#docker-compose","text":"Pour les utilisateurs de Docker Compose , un m\u00e9canisme permet de configurer les logs directement dans les descripteurs en YAML. Voir le d\u00e9pot tock-docker pour un exemple d'impl\u00e9mentation de Tock dans Docker Compose. Chaque composant applicatif peut avoir sa propre configuration : docker-compose.yml logging : driver : \"json-file\" options : max-size : \"10m\" max-file : \"5\" L'exemple ci-dessus configure une rotation automatique des fichiers de logs, de mani\u00e8re \u00e0 avoir maximum 5 fichiers de logs de maximum 10 Mo chacun (le plus ancien \u00e9tant supprim\u00e9 pour en cr\u00e9er un nouveau si besoin). Pour en savoir plus, voir la documentation Docker Compose de ce m\u00e9canisme.","title":"Docker Compose"},{"location":"admin/supervision/#chiffrement-et-anonymisation","text":"Voir la page s\u00e9curit\u00e9 concernant les possibilit\u00e9s de chiffrement et anonymisation des logs.","title":"Chiffrement et anonymisation"},{"location":"apropos/communaute/","text":"Communaut\u00e9 Tock \u00b6 Tock est b\u00e2ti sur un mod\u00e8le communautaire pour cr\u00e9er une plateforme ouverte. Pour en savoir plus, voir pourquoi Tock . La communaut\u00e9 Tock est ouverte \u00e0 la contribution et tous les retours comme les feature requests et pull requests sont les bienvenus ! Rejoindre la communaut\u00e9 (Gitter) \u00b6 La plupart des utilisateurs et contributeurs Tock se retrouvent sur la messagerie instantann\u00e9e Gitter . C'est un bon moyen de voir \u00e0 quel point la communaut\u00e9 est active et accessible. Communaut\u00e9 Tock sur Gitter Fil Gitter des releases Tock Suivre l'actualit\u00e9 de la plateforme \u00b6 Pour suivre l'actualit\u00e9 des projets Tock mais aussi les meetups, conf\u00e9rences, etc., rendez-vous sur le site principal : Tock.ai Vous pouvez \u00e9galement retrouver les nouveaut\u00e9s dans ces pages plus sp\u00e9cfiques : Projets & utilisateurs connus Pr\u00e9sentations & conf\u00e9rences Prix & r\u00e9compenses Enfin, pour suivre les versions et fonctionnalit\u00e9s de Tock : Fil Gitter des releases & features Release Notes Roadmap Code & Contribution (GitHub) \u00b6 L'ensemble de la plateforme et des outils est partag\u00e9 sur GitHub sous licence Apache 2 . Sources & Projets Licence Issues Contributeurs Pour en savoir plus sur l'organisation des d\u00e9p\u00f4ts, les conventions de code, etc. voir le guide de contribution Tock. Pour tout autre forme de contribution, n'h\u00e9sitez pas \u00e0 utiliser les issues GitHub et \u00e0 contacter directement la communaut\u00e9 avec Gitter. Association TOSIT \u00b6 La solution Tock est actuellement activement \u00e9tudi\u00e9e et exp\u00e9riment\u00e9e par l'association TOSIT (The Open Source I Trust) , une structure de soutien \u00e0 l\u2019Open Source qui vise \u00e0 soutenir l\u2019\u00e9mergence de codes, logiciels et solutions informatiques sous licence open source et/ou licence libre. Fond\u00e9e par Carrefour, EDF, Enedis, Orange, P\u00f4le Emploi et SNCF, TOSIT compte depuis d'autres membres importants comme Le Minist\u00e8re des Arm\u00e9es, Soci\u00e9t\u00e9 G\u00e9n\u00e9rale ou MAIF par exemple. Tock s'inscrit dans le cadre du Groupe de Travail Chatbots du TOSIT. La solution est d'ores et d\u00e9j\u00e0 utilis\u00e9e par plusieurs membres du TOSIT, dont SNCF. Pour en savoir plus, voir le site de l'association : http://tosit.fr/ H\u00e9bergement de la D\u00e9mo publique \u00b6 La plateforme publique de d\u00e9monstration Tock est destin\u00e9e \u00e0 faciliter la prise en main de la solution. Elle est accompagn\u00e9e d'un guide pour faire ses premiers pas. Merci \u00e0 e.Voyageurs SNCF qui h\u00e9berge et maintient cette plateforme de d\u00e9mo en ligne. Plateforme D\u00e9mo en ligne Guide Cr\u00e9er son 1er bot avec Tock Aide \u00b6 Que ce soit pour de l'aide, des questions, des suggestions : n'h\u00e9sitez pas \u00e0 nous contacter .","title":"Communaut\u00e9"},{"location":"apropos/communaute/#communaute-tock","text":"Tock est b\u00e2ti sur un mod\u00e8le communautaire pour cr\u00e9er une plateforme ouverte. Pour en savoir plus, voir pourquoi Tock . La communaut\u00e9 Tock est ouverte \u00e0 la contribution et tous les retours comme les feature requests et pull requests sont les bienvenus !","title":"Communaut\u00e9 Tock"},{"location":"apropos/communaute/#rejoindre-la-communaute-gitter","text":"La plupart des utilisateurs et contributeurs Tock se retrouvent sur la messagerie instantann\u00e9e Gitter . C'est un bon moyen de voir \u00e0 quel point la communaut\u00e9 est active et accessible. Communaut\u00e9 Tock sur Gitter Fil Gitter des releases Tock","title":"Rejoindre la communaut\u00e9 (Gitter)"},{"location":"apropos/communaute/#suivre-lactualite-de-la-plateforme","text":"Pour suivre l'actualit\u00e9 des projets Tock mais aussi les meetups, conf\u00e9rences, etc., rendez-vous sur le site principal : Tock.ai Vous pouvez \u00e9galement retrouver les nouveaut\u00e9s dans ces pages plus sp\u00e9cfiques : Projets & utilisateurs connus Pr\u00e9sentations & conf\u00e9rences Prix & r\u00e9compenses Enfin, pour suivre les versions et fonctionnalit\u00e9s de Tock : Fil Gitter des releases & features Release Notes Roadmap","title":"Suivre l'actualit\u00e9 de la plateforme"},{"location":"apropos/communaute/#code-contribution-github","text":"L'ensemble de la plateforme et des outils est partag\u00e9 sur GitHub sous licence Apache 2 . Sources & Projets Licence Issues Contributeurs Pour en savoir plus sur l'organisation des d\u00e9p\u00f4ts, les conventions de code, etc. voir le guide de contribution Tock. Pour tout autre forme de contribution, n'h\u00e9sitez pas \u00e0 utiliser les issues GitHub et \u00e0 contacter directement la communaut\u00e9 avec Gitter.","title":"Code &amp; Contribution (GitHub)"},{"location":"apropos/communaute/#association-tosit","text":"La solution Tock est actuellement activement \u00e9tudi\u00e9e et exp\u00e9riment\u00e9e par l'association TOSIT (The Open Source I Trust) , une structure de soutien \u00e0 l\u2019Open Source qui vise \u00e0 soutenir l\u2019\u00e9mergence de codes, logiciels et solutions informatiques sous licence open source et/ou licence libre. Fond\u00e9e par Carrefour, EDF, Enedis, Orange, P\u00f4le Emploi et SNCF, TOSIT compte depuis d'autres membres importants comme Le Minist\u00e8re des Arm\u00e9es, Soci\u00e9t\u00e9 G\u00e9n\u00e9rale ou MAIF par exemple. Tock s'inscrit dans le cadre du Groupe de Travail Chatbots du TOSIT. La solution est d'ores et d\u00e9j\u00e0 utilis\u00e9e par plusieurs membres du TOSIT, dont SNCF. Pour en savoir plus, voir le site de l'association : http://tosit.fr/","title":"Association TOSIT"},{"location":"apropos/communaute/#hebergement-de-la-demo-publique","text":"La plateforme publique de d\u00e9monstration Tock est destin\u00e9e \u00e0 faciliter la prise en main de la solution. Elle est accompagn\u00e9e d'un guide pour faire ses premiers pas. Merci \u00e0 e.Voyageurs SNCF qui h\u00e9berge et maintient cette plateforme de d\u00e9mo en ligne. Plateforme D\u00e9mo en ligne Guide Cr\u00e9er son 1er bot avec Tock","title":"H\u00e9bergement de la D\u00e9mo publique"},{"location":"apropos/communaute/#aide","text":"Que ce soit pour de l'aide, des questions, des suggestions : n'h\u00e9sitez pas \u00e0 nous contacter .","title":"Aide"},{"location":"apropos/contact/","text":"Nous contacter \u00b6 D\u00e9veloppeurs, utilisateurs ou juste curieux, n'h\u00e9sitez pas \u00e0 contacter les cr\u00e9ateurs de la solution et d'autres membres de la communaut\u00e9 pour \u00e9changer sur Tock. Vous pouvez nous retrouver sur Gitter (la messagerie instantann\u00e9e pour GitHub) : https://gitter.im/tockchat/Lobby Les issues GitHub permettent aussi de remonter une anomalie ou proposer une \u00e9volution : https://github.com/theopenconversationkit/tock/issues","title":"Nous contacter"},{"location":"apropos/contact/#nous-contacter","text":"D\u00e9veloppeurs, utilisateurs ou juste curieux, n'h\u00e9sitez pas \u00e0 contacter les cr\u00e9ateurs de la solution et d'autres membres de la communaut\u00e9 pour \u00e9changer sur Tock. Vous pouvez nous retrouver sur Gitter (la messagerie instantann\u00e9e pour GitHub) : https://gitter.im/tockchat/Lobby Les issues GitHub permettent aussi de remonter une anomalie ou proposer une \u00e9volution : https://github.com/theopenconversationkit/tock/issues","title":"Nous contacter"},{"location":"apropos/contribuer/","text":"Contribuer \u00e0 Tock \u00b6 Le projet Tock est ouvert \u00e0 la contribution et toute proposition est la bienvenue ! Cette page donne des indications sur la structure et les conventions du code de la plateforme. TL;DR \u00b6 Voir CONTRIBUTING.md (anglais uniquement). Principales technologies \u00b6 L'ensemble de la plateforme peut fonctionner conteneuris\u00e9e (impl\u00e9mentation Docker fournie). La plateforme applicative par d\u00e9faut est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. C\u00f4t\u00e9 serveur, Tock utilise Vert.x et MongoDB (alt. DocumentDB ) . Diff\u00e9rentes briques NLU peuvent \u00eatre utilis\u00e9es, mais Tock n'a pas de d\u00e9pendance forte envers l'une d'elles. Les interfaces graphiques Tock Studio sont \u00e9crites avec Angular en Typescript . Des int\u00e9grations React et Flutter sont fournies pour les interfaces Web et Mobile. Structure des sources \u00b6 Les d\u00e9p\u00f4ts \u00b6 tock : d\u00e9p\u00f4t principal comprend le framework et les composants de la plateforme sous licence Apache 2 . tock-corenlp : code utilisant une d\u00e9pendance optionnelle \u00e0 Stanford CoreNLP (\u00e0 la place d' Apache OpenNLP ), sous licence GPL . tock-docker : des images Docker et Docker Compose , pour faciliter la prise en main et le d\u00e9ploiement de la plateforme dans diff\u00e9rentes configurations. tock-bot-samples : des exemples de code notamment pour programmer des parcours en mode WebHook ou WebSocket comme dans les guides Tock . tock-bot-open-data : un exemple de bot bas\u00e9 sur les API Open Data de la SNCF , impl\u00e9mentant \u00e9galement des bases pour l'internationalisation avec deux langues propos\u00e9es. Le d\u00e9p\u00f4t tock \u00b6 Voici une premi\u00e8re description des sources dans le d\u00e9p\u00f4t tock : bot : la plateforme conversationnelle (interfaces, API, connecteurs, etc.), en d\u00e9pendance sur les modules NLU docs : le sites de documentation, g\u00e9n\u00e9r\u00e9s avec MkDocs docs-mk : les sources pour les sites de documentation, pour MkDocs dokka : la documentation Dokka du framework Kotlin etc : des scripts utilitaires, par exemple pour g\u00e9n\u00e9rer les sites avec MkDocs nlp : la plateforme NLU uniquement (interfaces, API, mod\u00e8les d'entit\u00e9s, etc.) scripts : d'autres scripts utilitaires, par exemple pour d\u00e9velopper sur Messenger avec ngrok shared : des composants Kotlin partag\u00e9s entre les diff\u00e9rents modules du framework stt : des impl\u00e9mentations et wrappers pour le speech-to-text translator : des impl\u00e9mentations et wrappers pour le multilingue ( i18n ) Remarque : il existe \"deux admin \" (ie. deux interfaces Tock Studio ) dans les sources. En effet, il est possible d'installer la plateforme NLU / NLP seule sans les outils conversationnels. En cons\u00e9quence : nlp/admin : contient les composants et interfaces graphiques pour le NLU / NLP seulement bot/admin : reprend les composants NLP / NLU (en d\u00e9pendance dans le build Maven) et reconstruit les interfaces en y ajoutant les outils conversationnels Le d\u00e9p\u00f4t tock-docker \u00b6 Le d\u00e9p\u00f4t contient une structure de modules Maven reprenant les diff\u00e9rents composants de la plateforme Tock. Chacun de ces modules porte une impl\u00e9mentation Docker du composant en s'appuie sur le plugin Maven io.fabric8:docker-maven-plugin pour encapsuler le build Docker. A la racine du d\u00e9p\u00f4t se trouvent diff\u00e9rents descripteurs Docker Compose permettant de d\u00e9ployer une plateforme en se basant sur les images d\u00e9j\u00e0 construites. Diff\u00e9rentes configurations existent, notamment en mode Bot API ou en mode int\u00e9gr\u00e9 , avec la plateforme NLU standalone, etc. Le descripteur de r\u00e9f\u00e9rence pour le mode Bot API est docker-compose-bot.yml . Build & run \u00b6 Construire Tock \u00e0 partir des sources \u00b6 Tock (core) \u00b6 Le projet est construit avec Maven , y compris les modules Web impliquant NPM et Angular : $ mvn package Un build d'int\u00e9gration continue est disponible sur Travis . Images Docker \u00b6 Les images Docker de Tock peuvent \u00eatre reconstruites \u00e0 partir des sources du d\u00e9p\u00f4t tock-docker . Pour cela, utilisez Maven qui d\u00e9clenchera le build Docker : $ mvn package docker:build Vous pouvez ensuite instancier ces images via Docker ou les stacks Docker Compose avec les descripteurs \u00e0 la racine du d\u00e9p\u00f4t. Ex\u00e9cuter dans un IDE \u00b6 Pour d\u00e9marrer Tock avec Docker Compose hors d'un IDE, voir D\u00e9ployer Tock avec Docker . Les diff\u00e9rents composants Tock peuvent s'ex\u00e9cuter depuis un IDE (environnement de d\u00e9veloppement int\u00e9gr\u00e9). Des configurations sont fournies pour IntelliJ . Voir la section Installation Tock . Pour ex\u00e9cuter le bot/exemple en mode int\u00e9gr\u00e9, une configuration est aussi disponible : OpenDataBot . Code \u00b6 Commits & merge requests \u00b6 Pour soumettre une \u00e9volution ou un correctif : Cr\u00e9er une issue : Format recommand\u00e9 pour le titre : [Component] Title De pr\u00e9f\u00e9rence en anglais Composant : par exemple Studio , Core , Doc , etc. Titre : par exemple Do or fix something Cr\u00e9er une pull request et la lier \u00e0 l' issue : Tous les commits doivent \u00eatre sign\u00e9s SVP rebase ou squash les commits superflus Astuce : vous pouvez noter la PR comme Draft avant de la soumettre Format recommand\u00e9 pour le nom de la branche : ISSUEID_short_title Format recommand\u00e9 pour le(s) message(s) de commit(s) : resolves #ISSUEID Component: title pour les \u00e9volutions fixes #ISSUEID Component: title pour les correctifs Avant d'\u00eatre int\u00e9gr\u00e9e, une pull request doit passer les tests et \u00eatre approuv\u00e9e par au moins deux de ces d\u00e9veloppeurs : @vsct-jburet , @francoisno , @NainJaune , @elebescond , @SarukaUsagi , @MaximeLeFrancois , @bakic , @broxmik , @mrboizo Conventions de code \u00b6 Les Kotlin Code Conventions sont utilis\u00e9es pour d\u00e9velopper le code de Tock. Tests unitaires \u00b6 Chaque nouvelle \u00e9volution ou correctif devrait embarquer ses tests unitaires. Nous contacter \u00b6 Un probl\u00e8me ? Une question sur l'impl\u00e9mentation ? Une id\u00e9e \u00e0 partager ? Pour contribuer au projet ou simplement en savoir plus, n'h\u00e9sitez pas \u00e0 nous contacter .","title":"Contribuer"},{"location":"apropos/contribuer/#contribuer-a-tock","text":"Le projet Tock est ouvert \u00e0 la contribution et toute proposition est la bienvenue ! Cette page donne des indications sur la structure et les conventions du code de la plateforme.","title":"Contribuer \u00e0 Tock"},{"location":"apropos/contribuer/#tldr","text":"Voir CONTRIBUTING.md (anglais uniquement).","title":"TL;DR"},{"location":"apropos/contribuer/#principales-technologies","text":"L'ensemble de la plateforme peut fonctionner conteneuris\u00e9e (impl\u00e9mentation Docker fournie). La plateforme applicative par d\u00e9faut est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. C\u00f4t\u00e9 serveur, Tock utilise Vert.x et MongoDB (alt. DocumentDB ) . Diff\u00e9rentes briques NLU peuvent \u00eatre utilis\u00e9es, mais Tock n'a pas de d\u00e9pendance forte envers l'une d'elles. Les interfaces graphiques Tock Studio sont \u00e9crites avec Angular en Typescript . Des int\u00e9grations React et Flutter sont fournies pour les interfaces Web et Mobile.","title":"Principales technologies"},{"location":"apropos/contribuer/#structure-des-sources","text":"","title":"Structure des sources"},{"location":"apropos/contribuer/#les-depots","text":"tock : d\u00e9p\u00f4t principal comprend le framework et les composants de la plateforme sous licence Apache 2 . tock-corenlp : code utilisant une d\u00e9pendance optionnelle \u00e0 Stanford CoreNLP (\u00e0 la place d' Apache OpenNLP ), sous licence GPL . tock-docker : des images Docker et Docker Compose , pour faciliter la prise en main et le d\u00e9ploiement de la plateforme dans diff\u00e9rentes configurations. tock-bot-samples : des exemples de code notamment pour programmer des parcours en mode WebHook ou WebSocket comme dans les guides Tock . tock-bot-open-data : un exemple de bot bas\u00e9 sur les API Open Data de la SNCF , impl\u00e9mentant \u00e9galement des bases pour l'internationalisation avec deux langues propos\u00e9es.","title":"Les d\u00e9p\u00f4ts"},{"location":"apropos/contribuer/#le-depot-tock","text":"Voici une premi\u00e8re description des sources dans le d\u00e9p\u00f4t tock : bot : la plateforme conversationnelle (interfaces, API, connecteurs, etc.), en d\u00e9pendance sur les modules NLU docs : le sites de documentation, g\u00e9n\u00e9r\u00e9s avec MkDocs docs-mk : les sources pour les sites de documentation, pour MkDocs dokka : la documentation Dokka du framework Kotlin etc : des scripts utilitaires, par exemple pour g\u00e9n\u00e9rer les sites avec MkDocs nlp : la plateforme NLU uniquement (interfaces, API, mod\u00e8les d'entit\u00e9s, etc.) scripts : d'autres scripts utilitaires, par exemple pour d\u00e9velopper sur Messenger avec ngrok shared : des composants Kotlin partag\u00e9s entre les diff\u00e9rents modules du framework stt : des impl\u00e9mentations et wrappers pour le speech-to-text translator : des impl\u00e9mentations et wrappers pour le multilingue ( i18n ) Remarque : il existe \"deux admin \" (ie. deux interfaces Tock Studio ) dans les sources. En effet, il est possible d'installer la plateforme NLU / NLP seule sans les outils conversationnels. En cons\u00e9quence : nlp/admin : contient les composants et interfaces graphiques pour le NLU / NLP seulement bot/admin : reprend les composants NLP / NLU (en d\u00e9pendance dans le build Maven) et reconstruit les interfaces en y ajoutant les outils conversationnels","title":"Le d\u00e9p\u00f4t tock"},{"location":"apropos/contribuer/#le-depot-tock-docker","text":"Le d\u00e9p\u00f4t contient une structure de modules Maven reprenant les diff\u00e9rents composants de la plateforme Tock. Chacun de ces modules porte une impl\u00e9mentation Docker du composant en s'appuie sur le plugin Maven io.fabric8:docker-maven-plugin pour encapsuler le build Docker. A la racine du d\u00e9p\u00f4t se trouvent diff\u00e9rents descripteurs Docker Compose permettant de d\u00e9ployer une plateforme en se basant sur les images d\u00e9j\u00e0 construites. Diff\u00e9rentes configurations existent, notamment en mode Bot API ou en mode int\u00e9gr\u00e9 , avec la plateforme NLU standalone, etc. Le descripteur de r\u00e9f\u00e9rence pour le mode Bot API est docker-compose-bot.yml .","title":"Le d\u00e9p\u00f4t tock-docker"},{"location":"apropos/contribuer/#build-run","text":"","title":"Build &amp; run"},{"location":"apropos/contribuer/#construire-tock-a-partir-des-sources","text":"","title":"Construire Tock \u00e0 partir des sources"},{"location":"apropos/contribuer/#tock-core","text":"Le projet est construit avec Maven , y compris les modules Web impliquant NPM et Angular : $ mvn package Un build d'int\u00e9gration continue est disponible sur Travis .","title":"Tock (core)"},{"location":"apropos/contribuer/#images-docker","text":"Les images Docker de Tock peuvent \u00eatre reconstruites \u00e0 partir des sources du d\u00e9p\u00f4t tock-docker . Pour cela, utilisez Maven qui d\u00e9clenchera le build Docker : $ mvn package docker:build Vous pouvez ensuite instancier ces images via Docker ou les stacks Docker Compose avec les descripteurs \u00e0 la racine du d\u00e9p\u00f4t.","title":"Images Docker"},{"location":"apropos/contribuer/#executer-dans-un-ide","text":"Pour d\u00e9marrer Tock avec Docker Compose hors d'un IDE, voir D\u00e9ployer Tock avec Docker . Les diff\u00e9rents composants Tock peuvent s'ex\u00e9cuter depuis un IDE (environnement de d\u00e9veloppement int\u00e9gr\u00e9). Des configurations sont fournies pour IntelliJ . Voir la section Installation Tock . Pour ex\u00e9cuter le bot/exemple en mode int\u00e9gr\u00e9, une configuration est aussi disponible : OpenDataBot .","title":"Ex\u00e9cuter dans un IDE"},{"location":"apropos/contribuer/#code","text":"","title":"Code"},{"location":"apropos/contribuer/#commits-merge-requests","text":"Pour soumettre une \u00e9volution ou un correctif : Cr\u00e9er une issue : Format recommand\u00e9 pour le titre : [Component] Title De pr\u00e9f\u00e9rence en anglais Composant : par exemple Studio , Core , Doc , etc. Titre : par exemple Do or fix something Cr\u00e9er une pull request et la lier \u00e0 l' issue : Tous les commits doivent \u00eatre sign\u00e9s SVP rebase ou squash les commits superflus Astuce : vous pouvez noter la PR comme Draft avant de la soumettre Format recommand\u00e9 pour le nom de la branche : ISSUEID_short_title Format recommand\u00e9 pour le(s) message(s) de commit(s) : resolves #ISSUEID Component: title pour les \u00e9volutions fixes #ISSUEID Component: title pour les correctifs Avant d'\u00eatre int\u00e9gr\u00e9e, une pull request doit passer les tests et \u00eatre approuv\u00e9e par au moins deux de ces d\u00e9veloppeurs : @vsct-jburet , @francoisno , @NainJaune , @elebescond , @SarukaUsagi , @MaximeLeFrancois , @bakic , @broxmik , @mrboizo","title":"Commits &amp; merge requests"},{"location":"apropos/contribuer/#conventions-de-code","text":"Les Kotlin Code Conventions sont utilis\u00e9es pour d\u00e9velopper le code de Tock.","title":"Conventions de code"},{"location":"apropos/contribuer/#tests-unitaires","text":"Chaque nouvelle \u00e9volution ou correctif devrait embarquer ses tests unitaires.","title":"Tests unitaires"},{"location":"apropos/contribuer/#nous-contacter","text":"Un probl\u00e8me ? Une question sur l'impl\u00e9mentation ? Une id\u00e9e \u00e0 partager ? Pour contribuer au projet ou simplement en savoir plus, n'h\u00e9sitez pas \u00e0 nous contacter .","title":"Nous contacter"},{"location":"apropos/emploi/","text":"Emplois Tock \u00b6 Int\u00e9ress\u00e9(e) par travailler avec Tock et contribuer \u00e0 la plateforme ? Cette page recense des entreprises et organisations proposants des offres d'emploi dans le domaine conversationnel avec Tock : e.Voyageurs SNCF (\u00e0 l'origine du projet) recrute pour d\u00e9velopper des assistants conversationnels avec Tock. Pour en savoir plus, rendez-vous sur Gitter ou sur https://jobs.oui.sncf/ . Vous utilisez Tock et proposez des offres d'emploi en conversationnel ? N'h\u00e9sitez pas \u00e0 nous le signaler pour enrichir cette liste.","title":"Emploi"},{"location":"apropos/emploi/#emplois-tock","text":"Int\u00e9ress\u00e9(e) par travailler avec Tock et contribuer \u00e0 la plateforme ? Cette page recense des entreprises et organisations proposants des offres d'emploi dans le domaine conversationnel avec Tock : e.Voyageurs SNCF (\u00e0 l'origine du projet) recrute pour d\u00e9velopper des assistants conversationnels avec Tock. Pour en savoir plus, rendez-vous sur Gitter ou sur https://jobs.oui.sncf/ . Vous utilisez Tock et proposez des offres d'emploi en conversationnel ? N'h\u00e9sitez pas \u00e0 nous le signaler pour enrichir cette liste.","title":"Emplois Tock"},{"location":"apropos/pourquoi/","text":"Pourquoi Tock ? \u00b6 Initi\u00e9 en 2016 par l'\u00e9quipe Innovation chez OUI.sncf afin de motoriser l'analyse des commandes vocales sur ses applications mobiles , le framework fut ensuite utilis\u00e9 pour cr\u00e9er son bot Messenger , avant d'\u00eatre \u00e9tendu \u00e0 de nombreux canaux et d'accueillir d'autres bots pour de nouveaux cas d'usage. A ses d\u00e9buts, la plateforme donnait des r\u00e9sultats similaires \u00e0 ceux obtenus avec diff\u00e9rentes solutions du march\u00e9, tout en restant en ma\u00eetrise du code (embarquant des biblioth\u00e8ques opensource issues du domaine universitaire), en \u00e9vitant les effets \"bo\u00eete noire\" (notamment pour d\u00e9bugger les mod\u00e8les conversationnels) pour une r\u00e9activit\u00e9 accrue. Depuis, l'\u00e9quipe derri\u00e8re OUIbot ainsi que d'autres \u00e9quipes d\u00e9di\u00e9es \u00e0 diff\u00e9rents assistants conversationnels SNCF (cf la vitrine ) utilisent quotidiennement Tock en production, tout en enrichissant r\u00e9guli\u00e8rement la plateforme de nouvelles fonctionnalit\u00e9s et connecteurs. Nous pensons qu'il y a un besoin de plateformes conversationnelles et IA ouvertes , permettant des sc\u00e9narios techniques et m\u00e9tier vari\u00e9s tout en restant en ma\u00eetrise du code , l'utilisateur \u00e9tant propri\u00e9taire de ses mod\u00e8les et de ses donn\u00e9es . De plus en plus d'acteurs, petites et grandes entreprises en France et \u00e0 l'international, partagent cette vision et ce besoin pour leurs propres projets. L'ensemble de la solution Tock est partag\u00e9 avec la communaut\u00e9 opensource dans le but de f\u00e9d\u00e9rer et mutualiser l'effort des cr\u00e9ateurs d'assistants. Depuis 2019, Tock est pr\u00e9conis\u00e9 en interne par le groupe SNCF. L'outil est \u00e9galement utilis\u00e9 en production par d'autres entreprises (voir vitrine ). A terme, nous pensons que la solution Tock a vocation \u00e0 rejoindre une association comme le TOSIT (The Open Source I Trust) , une fondation Open Source ou un consortium.","title":"Pourquoi Tock"},{"location":"apropos/pourquoi/#pourquoi-tock","text":"Initi\u00e9 en 2016 par l'\u00e9quipe Innovation chez OUI.sncf afin de motoriser l'analyse des commandes vocales sur ses applications mobiles , le framework fut ensuite utilis\u00e9 pour cr\u00e9er son bot Messenger , avant d'\u00eatre \u00e9tendu \u00e0 de nombreux canaux et d'accueillir d'autres bots pour de nouveaux cas d'usage. A ses d\u00e9buts, la plateforme donnait des r\u00e9sultats similaires \u00e0 ceux obtenus avec diff\u00e9rentes solutions du march\u00e9, tout en restant en ma\u00eetrise du code (embarquant des biblioth\u00e8ques opensource issues du domaine universitaire), en \u00e9vitant les effets \"bo\u00eete noire\" (notamment pour d\u00e9bugger les mod\u00e8les conversationnels) pour une r\u00e9activit\u00e9 accrue. Depuis, l'\u00e9quipe derri\u00e8re OUIbot ainsi que d'autres \u00e9quipes d\u00e9di\u00e9es \u00e0 diff\u00e9rents assistants conversationnels SNCF (cf la vitrine ) utilisent quotidiennement Tock en production, tout en enrichissant r\u00e9guli\u00e8rement la plateforme de nouvelles fonctionnalit\u00e9s et connecteurs. Nous pensons qu'il y a un besoin de plateformes conversationnelles et IA ouvertes , permettant des sc\u00e9narios techniques et m\u00e9tier vari\u00e9s tout en restant en ma\u00eetrise du code , l'utilisateur \u00e9tant propri\u00e9taire de ses mod\u00e8les et de ses donn\u00e9es . De plus en plus d'acteurs, petites et grandes entreprises en France et \u00e0 l'international, partagent cette vision et ce besoin pour leurs propres projets. L'ensemble de la solution Tock est partag\u00e9 avec la communaut\u00e9 opensource dans le but de f\u00e9d\u00e9rer et mutualiser l'effort des cr\u00e9ateurs d'assistants. Depuis 2019, Tock est pr\u00e9conis\u00e9 en interne par le groupe SNCF. L'outil est \u00e9galement utilis\u00e9 en production par d'autres entreprises (voir vitrine ). A terme, nous pensons que la solution Tock a vocation \u00e0 rejoindre une association comme le TOSIT (The Open Source I Trust) , une fondation Open Source ou un consortium.","title":"Pourquoi Tock ?"},{"location":"apropos/recompenses/","text":"Prix et r\u00e9compenses \u00b6 Depuis sa cr\u00e9ation pour OUI.sncf en 2016 jusqu'au service AlloCovid en 2020, la solution technique et les bots cr\u00e9\u00e9s avec Tock ont \u00e9t\u00e9 r\u00e9compens\u00e9s par plusieurs prix. Un grand merci aux organisateurs de ces \u00e9v\u00e9nements, aux entreprises qui soutiennent Tock (notamment SNCF et TOSIT) ainsi qu'\u00e0 la communaut\u00e9 \ud83d\ude42 Meilleure Strat\u00e9gie Open Source 2019 (SNCF) \u00b6 En d\u00e9cembre 2019, le prix Les Acteurs du Libre de la Meilleure Strat\u00e9gie Open Source a r\u00e9compens\u00e9 la SNCF pour sa d\u00e9marche et le partage de plateformes ouvertes comme Tock (filiale e.Voyageurs) et Navitia (filiale Kisio Digital). La remise du prix \u00e0 Simon Clavier et Fran\u00e7ois Nollen eut lieu le 10 d\u00e9cembre dans le Grand Auditorium du Paris Open Source Summit . Quelques photos et la captation vid\u00e9o sont disponibles. Pour en savoir plus, voir aussi Les Acteurs Du Libre . Best Robot Experience 2019 (OUI.sncf) \u00b6 En 2019, OUIbot a re\u00e7u le prix Best Robot Experience pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive. Re\u00e7u par Caroline Chupin et Evelyne Papon pour OUI.sncf, le prix a d\u00e9partag\u00e9 cette fois pas moins de 31 robots, chatbots et voicebots. Une interview est disponible en ligne . Voir aussi le blog Cultures Services . Best Robot Experience 2018 (OUI.sncf) \u00b6 En 2018, OUIbot l'assistant OUI.sncf qui accompagne pr\u00e8s de 10 000 utilisateurs par jour a \u00e9t\u00e9 \u00e9lu Best Robot Experience par l' Acad\u00e9mie du Service / Sens du client . Le prix remis \u00e0 Caroline Chupin pour OUI.sncf a d\u00e9partag\u00e9 24 agents virtuels propos\u00e9s par des organisations prestigieuses (grandes entreprises, GAFAM, minist\u00e8res) sur la base de crit\u00e8res comme la rapidit\u00e9, la logique et la simplicit\u00e9. Pour en savoir plus, voir le blog Sens du client .","title":"Prix et r\u00e9compenses"},{"location":"apropos/recompenses/#prix-et-recompenses","text":"Depuis sa cr\u00e9ation pour OUI.sncf en 2016 jusqu'au service AlloCovid en 2020, la solution technique et les bots cr\u00e9\u00e9s avec Tock ont \u00e9t\u00e9 r\u00e9compens\u00e9s par plusieurs prix. Un grand merci aux organisateurs de ces \u00e9v\u00e9nements, aux entreprises qui soutiennent Tock (notamment SNCF et TOSIT) ainsi qu'\u00e0 la communaut\u00e9 \ud83d\ude42","title":"Prix et r\u00e9compenses"},{"location":"apropos/recompenses/#meilleure-strategie-open-source-2019-sncf","text":"En d\u00e9cembre 2019, le prix Les Acteurs du Libre de la Meilleure Strat\u00e9gie Open Source a r\u00e9compens\u00e9 la SNCF pour sa d\u00e9marche et le partage de plateformes ouvertes comme Tock (filiale e.Voyageurs) et Navitia (filiale Kisio Digital). La remise du prix \u00e0 Simon Clavier et Fran\u00e7ois Nollen eut lieu le 10 d\u00e9cembre dans le Grand Auditorium du Paris Open Source Summit . Quelques photos et la captation vid\u00e9o sont disponibles. Pour en savoir plus, voir aussi Les Acteurs Du Libre .","title":"Meilleure Strat\u00e9gie Open Source 2019 (SNCF)"},{"location":"apropos/recompenses/#best-robot-experience-2019-ouisncf","text":"En 2019, OUIbot a re\u00e7u le prix Best Robot Experience pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive. Re\u00e7u par Caroline Chupin et Evelyne Papon pour OUI.sncf, le prix a d\u00e9partag\u00e9 cette fois pas moins de 31 robots, chatbots et voicebots. Une interview est disponible en ligne . Voir aussi le blog Cultures Services .","title":"Best Robot Experience 2019 (OUI.sncf)"},{"location":"apropos/recompenses/#best-robot-experience-2018-ouisncf","text":"En 2018, OUIbot l'assistant OUI.sncf qui accompagne pr\u00e8s de 10 000 utilisateurs par jour a \u00e9t\u00e9 \u00e9lu Best Robot Experience par l' Acad\u00e9mie du Service / Sens du client . Le prix remis \u00e0 Caroline Chupin pour OUI.sncf a d\u00e9partag\u00e9 24 agents virtuels propos\u00e9s par des organisations prestigieuses (grandes entreprises, GAFAM, minist\u00e8res) sur la base de crit\u00e8res comme la rapidit\u00e9, la logique et la simplicit\u00e9. Pour en savoir plus, voir le blog Sens du client .","title":"Best Robot Experience 2018 (OUI.sncf)"},{"location":"apropos/ressources/","text":"Ressources Tock \u00b6 Les diff\u00e9rents supports et pr\u00e9sentations ci-dessous donnent un aper\u00e7u de la solution Tock, en compl\u00e9ment des guides pour tester soi-m\u00eame la plateforme. Conf\u00e9rences / video \u00b6 Tock & M\u00e9lusine @ AI Paris 2020 (REX SNCF & MAIF) \ud83d\udd33 slides Conversationnel & Open Source @ Paris Open Source Summit 2019 (REX SNCF & invit\u00e9s EDF, Enedis, Orange, SogetiLabs, TOSIT) \ud83d\udcfd\ufe0f 30 min / \ud83d\udd33 slides D\u00e9velopper un bot sur Messenger et Google Assistant en 30 minutes @ Devoxx France 2018 (live coding \"tools in action\" ) \ud83d\udcfd\ufe0f 30 min Supports de pr\u00e9sentation / meetup \u00b6 Tock - The Open Conversation Kit @ Meetup Open Transport (2019) Tock - The Open Conversation Kit @ CRiP OpenSource & Co-d\u00e9veloppement (2017) N'h\u00e9sitez pas \u00e0 partager d'autres supports et liens autour de Tock. Kit presse \u00b6 Comme le reste des sources Tock, les logos sont disponibles sous licence Apache 2 . Logo Tock - couleurs par d\u00e9faut / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - bleu / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - noir / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - blanc / transparent ( t\u00e9l\u00e9charger ) :","title":"Ressources"},{"location":"apropos/ressources/#ressources-tock","text":"Les diff\u00e9rents supports et pr\u00e9sentations ci-dessous donnent un aper\u00e7u de la solution Tock, en compl\u00e9ment des guides pour tester soi-m\u00eame la plateforme.","title":"Ressources Tock"},{"location":"apropos/ressources/#conferences-video","text":"Tock & M\u00e9lusine @ AI Paris 2020 (REX SNCF & MAIF) \ud83d\udd33 slides Conversationnel & Open Source @ Paris Open Source Summit 2019 (REX SNCF & invit\u00e9s EDF, Enedis, Orange, SogetiLabs, TOSIT) \ud83d\udcfd\ufe0f 30 min / \ud83d\udd33 slides D\u00e9velopper un bot sur Messenger et Google Assistant en 30 minutes @ Devoxx France 2018 (live coding \"tools in action\" ) \ud83d\udcfd\ufe0f 30 min","title":"Conf\u00e9rences / video"},{"location":"apropos/ressources/#supports-de-presentation-meetup","text":"Tock - The Open Conversation Kit @ Meetup Open Transport (2019) Tock - The Open Conversation Kit @ CRiP OpenSource & Co-d\u00e9veloppement (2017) N'h\u00e9sitez pas \u00e0 partager d'autres supports et liens autour de Tock.","title":"Supports de pr\u00e9sentation / meetup"},{"location":"apropos/ressources/#kit-presse","text":"Comme le reste des sources Tock, les logos sont disponibles sous licence Apache 2 . Logo Tock - couleurs par d\u00e9faut / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - bleu / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - noir / transparent ( t\u00e9l\u00e9charger ) : Logo Tock - blanc / transparent ( t\u00e9l\u00e9charger ) :","title":"Kit presse"},{"location":"apropos/vitrine/","text":"Vitrine utilisateurs \u00b6 Depuis sa cr\u00e9ation pour OUI.sncf en 2016 jusqu'au service AlloCovid en 2020, Tock est utilis\u00e9 par de plus en plus d'\u00e9quipes (notamment SNCF mais pas uniquement) pour cr\u00e9er des bots conversationnels d\u00e9di\u00e9s \u00e0 des usages divers : business to customer et business to business distribution, transactionnel, paiement assistance, care , help desks FAQ et arbres de d\u00e9cision Cette page pr\u00e9sente diff\u00e9rents assistants et produits connus construits avec Tock, dont certains ont \u00e9t\u00e9 r\u00e9compens\u00e9s par la communaut\u00e9. AlloCovid \u00b6 Le service AlloCovid permet d'informer et d'orienter la population sur le Covid-19, reprenant le questionnaire pr\u00e9d\u00e9fini par le Minist\u00e8re de la Sant\u00e9. IA vocale engag\u00e9e dans la crise sanitaire Ce service conversationnel est le fruit de la collaboration de nombreux experts fran\u00e7ais, partenaires technologiques et b\u00e9n\u00e9voles. Pour en savoir sur la g\u00e9n\u00e8se du projet, l'\u00e9quipe et les partenaires, le fonctionnement du bot, la presse, etc. rendez-vous sur www.allocovid.com . Disponible par t\u00e9l\u00e9phone, sur le Web et WhatsApp, AlloCovid est construit autour d'un bot Tock et int\u00e8gre des solutions compl\u00e9mentaires comme les technologies vocales Allo-Media et Voxygen . Le bot AlloCovid est construit autour de technologies open source (\u00e0 travers la plateforme Tock), et lui-m\u00eame open source : les sources du bot sont disponibles sur le d\u00e9p\u00f4t allocovid . Avec les sources du bot on trouve \u00e9galement celles du connecteur Allo-Media , quelques explications techniques sur le bot et la sp\u00e9cification fonctionnelle du questionnaire Covid. Nom : AlloCovid Date de naissance : en production au printemps 2020 Domaine : informations sanitaires et orientation vers les services de sant\u00e9 Canaux : texte & voix, par t\u00e9l\u00e9phone, sur WhatsApp et site Web OUIbot , le bot OUI.sncf \u00b6 OUIbot est l'assistant conversationnel de OUI.sncf. Disponible depuis 2016 sur le r\u00e9seau social Facebook Messenger, OUIbot s'est construit avec les premi\u00e8res versions de Tock. Avec OUIbot, r\u00e9server un billet de train n'a jamais \u00e9t\u00e9 aussi simple ! Il vous assiste dans la pr\u00e9paration de vos voyages, permet d'effectuer rapidement et simplement une r\u00e9servation compl\u00e8te, de la recherche \u00e0 l'achat (paiement inclus), et vous accompagne durant votre voyage. Gr\u00e2ce aux nombreux connecteurs Tock, OUIbot r\u00e9pond pr\u00e9sent sur de nombreux canaux conversationnels : site www.oui.sncf , r\u00e9seaux sociaux, assistants vocaux, enceintes connect\u00e9es et m\u00eame IAffiches avec JCDecaux . En 2019, OUIbot accompagne pr\u00e8s de 10 000 utilisateurs par jour. Il a \u00e9t\u00e9 \u00e9lu Best Robot Experience pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive. Nom : OUIbot Date de naissance : en production depuis 2016 Domaine : distribution, transactionnel (r\u00e9servations, paiements), alertes & push notifications, relai vers un agent Canaux : texte & voix, sur le site Web entreprise, Messenger, WhatsApp, Business Chat (Messages), Google Assistant, Google Home, Alexa, IAffiches JCDecaux Chatbot interne Enedis \u00b6 Le Chatbot interne Enedis permet aux 39 000 salari\u00e9s Enedis un acc\u00e8s simplifi\u00e9 aux services logistiques de l\u2019entreprise. Cet agent conversationnel intelligent offre un support de 1 er niveau en r\u00e9pondant aux questions les plus fr\u00e9quentes des salari\u00e9s et en orientant vers les outils M\u00e9tiers de gestion de demande. Il a \u00e9galement vocation \u00e0 mieux appr\u00e9hender les besoins des salari\u00e9s via l\u2019analyse des questions fr\u00e9quentes. Construit avec Tock, le chatbot est disponible sur un site Web interne \u00e0 l'entreprise. Nom : Chatbot interne Enedis Date de naissance : en production depuis 2020 Domaine : services logistiques internes Canaux : texte, sur un site Web interne L'Assistant SNCF \u00b6 L'Assistant SNCF est l'application mobile des voyageurs SNCF sur Android et iOS, couvrant le train mais aussi d'autres modes de transport. Avec l\u2019 Assistant SNCF , vous pouvez calculer votre itin\u00e9raire, rester inform\u00e9 en temps r\u00e9el, acheter directement vos tickets de transport ou encore r\u00e9server votre course en VTC. En attendant de nouvelles fonctionnalit\u00e9s \u00e0 venir. Accessible via le \"microphone\" dans l'application mobile, le bot conversationnel de l' Assistant SNCF est construit avec Tock et les fonctions speech-to-text Android et iOS. Nom : L'Assistant SNCF Date de naissance : en production, fonction vocale Tock depuis 2019 Domaine : voyage & transport (recherche itin\u00e9raires en multi-modal, etc.) Canaux : vocal, sur l'application mobile SNCF pour Android et iOS LinTO by Linagora \u00b6 La plateforme LinTO est une bo\u00eete \u00e0 outils Open Source permettant le d\u00e9veloppement et l'int\u00e9gration de processus d\u2019interactions vocales r\u00e9pondant aux besoins des professionnels et de l\u2019industrie. LinTO est un assistant intelligent Open Source con\u00e7u par LINAGORA : bas\u00e9 exclusivement sur des technologies Open Source, LinTO est pr\u00eat pour le cloud mais sans GAFAM (Google-Amazon-Facebook-Apple-Microsoft), et respecte votre vie priv\u00e9e sans partager vos donn\u00e9es pour usage commercial. LinTO utilise l'IA pour capter votre voix et vous aider tout au long de la journ\u00e9e, m\u00eame en r\u00e9union, \u00e0 r\u00e9duire les t\u00e2ches stressantes ou chronophages : gestion d'agenda, rappels, prise de notes, emails, m\u00e9t\u00e9o, trafic, dictionnaire , actualit\u00e9s, etc. Le projet de recherche est subventionn\u00e9 par le PIA (Programme d'Investissement d'Avenir) de l'\u00e9tat Fran\u00e7ais dans le cadre des Grands D\u00e9fis du num\u00e9rique. Il allie des entreprises technologiques telles que LINAGORA et ZELROS et des laboratoires de recherche comme l'IRIT, le LaaS, le CNRS et le laboratoire de recherche en informatique de l'\u00e9cole polytechnique. Le service LinTO NLU (Natural Language Understanding) est bas\u00e9 sur Tock et permet l\u2019utilisation de plusieurs mod\u00e8les IA d\u00e9di\u00e9s \u00e0 des cas d\u2019utilisation sp\u00e9cifiques. Il apprend automatiquement selon les usages lors de l\u2019ajout ou suppression de comp\u00e9tences ( Skills ) \u00e0 la plateforme. Nom : LinTO Date de naissance : en production avec Tock depuis 2019 Domaine : assistant personnel pour les entreprises (agenda, emails, prise de notes, etc.) Canaux : vocal (portabilit\u00e9 Raspberry Pi, ARM, Android, Web...) Tilien , le chatbot Transilien \u00b6 Tilien est le chatbot Transilien sur Messenger. Con\u00e7u comme un compagnon de voyage personnel et amical, il informe des prochains d\u00e9parts, l'\u00e9tat du trafic, les travaux en cours et \u00e0 venir, propose des itin\u00e9raires et bien d'autres choses (plans des lignes, fiches horaires, etc.) sur l'ensemble du r\u00e9seau ferr\u00e9 Ile-De-France : M\u00e9tro, RER, Transilien, Tram. Motoris\u00e9 par Tock, le chatbot vous attend sur Facebook Messenger pour offrir ses services. Nom : Tilien Date de naissance : en production, depuis 2018 sur Tock Domaine : transport & assistance (recherche itin\u00e9raires, plans des lignes, \u00e9tat du trafic, etc.) Canaux : texte, sur Messenger ( botsncftransilien ) Mon Assistant TGV INOUI \u00b6 Mon Assistant informe les clients et voyageurs de la marque TGV INOUI avant, pendant et apr\u00e8s leur trajet. Le chatbot est capable de donner l'\u00e9tat du trafic, le quai de d\u00e9part d'un train, la ou les places du client, les services \u00e0 bord (le bar, les prises \u00e9lectriques, etc.). Il permet aussi de parler avec un agent SNCF tout en restant dans la m\u00eame conversation. Pr\u00e9sent sur la page Facebook TGV INOUI et le portail Wifi \u00e0 Bord , l'assistant s'appuie sur Tock et le tock-react-kit . Nom : Mon Assistant TGV INOUI Date de naissance : en production depuis 2019 Domaine : assistance & info voyageur (info quai, infos voyage en cours, services \u00e0 bord), relai vers un agent Canaux : texte, sur le portail Wifi \u00e0 Bord et Messenger ( TGV INOUI ) L'Agent virtuel SNCF \u00b6 L' Agent virtuel SNCF pr\u00e9sente de mani\u00e8re conversationnelle l'information voyageur et les \u00e9ventuelles perturbations sur tous les trains (TGV, IC, TER, Eurostar...). On peut interroger le bot par num\u00e9ro de train, dossier voyageur, prochains d\u00e9parts, etc. pour obtenir les derni\u00e8res informations et l'\u00e9tat du trafic, ou encore parler \u00e0 un Agent. Accessible sur le site Web sncf.com , la page Facebook et la page Twitter de la SNCF, l' Agent virtuel est bas\u00e9 sur Tock et utilise le tock-react-kit pour l'int\u00e9gration Web. Nom : Agent virtuel SNCF Date de naissance : en production depuis 2019 Domaine : voyage & transport (\u00e9tat du trafic, travaux, prochains d\u00e9parts), relai vers un agent Canaux : texte, sur sncf.com ( lien direct ), Messenger ( SNCFOFFICIEL ) et Twitter ( @sncf ) Eve , le bot interne e-voyageurs \u00b6 Eve est l'assistant interne des collaborateurs e.Voyageurs SNCF . Le chatbot r\u00e9pond aux questions courantes, renvoie vers les bons contacts et outils collaboratifs de l'entreprise, automatise des demandes courantes au Support Informatique, Services G\u00e9n\u00e9raux, Direction Juridique, etc. Les \u00e9quipes Devops peuvent aussi lui demander l'\u00e9tat de la production, les prochaines interventions, voire d'effectuer directement certaines op\u00e9rations pour plus de simplicit\u00e9 et de r\u00e9activit\u00e9. Eve est \u00e0 l'\u00e9coute des collaborateurs dans l'entreprise et en mobilit\u00e9 sur Teams avec Tock. Nom : Eve Date de naissance : en production depuis 2019 Domaine : assistance en interne & B2B (FAQ, Support Informatique, RH, Juridique), automatisations DevOps (supervision, d\u00e9ploiements, gestion de production, etc.) Canaux : texte & voix, en interne dans l'entreprise et en mobilit\u00e9 via Teams Autres bots Tock... \u00b6 D'autres assistants conversationnels d\u00e9velopp\u00e9s avec Tock sont utilis\u00e9s par diff\u00e9rentes organisations (notamment les membres du TOSIT ). Ces bots ne sont pas toujours destin\u00e9s au grand public et leurs organisations ne communiquent pas n\u00e9cessairement dessus. Nous mentionnons ces projets si l'occasion se pr\u00e9sente ;) N'h\u00e9sitez pas \u00e0 faire un tour sur le tchat Gitter de la communaut\u00e9, vous pourrez constater que de plus en plus de professionnels et particuliers, \u00e9tudiants, PME et ESN, exp\u00e9rimentent ou utilisent Tock pour leurs projets d'assistants ou d'applications NLP . Et vous ? \u00b6 La plateforme est suffisamment g\u00e9n\u00e9rique pour permettre de nombreux usages et l'int\u00e9gration de canaux internes ou externes. Si vous avez un doute sur les possibilit\u00e9s de Tock ou la faisabilit\u00e9 d'un nouveau projet, vous pouvez nous contacter pour en parler. Quant \u00e0 vos propres r\u00e9alisations, n'h\u00e9sitez pas \u00e0 les partager ! \ud83d\ude42","title":"Vitrine utilisateurs"},{"location":"apropos/vitrine/#vitrine-utilisateurs","text":"Depuis sa cr\u00e9ation pour OUI.sncf en 2016 jusqu'au service AlloCovid en 2020, Tock est utilis\u00e9 par de plus en plus d'\u00e9quipes (notamment SNCF mais pas uniquement) pour cr\u00e9er des bots conversationnels d\u00e9di\u00e9s \u00e0 des usages divers : business to customer et business to business distribution, transactionnel, paiement assistance, care , help desks FAQ et arbres de d\u00e9cision Cette page pr\u00e9sente diff\u00e9rents assistants et produits connus construits avec Tock, dont certains ont \u00e9t\u00e9 r\u00e9compens\u00e9s par la communaut\u00e9.","title":"Vitrine utilisateurs"},{"location":"apropos/vitrine/#allocovid","text":"Le service AlloCovid permet d'informer et d'orienter la population sur le Covid-19, reprenant le questionnaire pr\u00e9d\u00e9fini par le Minist\u00e8re de la Sant\u00e9. IA vocale engag\u00e9e dans la crise sanitaire Ce service conversationnel est le fruit de la collaboration de nombreux experts fran\u00e7ais, partenaires technologiques et b\u00e9n\u00e9voles. Pour en savoir sur la g\u00e9n\u00e8se du projet, l'\u00e9quipe et les partenaires, le fonctionnement du bot, la presse, etc. rendez-vous sur www.allocovid.com . Disponible par t\u00e9l\u00e9phone, sur le Web et WhatsApp, AlloCovid est construit autour d'un bot Tock et int\u00e8gre des solutions compl\u00e9mentaires comme les technologies vocales Allo-Media et Voxygen . Le bot AlloCovid est construit autour de technologies open source (\u00e0 travers la plateforme Tock), et lui-m\u00eame open source : les sources du bot sont disponibles sur le d\u00e9p\u00f4t allocovid . Avec les sources du bot on trouve \u00e9galement celles du connecteur Allo-Media , quelques explications techniques sur le bot et la sp\u00e9cification fonctionnelle du questionnaire Covid. Nom : AlloCovid Date de naissance : en production au printemps 2020 Domaine : informations sanitaires et orientation vers les services de sant\u00e9 Canaux : texte & voix, par t\u00e9l\u00e9phone, sur WhatsApp et site Web","title":"AlloCovid"},{"location":"apropos/vitrine/#ouibot-le-bot-ouisncf","text":"OUIbot est l'assistant conversationnel de OUI.sncf. Disponible depuis 2016 sur le r\u00e9seau social Facebook Messenger, OUIbot s'est construit avec les premi\u00e8res versions de Tock. Avec OUIbot, r\u00e9server un billet de train n'a jamais \u00e9t\u00e9 aussi simple ! Il vous assiste dans la pr\u00e9paration de vos voyages, permet d'effectuer rapidement et simplement une r\u00e9servation compl\u00e8te, de la recherche \u00e0 l'achat (paiement inclus), et vous accompagne durant votre voyage. Gr\u00e2ce aux nombreux connecteurs Tock, OUIbot r\u00e9pond pr\u00e9sent sur de nombreux canaux conversationnels : site www.oui.sncf , r\u00e9seaux sociaux, assistants vocaux, enceintes connect\u00e9es et m\u00eame IAffiches avec JCDecaux . En 2019, OUIbot accompagne pr\u00e8s de 10 000 utilisateurs par jour. Il a \u00e9t\u00e9 \u00e9lu Best Robot Experience pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive. Nom : OUIbot Date de naissance : en production depuis 2016 Domaine : distribution, transactionnel (r\u00e9servations, paiements), alertes & push notifications, relai vers un agent Canaux : texte & voix, sur le site Web entreprise, Messenger, WhatsApp, Business Chat (Messages), Google Assistant, Google Home, Alexa, IAffiches JCDecaux","title":"OUIbot, le bot OUI.sncf"},{"location":"apropos/vitrine/#chatbot-interne-enedis","text":"Le Chatbot interne Enedis permet aux 39 000 salari\u00e9s Enedis un acc\u00e8s simplifi\u00e9 aux services logistiques de l\u2019entreprise. Cet agent conversationnel intelligent offre un support de 1 er niveau en r\u00e9pondant aux questions les plus fr\u00e9quentes des salari\u00e9s et en orientant vers les outils M\u00e9tiers de gestion de demande. Il a \u00e9galement vocation \u00e0 mieux appr\u00e9hender les besoins des salari\u00e9s via l\u2019analyse des questions fr\u00e9quentes. Construit avec Tock, le chatbot est disponible sur un site Web interne \u00e0 l'entreprise. Nom : Chatbot interne Enedis Date de naissance : en production depuis 2020 Domaine : services logistiques internes Canaux : texte, sur un site Web interne","title":"Chatbot interne Enedis"},{"location":"apropos/vitrine/#lassistant-sncf","text":"L'Assistant SNCF est l'application mobile des voyageurs SNCF sur Android et iOS, couvrant le train mais aussi d'autres modes de transport. Avec l\u2019 Assistant SNCF , vous pouvez calculer votre itin\u00e9raire, rester inform\u00e9 en temps r\u00e9el, acheter directement vos tickets de transport ou encore r\u00e9server votre course en VTC. En attendant de nouvelles fonctionnalit\u00e9s \u00e0 venir. Accessible via le \"microphone\" dans l'application mobile, le bot conversationnel de l' Assistant SNCF est construit avec Tock et les fonctions speech-to-text Android et iOS. Nom : L'Assistant SNCF Date de naissance : en production, fonction vocale Tock depuis 2019 Domaine : voyage & transport (recherche itin\u00e9raires en multi-modal, etc.) Canaux : vocal, sur l'application mobile SNCF pour Android et iOS","title":"L'Assistant SNCF"},{"location":"apropos/vitrine/#linto-by-linagora","text":"La plateforme LinTO est une bo\u00eete \u00e0 outils Open Source permettant le d\u00e9veloppement et l'int\u00e9gration de processus d\u2019interactions vocales r\u00e9pondant aux besoins des professionnels et de l\u2019industrie. LinTO est un assistant intelligent Open Source con\u00e7u par LINAGORA : bas\u00e9 exclusivement sur des technologies Open Source, LinTO est pr\u00eat pour le cloud mais sans GAFAM (Google-Amazon-Facebook-Apple-Microsoft), et respecte votre vie priv\u00e9e sans partager vos donn\u00e9es pour usage commercial. LinTO utilise l'IA pour capter votre voix et vous aider tout au long de la journ\u00e9e, m\u00eame en r\u00e9union, \u00e0 r\u00e9duire les t\u00e2ches stressantes ou chronophages : gestion d'agenda, rappels, prise de notes, emails, m\u00e9t\u00e9o, trafic, dictionnaire , actualit\u00e9s, etc. Le projet de recherche est subventionn\u00e9 par le PIA (Programme d'Investissement d'Avenir) de l'\u00e9tat Fran\u00e7ais dans le cadre des Grands D\u00e9fis du num\u00e9rique. Il allie des entreprises technologiques telles que LINAGORA et ZELROS et des laboratoires de recherche comme l'IRIT, le LaaS, le CNRS et le laboratoire de recherche en informatique de l'\u00e9cole polytechnique. Le service LinTO NLU (Natural Language Understanding) est bas\u00e9 sur Tock et permet l\u2019utilisation de plusieurs mod\u00e8les IA d\u00e9di\u00e9s \u00e0 des cas d\u2019utilisation sp\u00e9cifiques. Il apprend automatiquement selon les usages lors de l\u2019ajout ou suppression de comp\u00e9tences ( Skills ) \u00e0 la plateforme. Nom : LinTO Date de naissance : en production avec Tock depuis 2019 Domaine : assistant personnel pour les entreprises (agenda, emails, prise de notes, etc.) Canaux : vocal (portabilit\u00e9 Raspberry Pi, ARM, Android, Web...)","title":"LinTO by Linagora"},{"location":"apropos/vitrine/#tilien-le-chatbot-transilien","text":"Tilien est le chatbot Transilien sur Messenger. Con\u00e7u comme un compagnon de voyage personnel et amical, il informe des prochains d\u00e9parts, l'\u00e9tat du trafic, les travaux en cours et \u00e0 venir, propose des itin\u00e9raires et bien d'autres choses (plans des lignes, fiches horaires, etc.) sur l'ensemble du r\u00e9seau ferr\u00e9 Ile-De-France : M\u00e9tro, RER, Transilien, Tram. Motoris\u00e9 par Tock, le chatbot vous attend sur Facebook Messenger pour offrir ses services. Nom : Tilien Date de naissance : en production, depuis 2018 sur Tock Domaine : transport & assistance (recherche itin\u00e9raires, plans des lignes, \u00e9tat du trafic, etc.) Canaux : texte, sur Messenger ( botsncftransilien )","title":"Tilien, le chatbot Transilien"},{"location":"apropos/vitrine/#mon-assistant-tgv-inoui","text":"Mon Assistant informe les clients et voyageurs de la marque TGV INOUI avant, pendant et apr\u00e8s leur trajet. Le chatbot est capable de donner l'\u00e9tat du trafic, le quai de d\u00e9part d'un train, la ou les places du client, les services \u00e0 bord (le bar, les prises \u00e9lectriques, etc.). Il permet aussi de parler avec un agent SNCF tout en restant dans la m\u00eame conversation. Pr\u00e9sent sur la page Facebook TGV INOUI et le portail Wifi \u00e0 Bord , l'assistant s'appuie sur Tock et le tock-react-kit . Nom : Mon Assistant TGV INOUI Date de naissance : en production depuis 2019 Domaine : assistance & info voyageur (info quai, infos voyage en cours, services \u00e0 bord), relai vers un agent Canaux : texte, sur le portail Wifi \u00e0 Bord et Messenger ( TGV INOUI )","title":"Mon Assistant TGV INOUI"},{"location":"apropos/vitrine/#lagent-virtuel-sncf","text":"L' Agent virtuel SNCF pr\u00e9sente de mani\u00e8re conversationnelle l'information voyageur et les \u00e9ventuelles perturbations sur tous les trains (TGV, IC, TER, Eurostar...). On peut interroger le bot par num\u00e9ro de train, dossier voyageur, prochains d\u00e9parts, etc. pour obtenir les derni\u00e8res informations et l'\u00e9tat du trafic, ou encore parler \u00e0 un Agent. Accessible sur le site Web sncf.com , la page Facebook et la page Twitter de la SNCF, l' Agent virtuel est bas\u00e9 sur Tock et utilise le tock-react-kit pour l'int\u00e9gration Web. Nom : Agent virtuel SNCF Date de naissance : en production depuis 2019 Domaine : voyage & transport (\u00e9tat du trafic, travaux, prochains d\u00e9parts), relai vers un agent Canaux : texte, sur sncf.com ( lien direct ), Messenger ( SNCFOFFICIEL ) et Twitter ( @sncf )","title":"L'Agent virtuel SNCF"},{"location":"apropos/vitrine/#eve-le-bot-interne-e-voyageurs","text":"Eve est l'assistant interne des collaborateurs e.Voyageurs SNCF . Le chatbot r\u00e9pond aux questions courantes, renvoie vers les bons contacts et outils collaboratifs de l'entreprise, automatise des demandes courantes au Support Informatique, Services G\u00e9n\u00e9raux, Direction Juridique, etc. Les \u00e9quipes Devops peuvent aussi lui demander l'\u00e9tat de la production, les prochaines interventions, voire d'effectuer directement certaines op\u00e9rations pour plus de simplicit\u00e9 et de r\u00e9activit\u00e9. Eve est \u00e0 l'\u00e9coute des collaborateurs dans l'entreprise et en mobilit\u00e9 sur Teams avec Tock. Nom : Eve Date de naissance : en production depuis 2019 Domaine : assistance en interne & B2B (FAQ, Support Informatique, RH, Juridique), automatisations DevOps (supervision, d\u00e9ploiements, gestion de production, etc.) Canaux : texte & voix, en interne dans l'entreprise et en mobilit\u00e9 via Teams","title":"Eve, le bot interne e-voyageurs"},{"location":"apropos/vitrine/#autres-bots-tock","text":"D'autres assistants conversationnels d\u00e9velopp\u00e9s avec Tock sont utilis\u00e9s par diff\u00e9rentes organisations (notamment les membres du TOSIT ). Ces bots ne sont pas toujours destin\u00e9s au grand public et leurs organisations ne communiquent pas n\u00e9cessairement dessus. Nous mentionnons ces projets si l'occasion se pr\u00e9sente ;) N'h\u00e9sitez pas \u00e0 faire un tour sur le tchat Gitter de la communaut\u00e9, vous pourrez constater que de plus en plus de professionnels et particuliers, \u00e9tudiants, PME et ESN, exp\u00e9rimentent ou utilisent Tock pour leurs projets d'assistants ou d'applications NLP .","title":"Autres bots Tock..."},{"location":"apropos/vitrine/#et-vous","text":"La plateforme est suffisamment g\u00e9n\u00e9rique pour permettre de nombreux usages et l'int\u00e9gration de canaux internes ou externes. Si vous avez un doute sur les possibilit\u00e9s de Tock ou la faisabilit\u00e9 d'un nouveau projet, vous pouvez nous contacter pour en parler. Quant \u00e0 vos propres r\u00e9alisations, n'h\u00e9sitez pas \u00e0 les partager ! \ud83d\ude42","title":"Et vous ?"},{"location":"dev/api/","text":"Les APIs Tock \u00b6 Cette section de la documentation Tock pr\u00e9sente sommairement les diff\u00e9rentes API fournies avec Tock. Tock Web Connector API \u00b6 Le connecteur Web de Tock permet de dialoguer avec un bot \u00e0 travers une API REST. La documentation de cette API est disponible dans /api/web-connector . Tock NLU API \u00b6 L'API NLU de Tock (reconnaissance du langage naturel) permet d'interroger programmatiquement le mod\u00e8le conversationnel et d'analyser une phrase. La documentation de l'API Tock NLU est disponible dans /api . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/ . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/index.html . Tock Studio / Admin API \u00b6 De m\u00eame, la documentation de l'API Tock Studio est disponible dans /api/admin . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/admin.html . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/admin.html . Tock Bot Definition API \u00b6 Cette API permet de cr\u00e9er des bots et des parcours ( stories ) avec n'importe quel langage. Un bot Tock peut \u00eatre compos\u00e9 de parcours configur\u00e9s dans Tock Studio, compl\u00e9t\u00e9s par des parcours d\u00e9velopp\u00e9s dans un langage de programmation pour impl\u00e9menter des r\u00e8gles complexes, interagir avec d'autres APIs, etc. Cette API est utilis\u00e9e par les clients Kotlin, Javascript/Nodejs et Python disponibles en modes WebHook et WebSocket . L'API est toutefois encore en d\u00e9veloppement (b\u00e9ta) et sa documentation arrivera bient\u00f4t. Pour d\u00e9velopper en mode Bot API , voir cette page .","title":"Liste des APIs"},{"location":"dev/api/#les-apis-tock","text":"Cette section de la documentation Tock pr\u00e9sente sommairement les diff\u00e9rentes API fournies avec Tock.","title":"Les APIs Tock"},{"location":"dev/api/#tock-web-connector-api","text":"Le connecteur Web de Tock permet de dialoguer avec un bot \u00e0 travers une API REST. La documentation de cette API est disponible dans /api/web-connector .","title":"Tock Web Connector API"},{"location":"dev/api/#tock-nlu-api","text":"L'API NLU de Tock (reconnaissance du langage naturel) permet d'interroger programmatiquement le mod\u00e8le conversationnel et d'analyser une phrase. La documentation de l'API Tock NLU est disponible dans /api . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/ . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/index.html .","title":"Tock NLU API"},{"location":"dev/api/#tock-studio-admin-api","text":"De m\u00eame, la documentation de l'API Tock Studio est disponible dans /api/admin . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/admin.html . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/admin.html .","title":"Tock Studio / Admin API"},{"location":"dev/api/#tock-bot-definition-api","text":"Cette API permet de cr\u00e9er des bots et des parcours ( stories ) avec n'importe quel langage. Un bot Tock peut \u00eatre compos\u00e9 de parcours configur\u00e9s dans Tock Studio, compl\u00e9t\u00e9s par des parcours d\u00e9velopp\u00e9s dans un langage de programmation pour impl\u00e9menter des r\u00e8gles complexes, interagir avec d'autres APIs, etc. Cette API est utilis\u00e9e par les clients Kotlin, Javascript/Nodejs et Python disponibles en modes WebHook et WebSocket . L'API est toutefois encore en d\u00e9veloppement (b\u00e9ta) et sa documentation arrivera bient\u00f4t. Pour d\u00e9velopper en mode Bot API , voir cette page .","title":"Tock Bot Definition API"},{"location":"dev/bot-api/","text":"D\u00e9velopper en mode Tock Bot API \u00b6 Le mode Bot API de Tock permet de d\u00e9velopper des bots en se connectant \u00e0 une plateforme Tock Studio en utilisant l'API REST conversationnelle de Tock. C'est donc le mode de d\u00e9veloppement Tock recommand\u00e9 pour d\u00e9marrer, ainsi que dans des scenarios ou l'acc\u00e8s partag\u00e9 \u00e0 la base de donn\u00e9es serait un probl\u00e8me. Seul le mode Bot API est disponible sur la plateforme de d\u00e9monstration publique Tock. Cette page pr\u00e9sente le d\u00e9veloppement de bots Tock en mode Bot API en Kotlin . Des clients sont aussi disponibles pour Javascript/Node et Python . Il est possible de d\u00e9velopper des parcours Tock dans n'importe quel langage via la Bot API . Une autre section pr\u00e9sente le mode Bot Framework disponible pour Kotlin uniquement, plus int\u00e9gr\u00e9 mais aussi plus coupl\u00e9 \u00e0 la plateforme Tock. Se connecter sur la plateforme de d\u00e9monstration \u00b6 Plut\u00f4t que d\u00e9ployer se propre plateforme Tock, il est possible de tester les modes WebSocket ou Webhook directement sur la plateforme de d\u00e9monstration Tock . D\u00e9velopper en Kotlin \u00b6 Activer le mode WebSocket \u00b6 C'est le mode \u00e0 privil\u00e9gier au d\u00e9marrage car le plus simple \u00e0 mettre en oeuvre. Pour utiliser le client websocket, il faut ajouter la d\u00e9pendance tock-bot-api-websocket \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> 20.9.2-1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:tock-bot-api-websocket:20.9.2-1' Activer le mode WebHook \u00b6 De mani\u00e8re alternative, vous pouvez choisir d'utiliser le client WebHook , il faut ajouter la d\u00e9pendance tock-bot-api-webhook \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-webhook </artifactId> <version> 20.9.2-1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:tock-bot-api-webhook:20.9.2-1' Dans ce cas, contrairement au mode WebSocket , il faut que l'application/bot d\u00e9marr\u00e9e soit joignable par la plateforme Tock via une URL publique (vous pouvez utilisez par exemple ngrok ). Cette URL doit \u00eatre indiqu\u00e9e dans le champ webhook url dans la vue Configuration > Bot Configurations de l'interface Tock Studio . Param\u00e9trer la cl\u00e9 d'API \u00b6 Dans Tock Studio , apr\u00e8s avoir configur\u00e9 un bot, allez dans Configuration > Bot Configurations et copiez la cl\u00e9 d'API du bot auquel vous souhaitez vous connecter. Vous pourrez saisir/coller cette clef dans le code Kotlin (voir ci-dessous). Cr\u00e9er des parcours en Kotlin \u00b6 Pour le moment, les composants suivants sont support\u00e9s pour les r\u00e9ponses : Texte avec Boutons (Quick Reply) Format \"carte\" Format \"carousel\" Formats sp\u00e9cifiques aux diff\u00e9rents canaux int\u00e9gr\u00e9s Voici un exemple de bot simple avec quelques parcours d\u00e9clar\u00e9s : fun main () { startWithDemo ( newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // R\u00e9cup\u00e9rer la cl\u00e9 d'API \u00e0 partir de l'onglet \"Bot Configurations\" dans Tock Studio newStory ( \"greetings\" ) { // Intention 'greetings' end ( \"Bonjour!\" ) // R\u00e9ponse texte simple }, newStory ( \"location\" ) { // Intention 'location' end ( // R\u00e9ponse avec une carte - pouvant inclure du texte, un fichier (par exemple une image) et des suggestions d'action utilisateur newCard ( \"Le titre de la carte\" , \"Un sous-titre\" , newAttachment ( \"https://url-image.png\" ), newAction ( \"Action 1\" ), newAction ( \"Action 2\" , \"http://redirection\" ) ) ) }, newStory ( \"goodbye\" ) { // Intention 'goodbye' end { // R\u00e9ponse sp\u00e9cifique au format Messenger buttonsTemplate ( \"Etes-vous s\u00fbr(e) de vouloir partir ?\" , nlpQuickReply ( \"Je reste\" )) } }, // R\u00e9ponse fournie pas le bot en cas d'incompr\u00e9hension unknownStory { end ( \"Je n'ai pas compris. Mais j'apprends tous les jours :)\" ) } ) ) } Le code source complet de l'exemple est disponible. D\u00e9velopper en Javascript \u00b6 Un client est fourni pour d\u00e9velopper des parcours en Javascript avec Nodejs . Pour en savoir plus, voir la documentation sur le d\u00e9p\u00f4t tock-node . D\u00e9velopper en Python \u00b6 Un client est fourni pour d\u00e9velopper des parcours en Python . Pour en savoir plus, voir la documentation sur le d\u00e9p\u00f4t tock-py . D\u00e9velopper via l'API \u00b6 Il est possible de d\u00e9velopper des parcours Tock dans n'importe quel langage, en s'interfa\u00e7ant directement avec l' API . Installer Bot API c\u00f4t\u00e9 serveur \u00b6 Pour utiliser le mode Bot API de Tock, un module sp\u00e9cifique doit \u00eatre d\u00e9ploy\u00e9 avec la plateforme. G\u00e9n\u00e9ralement appel\u00e9 bot-api dans les descripteurs Docker Compose par exemple, ce service a pour r\u00f4le : D'exposer la Bot API aux clients potentiels quelque soit leur langage de programmation D'accepter des connexions en WebSocket et/ou de se connecter au webhook configur\u00e9 Le guide D\u00e9ployer Tock avec Docker ou encore le chapitre Installation montrent comment d\u00e9ployer ce module si n\u00e9cessaire. La seule modification n\u00e9cessaire par rapport au code d'exemple pour la platforme de d\u00e9monstration est de remplacer la m\u00e9thode startWithDemo par start en pr\u00e9cisant si besoin l'adresse de du serveur bot-api .","title":"Tock Bot API"},{"location":"dev/bot-api/#developper-en-mode-tock-bot-api","text":"Le mode Bot API de Tock permet de d\u00e9velopper des bots en se connectant \u00e0 une plateforme Tock Studio en utilisant l'API REST conversationnelle de Tock. C'est donc le mode de d\u00e9veloppement Tock recommand\u00e9 pour d\u00e9marrer, ainsi que dans des scenarios ou l'acc\u00e8s partag\u00e9 \u00e0 la base de donn\u00e9es serait un probl\u00e8me. Seul le mode Bot API est disponible sur la plateforme de d\u00e9monstration publique Tock. Cette page pr\u00e9sente le d\u00e9veloppement de bots Tock en mode Bot API en Kotlin . Des clients sont aussi disponibles pour Javascript/Node et Python . Il est possible de d\u00e9velopper des parcours Tock dans n'importe quel langage via la Bot API . Une autre section pr\u00e9sente le mode Bot Framework disponible pour Kotlin uniquement, plus int\u00e9gr\u00e9 mais aussi plus coupl\u00e9 \u00e0 la plateforme Tock.","title":"D\u00e9velopper en mode Tock Bot API"},{"location":"dev/bot-api/#se-connecter-sur-la-plateforme-de-demonstration","text":"Plut\u00f4t que d\u00e9ployer se propre plateforme Tock, il est possible de tester les modes WebSocket ou Webhook directement sur la plateforme de d\u00e9monstration Tock .","title":"Se connecter sur la plateforme de d\u00e9monstration"},{"location":"dev/bot-api/#developper-en-kotlin","text":"","title":"D\u00e9velopper en Kotlin"},{"location":"dev/bot-api/#activer-le-mode-websocket","text":"C'est le mode \u00e0 privil\u00e9gier au d\u00e9marrage car le plus simple \u00e0 mettre en oeuvre. Pour utiliser le client websocket, il faut ajouter la d\u00e9pendance tock-bot-api-websocket \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> 20.9.2-1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:tock-bot-api-websocket:20.9.2-1'","title":"Activer le mode WebSocket"},{"location":"dev/bot-api/#activer-le-mode-webhook","text":"De mani\u00e8re alternative, vous pouvez choisir d'utiliser le client WebHook , il faut ajouter la d\u00e9pendance tock-bot-api-webhook \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-webhook </artifactId> <version> 20.9.2-1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:tock-bot-api-webhook:20.9.2-1' Dans ce cas, contrairement au mode WebSocket , il faut que l'application/bot d\u00e9marr\u00e9e soit joignable par la plateforme Tock via une URL publique (vous pouvez utilisez par exemple ngrok ). Cette URL doit \u00eatre indiqu\u00e9e dans le champ webhook url dans la vue Configuration > Bot Configurations de l'interface Tock Studio .","title":"Activer le mode WebHook"},{"location":"dev/bot-api/#parametrer-la-cle-dapi","text":"Dans Tock Studio , apr\u00e8s avoir configur\u00e9 un bot, allez dans Configuration > Bot Configurations et copiez la cl\u00e9 d'API du bot auquel vous souhaitez vous connecter. Vous pourrez saisir/coller cette clef dans le code Kotlin (voir ci-dessous).","title":"Param\u00e9trer la cl\u00e9 d'API"},{"location":"dev/bot-api/#creer-des-parcours-en-kotlin","text":"Pour le moment, les composants suivants sont support\u00e9s pour les r\u00e9ponses : Texte avec Boutons (Quick Reply) Format \"carte\" Format \"carousel\" Formats sp\u00e9cifiques aux diff\u00e9rents canaux int\u00e9gr\u00e9s Voici un exemple de bot simple avec quelques parcours d\u00e9clar\u00e9s : fun main () { startWithDemo ( newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // R\u00e9cup\u00e9rer la cl\u00e9 d'API \u00e0 partir de l'onglet \"Bot Configurations\" dans Tock Studio newStory ( \"greetings\" ) { // Intention 'greetings' end ( \"Bonjour!\" ) // R\u00e9ponse texte simple }, newStory ( \"location\" ) { // Intention 'location' end ( // R\u00e9ponse avec une carte - pouvant inclure du texte, un fichier (par exemple une image) et des suggestions d'action utilisateur newCard ( \"Le titre de la carte\" , \"Un sous-titre\" , newAttachment ( \"https://url-image.png\" ), newAction ( \"Action 1\" ), newAction ( \"Action 2\" , \"http://redirection\" ) ) ) }, newStory ( \"goodbye\" ) { // Intention 'goodbye' end { // R\u00e9ponse sp\u00e9cifique au format Messenger buttonsTemplate ( \"Etes-vous s\u00fbr(e) de vouloir partir ?\" , nlpQuickReply ( \"Je reste\" )) } }, // R\u00e9ponse fournie pas le bot en cas d'incompr\u00e9hension unknownStory { end ( \"Je n'ai pas compris. Mais j'apprends tous les jours :)\" ) } ) ) } Le code source complet de l'exemple est disponible.","title":"Cr\u00e9er des parcours en Kotlin"},{"location":"dev/bot-api/#developper-en-javascript","text":"Un client est fourni pour d\u00e9velopper des parcours en Javascript avec Nodejs . Pour en savoir plus, voir la documentation sur le d\u00e9p\u00f4t tock-node .","title":"D\u00e9velopper en Javascript"},{"location":"dev/bot-api/#developper-en-python","text":"Un client est fourni pour d\u00e9velopper des parcours en Python . Pour en savoir plus, voir la documentation sur le d\u00e9p\u00f4t tock-py .","title":"D\u00e9velopper en Python"},{"location":"dev/bot-api/#developper-via-lapi","text":"Il est possible de d\u00e9velopper des parcours Tock dans n'importe quel langage, en s'interfa\u00e7ant directement avec l' API .","title":"D\u00e9velopper via l'API"},{"location":"dev/bot-api/#installer-bot-api-cote-serveur","text":"Pour utiliser le mode Bot API de Tock, un module sp\u00e9cifique doit \u00eatre d\u00e9ploy\u00e9 avec la plateforme. G\u00e9n\u00e9ralement appel\u00e9 bot-api dans les descripteurs Docker Compose par exemple, ce service a pour r\u00f4le : D'exposer la Bot API aux clients potentiels quelque soit leur langage de programmation D'accepter des connexions en WebSocket et/ou de se connecter au webhook configur\u00e9 Le guide D\u00e9ployer Tock avec Docker ou encore le chapitre Installation montrent comment d\u00e9ployer ce module si n\u00e9cessaire. La seule modification n\u00e9cessaire par rapport au code d'exemple pour la platforme de d\u00e9monstration est de remplacer la m\u00e9thode startWithDemo par start en pr\u00e9cisant si besoin l'adresse de du serveur bot-api .","title":"Installer Bot API c\u00f4t\u00e9 serveur"},{"location":"dev/bot-integre/","text":"D\u00e9velopper en mode Tock Bot int\u00e9gr\u00e9 \u00b6 Le mode Bot int\u00e9gr\u00e9 Tock permet de d\u00e9velopper un bot en utilisant un Domain Specifique Language (DSL) en Kotlin . Contrairement au mode Bot API encore en d\u00e9veloppement, le Bot Framework Kotlin permet d'exploiter toutes les possibilit\u00e9s de la plateforme Tock, notamment : Gestion des contextes utilisateurs Historique de conversation Notions avanc\u00e9es comme la fusion d'entit\u00e9s Etc. Exemple de fusion d'entit\u00e9s : lorsque un utilisateur demande \"demain\" dans une phrase (appelons cette entit\u00e9 date ) puis \"plut\u00f4t le soir\" dans une phrase suivante, la fusion permet de mettre \u00e0 jour automatiquement l'entit\u00e9 ( date ) avec les deux informations compl\u00e9mentaires : jour et cr\u00e9neau horaire dans cet exemple. Attention : dans ce mode de d\u00e9veloppement, contrairement au mode Bot API , il est n\u00e9cessaire que le module bot dispose d'une connexion \u00e0 la base de donn\u00e9e (MongoDB) de la plateforme Tock utilis\u00e9e. Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage de programmation Kotlin . D\u00e9marrer avec le framework \u00b6 Documentation KDoc \u00b6 La documentation du framework au format KDoc est disponible ici . D\u00e9pendance bot-toolkit \u00b6 Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance bot-tookit \u00e0 l'application / au projet Kotlin. Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> bot-toolkit </artifactId> <version> 20.9.2-1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:bot-toolkit:20.9.2-1' Un bot est un ensemble de parcours (stories) \u00b6 Voici par exemple comment le Bot Open Data est d\u00e9fini : val openBot = bot ( \"bot_open_data\" , stories = listOf ( greetings , departures , arrivals , search ), hello = greetings ) Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de parcours ou stories . Une Story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\" (voir Concepts ). Ici le bot d\u00e9finit 4 parcours : greetings , departures , arrivals et search . Le parcours greetings est d\u00e9clar\u00e9 comme parcours principal, il sera pr\u00e9sent\u00e9 par d\u00e9faut au d\u00e9but d'une conversation : hello = greetings . Une Story simple \u00b6 Comment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e du parcours greetings : val greetings = story ( \"greetings\" ) { send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) end ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) } Notez que dans le corps de la fonction, this est de type BotBus , \u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der \u00e0 tous les \u00e9lements contextuels disponibles. Concr\u00e8tement sela signifie que quand l'intention greetings sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock. Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse ( bus.send() ), puis un deuxi\u00e8me en indiquant que c'est la derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un bus.end() . Voici maintenant la version compl\u00e8te de greetings : val greetings = story ( \"greetings\" ) { //cleanup state resetDialogState () send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) send ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) withMessenger { buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) } withGoogleAssistant { gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) } end () } Deux notions ont \u00e9t\u00e9 ajout\u00e9es : resetDialogState() qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents) les m\u00e9thodes withMessenger{} et withGoogleAssistant{} qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur. Ici un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant. D\u00e9marrer et connecter le bot \u00b6 Pour d\u00e9marrer le bot, il suffit de rajouter dans votre main principal l'appel suivant : registerAndInstallBot ( openBot ) La variable openBot dans l'exemple est le bot que vous avez d\u00e9fini plus haut. Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s dans l'interface d'administration du bot, du menu Configuration > Bot Configurations > Create a new configuration . Pour en savoir plus sur les diff\u00e9rents canaux et connecteurs, voir cette page . Importer la configuration (dumps) \u00b6 Il est possible d'exporter diff\u00e9rentes configurations depuis Tock Studio, puis les importer automatiquement au d\u00e9marrage du bot. Une fois export\u00e9s les fichiers dumps de Tock Studio dans le classpath du bot, on peut appeler une ou plusieurs des fonctions suivantes depuis le main : importApplicationDump : importe une application \u00e0 partir d'un dump d'application . Remarque : l'import est ignor\u00e9 si l'application cible existe d\u00e9j\u00e0. importNlpDump : importe un mod\u00e8le NLP (intentions, phrases, entit\u00e9s) \u00e0 partir d'un dump NLP . importI18nDump : importe des labels (aka i18n ) \u00e0 partir d'un dump de labels . Exemple : fun main ( args : Array < String >) { registerAndInstallBot ( bot ) // Import application importApplicationDump ( \"/bot_app_dump.json\" ) // Import NLP model (intents, sentences, entities...) importNlpDump ( \"/bot_nlp_dump.json\" ) // Import story labels (aka i18n) importI18nDump ( \"/bot_labels_dump.json\" ) } Aller plus loin \u00b6 Bien s\u00fbr, le StoryHandler de greetings ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame. Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire. Intentions secondaires \u00b6 Voici le d\u00e9but de la d\u00e9finition de la story search : val search = storyDef < SearchDef >( \"search\" , otherStarterIntents = setOf ( indicate_origin ), secondaryIntents = setOf ( indicate_location )) { } Le parcours search d\u00e9finit une intention secondaire \"de d\u00e9marrage\" ( indicate_origin ) et une intention secondaire simple ( indicate_location ). Une intention secondaire \"de d\u00e9marrage\" est semblable en tout point \u00e0 une intention principale : d\u00e8s que cette intention est d\u00e9tect\u00e9e, le parcours search va \u00eatre ex\u00e9cut\u00e9, si la story courante ne poss\u00e8de pas cette intention en tant qu'intention secondaire. Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte est \"d\u00e9j\u00e0\" la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires. Manipuler les entit\u00e9s \u00b6 Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des extensions . Par exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 destination : val destinationEntity = openBot . entity ( \"location\" , \"destination\" ) var BotBus . destination : Place ? get () = place ( destinationEntity ) set ( value ) = setPlace ( destinationEntity , value ) private fun BotBus . place ( entity : Entity ): Place ? = entityValue ( entity , :: placeValue ) ?. place private fun BotBus . setPlace ( entity : Entity , place : Place ?) = changeEntityValue ( entity , place ?. let { PlaceValue ( place ) }) Une entit\u00e9 de type location et de role destination est cr\u00e9\u00e9e. Il s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP. Une variable destination est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier. Cette variable contient la valeur actuelle de la destination dans le contexte utilisateur. Voici une version compl\u00e9t\u00e9e de la story search qui utilise destination : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0. Idem pour l'origine ou la date de d\u00e9part. Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe ( SearchDef ). La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //handle generic location intent if ( isIntent ( indicate_location ) && location != null ) { if ( destination == null || origin != null ) { destination = returnsAndRemoveLocation () } else { origin = returnsAndRemoveLocation () } } //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est indicate_location , nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination. Il est donc cod\u00e9 une r\u00e8gle simple : Si il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination. Sinon, il s'agit de l'origine. Utiliser HandlerDef \u00b6 Dans la d\u00e9finition de la story search ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique SearchDef . Voici le code de cette classe : @GAHandler ( GASearchConnector :: class ) @MessengerHandler ( MessengerSearchConnector :: class ) class SearchDef ( bus : BotBus ) : HandlerDef < SearchConnector >( bus ) { private val d : Place = bus . destination !! private val o : Place = bus . origin !! private val date : LocalDateTime = bus . departureDate !! override fun answer () { send ( \"De {0} \u00e0 {1}\" , o , d ) send ( \"D\u00e9part le {0}\" , date by datetimeFormat ) val journeys = SncfOpenDataClient . journey ( o , d , date ) if ( journeys . isEmpty ()) { end ( \"D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :(\" ) } else { send ( \"Voici la premi\u00e8re proposition :\" ) connector ?. sendFirstJourney ( journeys . first ()) end () } } } SearchDef \u00e9tend HandlerDef qui est un alias d'une classe du framework Tock. C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des parcours complexes. Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire : SearchConnector . SearchConnector est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations @GAHandler(GASearchConnector::class) et @MessengerHandler(MessengerSearchConnector::class) indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger). Que se passerait-il s'il n'y avait pas de connecteur pour Google Assistant par exemple ? La m\u00e9thode connector?.sendFirstJourney(journeys.first()) n'enverrait pas la r\u00e9ponse finale, puisque connector serait null . Utiliser ConnectorDef \u00b6 Voici maintenant une version simplifi\u00e9e de SearchConnector : sealed class SearchConnector ( context : SearchDef ) : ConnectorDef < SearchDef >( context ) { fun Section . title (): CharSequence = i18n ( \"{0} - {1}\" , from , to ) fun sendFirstJourney ( journey : Journey ) = withMessage ( sendFirstJourney ( journey . publicTransportSections ())) abstract fun sendFirstJourney ( sections : List < Section >): ConnectorMessage } Et voici son impl\u00e9mentation pour Messenger : class MessengerSearchConnector ( context : SearchDef ) : SearchConnector ( context ) { override fun sendFirstJourney ( sections : List < Section >): ConnectorMessage = flexibleListTemplate ( sections . map { section -> with ( section ) { listElement ( title (), content (), trainImage ) } }, compact ) } Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans SearchConnector et le comportement sp\u00e9cifique \u00e0 chaque connecteur se trouve dans les classes d\u00e9di\u00e9es. Utiliser StoryStep \u00b6 Parfois il est n\u00e9cessaire de se souvenir de l'\u00e9tape \u00e0 laquelle l'utilisateur se trouve dans la story courante. Pour cela Tock met \u00e0 disposition la notion de StoryStep . Il existe deux types de StoryStep : SimpleStoryStep \u00b6 A utiliser dans les cas simples, pour lequels on va g\u00e9rer le comportement induit directement : enum class MyStep : SimpleStoryStep { a , b } val story = storyWithSteps < MyStep >( \"intent\" ) { if ( step == a ) { // ... } else if ( step == b ) { // ... } else { //default case } } Pour modifier l'\u00e9tape courante, deux m\u00e9thodes sont disponibles : Modifier manuellement l'\u00e9tape val story = storyWithSteps < MyStep >( \"intent\" ) { //(...) step = MyStep . a // l'\u00e9tape sera persist\u00e9e tant que nous resterons dans cette story } Utiliser les boutons ou autres quick replies Plus de d\u00e9tails sur ce sujet plus bas . Les StoryStep avec comportement \u00b6 Dans des cas plus complexes, on souhaite pouvoir d\u00e9finir un comportement pour chaque \u00e9tape. L'utilisation de HandlerDef est alors un pr\u00e9requis. enum class MySteps : StoryStep < MyHandlerDef > { //pas de comportement sp\u00e9cifique display , select { // la step \"select\" sera automatiquement s\u00e9lectionn\u00e9e si la sous-intention select est d\u00e9tect\u00e9e override val intent : IntentAware ? = SecondaryIntent . select //dans ce cas la r\u00e9ponse suivante sera apport\u00e9e override fun answer (): MyHandlerDef .() -> Any ? = { end ( \"I don't know yet how to select something\" ) } }, disruption { //seule la r\u00e9ponse est configur\u00e9e override fun answer (): ScoreboardDef .() -> Any ? = { end ( \"some perturbation\" ) } }; } Davantage d'options de configuration sont disponibles. Consultez la description de StoryStep . Postback buttons & quick replies \u00b6 Messenger met \u00e0 disposition ce type de bouton, et la plupart des connecteurs avec interface graphique font de m\u00eame. Tock permet de d\u00e9finir l'action effectu\u00e9e suite \u00e0 un clic sur ces boutons. Dans l'exemple suivant, le bouton redirigera vers l'intention search . buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , search ) ) Il est possible de d\u00e9finir \u00e9galement une StoryStep et des param\u00e8tres d\u00e9di\u00e9s : //pour d\u00e9finir des param\u00e8tres, la pratique recommand\u00e9e est d'\u00e9tendre l'interface ParameterKey enum class ChoiceParameter : ParameterKey { nextResultDate , nextResultOrigin } buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , intent = search , //si aucune step n'est indiqu\u00e9e, c'est la step courante qui est utilis\u00e9e step = MyStep . a , parameters = //ce param\u00e8tre est stock\u00e9 sous forme de cha\u00eene de caract\u00e8re (les crochets sont utilis\u00e9s) nextResultDate [ nextDate ] + //ce param\u00e8tre est stock\u00e9 en json (les parenth\u00e8ses sont utilis\u00e9es) nextResultOrigin ( origin ) ) ) Pour r\u00e9cup\u00e9rer les param\u00e8tres du bouton sur lequel on a cliqu\u00e9 : val isClick = isChoiceAction () val nextDate = choice ( nextResultDate ) val nextOrigin : Locality = action . jsonChoice ( nextResultOrigin ) Tests Unitaires \u00b6 La page Tests Unitaires pr\u00e9sente le framework fourni pour r\u00e9aliser des TUs avec Tock.","title":"Tock Bot int\u00e9gr\u00e9"},{"location":"dev/bot-integre/#developper-en-mode-tock-bot-integre","text":"Le mode Bot int\u00e9gr\u00e9 Tock permet de d\u00e9velopper un bot en utilisant un Domain Specifique Language (DSL) en Kotlin . Contrairement au mode Bot API encore en d\u00e9veloppement, le Bot Framework Kotlin permet d'exploiter toutes les possibilit\u00e9s de la plateforme Tock, notamment : Gestion des contextes utilisateurs Historique de conversation Notions avanc\u00e9es comme la fusion d'entit\u00e9s Etc. Exemple de fusion d'entit\u00e9s : lorsque un utilisateur demande \"demain\" dans une phrase (appelons cette entit\u00e9 date ) puis \"plut\u00f4t le soir\" dans une phrase suivante, la fusion permet de mettre \u00e0 jour automatiquement l'entit\u00e9 ( date ) avec les deux informations compl\u00e9mentaires : jour et cr\u00e9neau horaire dans cet exemple. Attention : dans ce mode de d\u00e9veloppement, contrairement au mode Bot API , il est n\u00e9cessaire que le module bot dispose d'une connexion \u00e0 la base de donn\u00e9e (MongoDB) de la plateforme Tock utilis\u00e9e. Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage de programmation Kotlin .","title":"D\u00e9velopper en mode Tock Bot int\u00e9gr\u00e9"},{"location":"dev/bot-integre/#demarrer-avec-le-framework","text":"","title":"D\u00e9marrer avec le framework"},{"location":"dev/bot-integre/#documentation-kdoc","text":"La documentation du framework au format KDoc est disponible ici .","title":"Documentation KDoc"},{"location":"dev/bot-integre/#dependance-bot-toolkit","text":"Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance bot-tookit \u00e0 l'application / au projet Kotlin. Par exemple dans un projet Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> bot-toolkit </artifactId> <version> 20.9.2-1 </version> </dependency> Ou dans un projet Gradle : compile 'ai.tock:bot-toolkit:20.9.2-1'","title":"D\u00e9pendance bot-toolkit"},{"location":"dev/bot-integre/#un-bot-est-un-ensemble-de-parcours-stories","text":"Voici par exemple comment le Bot Open Data est d\u00e9fini : val openBot = bot ( \"bot_open_data\" , stories = listOf ( greetings , departures , arrivals , search ), hello = greetings ) Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de parcours ou stories . Une Story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\" (voir Concepts ). Ici le bot d\u00e9finit 4 parcours : greetings , departures , arrivals et search . Le parcours greetings est d\u00e9clar\u00e9 comme parcours principal, il sera pr\u00e9sent\u00e9 par d\u00e9faut au d\u00e9but d'une conversation : hello = greetings .","title":"Un bot est un ensemble de parcours (stories)"},{"location":"dev/bot-integre/#une-story-simple","text":"Comment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e du parcours greetings : val greetings = story ( \"greetings\" ) { send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) end ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) } Notez que dans le corps de la fonction, this est de type BotBus , \u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der \u00e0 tous les \u00e9lements contextuels disponibles. Concr\u00e8tement sela signifie que quand l'intention greetings sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock. Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse ( bus.send() ), puis un deuxi\u00e8me en indiquant que c'est la derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un bus.end() . Voici maintenant la version compl\u00e8te de greetings : val greetings = story ( \"greetings\" ) { //cleanup state resetDialogState () send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) send ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) withMessenger { buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) } withGoogleAssistant { gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) } end () } Deux notions ont \u00e9t\u00e9 ajout\u00e9es : resetDialogState() qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents) les m\u00e9thodes withMessenger{} et withGoogleAssistant{} qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur. Ici un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant.","title":"Une Story simple"},{"location":"dev/bot-integre/#demarrer-et-connecter-le-bot","text":"Pour d\u00e9marrer le bot, il suffit de rajouter dans votre main principal l'appel suivant : registerAndInstallBot ( openBot ) La variable openBot dans l'exemple est le bot que vous avez d\u00e9fini plus haut. Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s dans l'interface d'administration du bot, du menu Configuration > Bot Configurations > Create a new configuration . Pour en savoir plus sur les diff\u00e9rents canaux et connecteurs, voir cette page .","title":"D\u00e9marrer et connecter le bot"},{"location":"dev/bot-integre/#importer-la-configuration-dumps","text":"Il est possible d'exporter diff\u00e9rentes configurations depuis Tock Studio, puis les importer automatiquement au d\u00e9marrage du bot. Une fois export\u00e9s les fichiers dumps de Tock Studio dans le classpath du bot, on peut appeler une ou plusieurs des fonctions suivantes depuis le main : importApplicationDump : importe une application \u00e0 partir d'un dump d'application . Remarque : l'import est ignor\u00e9 si l'application cible existe d\u00e9j\u00e0. importNlpDump : importe un mod\u00e8le NLP (intentions, phrases, entit\u00e9s) \u00e0 partir d'un dump NLP . importI18nDump : importe des labels (aka i18n ) \u00e0 partir d'un dump de labels . Exemple : fun main ( args : Array < String >) { registerAndInstallBot ( bot ) // Import application importApplicationDump ( \"/bot_app_dump.json\" ) // Import NLP model (intents, sentences, entities...) importNlpDump ( \"/bot_nlp_dump.json\" ) // Import story labels (aka i18n) importI18nDump ( \"/bot_labels_dump.json\" ) }","title":"Importer la configuration (dumps)"},{"location":"dev/bot-integre/#aller-plus-loin","text":"Bien s\u00fbr, le StoryHandler de greetings ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame. Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire.","title":"Aller plus loin"},{"location":"dev/bot-integre/#intentions-secondaires","text":"Voici le d\u00e9but de la d\u00e9finition de la story search : val search = storyDef < SearchDef >( \"search\" , otherStarterIntents = setOf ( indicate_origin ), secondaryIntents = setOf ( indicate_location )) { } Le parcours search d\u00e9finit une intention secondaire \"de d\u00e9marrage\" ( indicate_origin ) et une intention secondaire simple ( indicate_location ). Une intention secondaire \"de d\u00e9marrage\" est semblable en tout point \u00e0 une intention principale : d\u00e8s que cette intention est d\u00e9tect\u00e9e, le parcours search va \u00eatre ex\u00e9cut\u00e9, si la story courante ne poss\u00e8de pas cette intention en tant qu'intention secondaire. Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte est \"d\u00e9j\u00e0\" la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires.","title":"Intentions secondaires"},{"location":"dev/bot-integre/#manipuler-les-entites","text":"Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des extensions . Par exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 destination : val destinationEntity = openBot . entity ( \"location\" , \"destination\" ) var BotBus . destination : Place ? get () = place ( destinationEntity ) set ( value ) = setPlace ( destinationEntity , value ) private fun BotBus . place ( entity : Entity ): Place ? = entityValue ( entity , :: placeValue ) ?. place private fun BotBus . setPlace ( entity : Entity , place : Place ?) = changeEntityValue ( entity , place ?. let { PlaceValue ( place ) }) Une entit\u00e9 de type location et de role destination est cr\u00e9\u00e9e. Il s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP. Une variable destination est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier. Cette variable contient la valeur actuelle de la destination dans le contexte utilisateur. Voici une version compl\u00e9t\u00e9e de la story search qui utilise destination : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0. Idem pour l'origine ou la date de d\u00e9part. Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe ( SearchDef ). La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //handle generic location intent if ( isIntent ( indicate_location ) && location != null ) { if ( destination == null || origin != null ) { destination = returnsAndRemoveLocation () } else { origin = returnsAndRemoveLocation () } } //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est indicate_location , nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination. Il est donc cod\u00e9 une r\u00e8gle simple : Si il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination. Sinon, il s'agit de l'origine.","title":"Manipuler les entit\u00e9s"},{"location":"dev/bot-integre/#utiliser-handlerdef","text":"Dans la d\u00e9finition de la story search ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique SearchDef . Voici le code de cette classe : @GAHandler ( GASearchConnector :: class ) @MessengerHandler ( MessengerSearchConnector :: class ) class SearchDef ( bus : BotBus ) : HandlerDef < SearchConnector >( bus ) { private val d : Place = bus . destination !! private val o : Place = bus . origin !! private val date : LocalDateTime = bus . departureDate !! override fun answer () { send ( \"De {0} \u00e0 {1}\" , o , d ) send ( \"D\u00e9part le {0}\" , date by datetimeFormat ) val journeys = SncfOpenDataClient . journey ( o , d , date ) if ( journeys . isEmpty ()) { end ( \"D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :(\" ) } else { send ( \"Voici la premi\u00e8re proposition :\" ) connector ?. sendFirstJourney ( journeys . first ()) end () } } } SearchDef \u00e9tend HandlerDef qui est un alias d'une classe du framework Tock. C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des parcours complexes. Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire : SearchConnector . SearchConnector est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations @GAHandler(GASearchConnector::class) et @MessengerHandler(MessengerSearchConnector::class) indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger). Que se passerait-il s'il n'y avait pas de connecteur pour Google Assistant par exemple ? La m\u00e9thode connector?.sendFirstJourney(journeys.first()) n'enverrait pas la r\u00e9ponse finale, puisque connector serait null .","title":"Utiliser HandlerDef"},{"location":"dev/bot-integre/#utiliser-connectordef","text":"Voici maintenant une version simplifi\u00e9e de SearchConnector : sealed class SearchConnector ( context : SearchDef ) : ConnectorDef < SearchDef >( context ) { fun Section . title (): CharSequence = i18n ( \"{0} - {1}\" , from , to ) fun sendFirstJourney ( journey : Journey ) = withMessage ( sendFirstJourney ( journey . publicTransportSections ())) abstract fun sendFirstJourney ( sections : List < Section >): ConnectorMessage } Et voici son impl\u00e9mentation pour Messenger : class MessengerSearchConnector ( context : SearchDef ) : SearchConnector ( context ) { override fun sendFirstJourney ( sections : List < Section >): ConnectorMessage = flexibleListTemplate ( sections . map { section -> with ( section ) { listElement ( title (), content (), trainImage ) } }, compact ) } Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans SearchConnector et le comportement sp\u00e9cifique \u00e0 chaque connecteur se trouve dans les classes d\u00e9di\u00e9es.","title":"Utiliser ConnectorDef"},{"location":"dev/bot-integre/#utiliser-storystep","text":"Parfois il est n\u00e9cessaire de se souvenir de l'\u00e9tape \u00e0 laquelle l'utilisateur se trouve dans la story courante. Pour cela Tock met \u00e0 disposition la notion de StoryStep . Il existe deux types de StoryStep :","title":"Utiliser StoryStep"},{"location":"dev/bot-integre/#simplestorystep","text":"A utiliser dans les cas simples, pour lequels on va g\u00e9rer le comportement induit directement : enum class MyStep : SimpleStoryStep { a , b } val story = storyWithSteps < MyStep >( \"intent\" ) { if ( step == a ) { // ... } else if ( step == b ) { // ... } else { //default case } } Pour modifier l'\u00e9tape courante, deux m\u00e9thodes sont disponibles : Modifier manuellement l'\u00e9tape val story = storyWithSteps < MyStep >( \"intent\" ) { //(...) step = MyStep . a // l'\u00e9tape sera persist\u00e9e tant que nous resterons dans cette story } Utiliser les boutons ou autres quick replies Plus de d\u00e9tails sur ce sujet plus bas .","title":"SimpleStoryStep"},{"location":"dev/bot-integre/#les-storystep-avec-comportement","text":"Dans des cas plus complexes, on souhaite pouvoir d\u00e9finir un comportement pour chaque \u00e9tape. L'utilisation de HandlerDef est alors un pr\u00e9requis. enum class MySteps : StoryStep < MyHandlerDef > { //pas de comportement sp\u00e9cifique display , select { // la step \"select\" sera automatiquement s\u00e9lectionn\u00e9e si la sous-intention select est d\u00e9tect\u00e9e override val intent : IntentAware ? = SecondaryIntent . select //dans ce cas la r\u00e9ponse suivante sera apport\u00e9e override fun answer (): MyHandlerDef .() -> Any ? = { end ( \"I don't know yet how to select something\" ) } }, disruption { //seule la r\u00e9ponse est configur\u00e9e override fun answer (): ScoreboardDef .() -> Any ? = { end ( \"some perturbation\" ) } }; } Davantage d'options de configuration sont disponibles. Consultez la description de StoryStep .","title":"Les StoryStep avec comportement"},{"location":"dev/bot-integre/#postback-buttons-quick-replies","text":"Messenger met \u00e0 disposition ce type de bouton, et la plupart des connecteurs avec interface graphique font de m\u00eame. Tock permet de d\u00e9finir l'action effectu\u00e9e suite \u00e0 un clic sur ces boutons. Dans l'exemple suivant, le bouton redirigera vers l'intention search . buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , search ) ) Il est possible de d\u00e9finir \u00e9galement une StoryStep et des param\u00e8tres d\u00e9di\u00e9s : //pour d\u00e9finir des param\u00e8tres, la pratique recommand\u00e9e est d'\u00e9tendre l'interface ParameterKey enum class ChoiceParameter : ParameterKey { nextResultDate , nextResultOrigin } buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , intent = search , //si aucune step n'est indiqu\u00e9e, c'est la step courante qui est utilis\u00e9e step = MyStep . a , parameters = //ce param\u00e8tre est stock\u00e9 sous forme de cha\u00eene de caract\u00e8re (les crochets sont utilis\u00e9s) nextResultDate [ nextDate ] + //ce param\u00e8tre est stock\u00e9 en json (les parenth\u00e8ses sont utilis\u00e9es) nextResultOrigin ( origin ) ) ) Pour r\u00e9cup\u00e9rer les param\u00e8tres du bouton sur lequel on a cliqu\u00e9 : val isClick = isChoiceAction () val nextDate = choice ( nextResultDate ) val nextOrigin : Locality = action . jsonChoice ( nextResultOrigin )","title":"Postback buttons &amp; quick replies"},{"location":"dev/bot-integre/#tests-unitaires","text":"La page Tests Unitaires pr\u00e9sente le framework fourni pour r\u00e9aliser des TUs avec Tock.","title":"Tests Unitaires"},{"location":"dev/connecteurs/","text":"Les connecteurs Tock \u00b6 La page Bot multicanal de la documentation utilisateur pr\u00e9sente la notion de connecteur Tock, ainsi que la liste des connecteurs d\u00e9j\u00e0 disponibles. Cette page n'ajoute donc que des \u00e9l\u00e9ments propres au d\u00e9veloppement avec les connecteurs Tock ou le d\u00e9veloppement de nouveaux connecteurs. Connecteurs fournis avec Tock \u00b6 Pour en savoir plus sur les connecteurs fournis avec la distribution Tock, vous pouvez aussi vous rendre dans le dossier de chaque connecteur. La page Bot multicanal liste tous les connecteurs disponibles. Par exemple, le dossier connector-messenger contient les sources et le README du connecteur Tock pour Messenger. Kits bas\u00e9s sur le connecteur Web \u00b6 Les composants utilisant le connecteur Web pour int\u00e9grer des bots Tock \u00e0 d'autres canaux sont fournis sur leur propre d\u00e9p\u00f4t GitHub \u00e0 c\u00f4t\u00e9 du d\u00e9p\u00f4t principal Tock. La page Bot multicanal liste tous les kits disponibles. Par exemple, le d\u00e9p\u00f4t tock-react-kit contient les sources et le README du kit pour React. D\u00e9velopper son propre connecteur \u00b6 Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. Un exemple de connecteur sp\u00e9cifique est disponible dans le projet d'exemple Bot Open Data . Pour d\u00e9finir son propre connecteur, quatres \u00e9tapes sont n\u00e9cessaires : 1) Impl\u00e9menter l'interface Connector Voici un exemple d'impl\u00e9mentation : val testConnectorType = ConnectorType ( \"test\" ) class TestConnector ( val applicationId : String , val path : String ) : Connector { override val connectorType : ConnectorType = testConnectorType override fun register ( controller : ConnectorController ) { controller . registerServices ( path ) { router -> //main API router . post ( \"$path/message\" ). blockingHandler { context -> //ConnectorRequest est mon objet m\u00e9tier pass\u00e9 par l'appli front val message : ConnectorRequest = mapper . readValue ( context . bodyAsString ) //transformation de l'objet m\u00e9tier en Event tock val event = readUserMessage ( message ) // on passe l'\u00e9v\u00e8nement au framework val callback = TestConnectorCallback ( applicationId , message . userId , context , controller ) controller . handle ( event , ConnectorData ( callback )) } } } override fun send ( event : Event , callback : ConnectorCallback , delayInMs : Long ) { callback as TestConnectorCallback if ( event is Action ) { //on enregistre l'action callback . actions . add ( event ) //si c'est la derni\u00e8re action \u00e0 envoyer, on envoie la r\u00e9ponse if ( event . metadata . lastAnswer ) { callback . sendAnswer () } } else { logger . trace { \"unsupported event: $event\" } } } } // pour r\u00e9cup\u00e9rer toutes les actions avant envoi class TestConnectorCallback ( override val applicationId : String , val userId : String , val context : RoutingContext , val controller : ConnectorController , val actions : MutableList < Action > = CopyOnWriteArrayList ()): ConnectorCallbackBase ( applicationId , testConnectorType ) { internal fun sendAnswer () { //on transforme la liste des r\u00e9ponses Tock en r\u00e9ponse m\u00e9tier val response = mapper . writeValueAsString ( actions . map {...}) //puis on envoie la r\u00e9ponse context . response (). end ( response ) } } 2) Impl\u00e9menter l'interface ConnectorProvider Voici un exemple d'impl\u00e9mentation : object TestConnectorProvider : ConnectorProvider { override val connectorType : ConnectorType = testConnectorType override fun connector ( connectorConfiguration : ConnectorConfiguration ): Connector { return TestConnector ( connectorConfiguration . connectorId , connectorConfiguration . path ) } } class TestConnectorProviderService : ConnectorProvider by TestConnectorProvider 3) Rendre disponible ce connecteur via un Service Loader : Pour cela, placez un fichier META-INF/services/ai.tock.bot.connector.ConnectorProvider dans le classpath, contenant le nom de la classe : mypackage.TestConnectorProviderService 4) Rajouter toutes les classes et fichiers cr\u00e9\u00e9s dans le classpath de l'admin et du bot. Le nouveau connecteur doit alors \u00eatre disponible dans l'interface Bot Configurations de Tock Studio .","title":"Connecteurs"},{"location":"dev/connecteurs/#les-connecteurs-tock","text":"La page Bot multicanal de la documentation utilisateur pr\u00e9sente la notion de connecteur Tock, ainsi que la liste des connecteurs d\u00e9j\u00e0 disponibles. Cette page n'ajoute donc que des \u00e9l\u00e9ments propres au d\u00e9veloppement avec les connecteurs Tock ou le d\u00e9veloppement de nouveaux connecteurs.","title":"Les connecteurs Tock"},{"location":"dev/connecteurs/#connecteurs-fournis-avec-tock","text":"Pour en savoir plus sur les connecteurs fournis avec la distribution Tock, vous pouvez aussi vous rendre dans le dossier de chaque connecteur. La page Bot multicanal liste tous les connecteurs disponibles. Par exemple, le dossier connector-messenger contient les sources et le README du connecteur Tock pour Messenger.","title":"Connecteurs fournis avec Tock"},{"location":"dev/connecteurs/#kits-bases-sur-le-connecteur-web","text":"Les composants utilisant le connecteur Web pour int\u00e9grer des bots Tock \u00e0 d'autres canaux sont fournis sur leur propre d\u00e9p\u00f4t GitHub \u00e0 c\u00f4t\u00e9 du d\u00e9p\u00f4t principal Tock. La page Bot multicanal liste tous les kits disponibles. Par exemple, le d\u00e9p\u00f4t tock-react-kit contient les sources et le README du kit pour React.","title":"Kits bas\u00e9s sur le connecteur Web"},{"location":"dev/connecteurs/#developper-son-propre-connecteur","text":"Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. Un exemple de connecteur sp\u00e9cifique est disponible dans le projet d'exemple Bot Open Data . Pour d\u00e9finir son propre connecteur, quatres \u00e9tapes sont n\u00e9cessaires : 1) Impl\u00e9menter l'interface Connector Voici un exemple d'impl\u00e9mentation : val testConnectorType = ConnectorType ( \"test\" ) class TestConnector ( val applicationId : String , val path : String ) : Connector { override val connectorType : ConnectorType = testConnectorType override fun register ( controller : ConnectorController ) { controller . registerServices ( path ) { router -> //main API router . post ( \"$path/message\" ). blockingHandler { context -> //ConnectorRequest est mon objet m\u00e9tier pass\u00e9 par l'appli front val message : ConnectorRequest = mapper . readValue ( context . bodyAsString ) //transformation de l'objet m\u00e9tier en Event tock val event = readUserMessage ( message ) // on passe l'\u00e9v\u00e8nement au framework val callback = TestConnectorCallback ( applicationId , message . userId , context , controller ) controller . handle ( event , ConnectorData ( callback )) } } } override fun send ( event : Event , callback : ConnectorCallback , delayInMs : Long ) { callback as TestConnectorCallback if ( event is Action ) { //on enregistre l'action callback . actions . add ( event ) //si c'est la derni\u00e8re action \u00e0 envoyer, on envoie la r\u00e9ponse if ( event . metadata . lastAnswer ) { callback . sendAnswer () } } else { logger . trace { \"unsupported event: $event\" } } } } // pour r\u00e9cup\u00e9rer toutes les actions avant envoi class TestConnectorCallback ( override val applicationId : String , val userId : String , val context : RoutingContext , val controller : ConnectorController , val actions : MutableList < Action > = CopyOnWriteArrayList ()): ConnectorCallbackBase ( applicationId , testConnectorType ) { internal fun sendAnswer () { //on transforme la liste des r\u00e9ponses Tock en r\u00e9ponse m\u00e9tier val response = mapper . writeValueAsString ( actions . map {...}) //puis on envoie la r\u00e9ponse context . response (). end ( response ) } } 2) Impl\u00e9menter l'interface ConnectorProvider Voici un exemple d'impl\u00e9mentation : object TestConnectorProvider : ConnectorProvider { override val connectorType : ConnectorType = testConnectorType override fun connector ( connectorConfiguration : ConnectorConfiguration ): Connector { return TestConnector ( connectorConfiguration . connectorId , connectorConfiguration . path ) } } class TestConnectorProviderService : ConnectorProvider by TestConnectorProvider 3) Rendre disponible ce connecteur via un Service Loader : Pour cela, placez un fichier META-INF/services/ai.tock.bot.connector.ConnectorProvider dans le classpath, contenant le nom de la classe : mypackage.TestConnectorProviderService 4) Rajouter toutes les classes et fichiers cr\u00e9\u00e9s dans le classpath de l'admin et du bot. Le nouveau connecteur doit alors \u00eatre disponible dans l'interface Bot Configurations de Tock Studio .","title":"D\u00e9velopper son propre connecteur"},{"location":"dev/exemples-code/","text":"Exemples de code Tock \u00b6 Les exemples dans Bot Samples \u00b6 Le d\u00e9p\u00f4t tock-bot-samples contient des exemples de code, notamment ceux utilis\u00e9s dans la documentation Tock pour programmer des parcours en modes WebHook ou WebSocket . Le bot Open Data \u00b6 Le d\u00e9p\u00f4t tock-bot-open-data contient un exemple d'impl\u00e9mentation de bot bas\u00e9 sur les API Open Data de la SNCF . Ce bot utilise le framework Kotlin pour Tock (et pas le mode Bot API via Webhook ou WebSocket ). Il impl\u00e9mente \u00e9galement une internationalisation avec deux langues propos\u00e9es : Fran\u00e7ais et Anglais. D\u00e9ployer le bot avec Docker \u00b6 Pour d\u00e9ployer le bot avec Docker / Docker Compose , suivez les instructions du d\u00e9p\u00f4t tock-docker . D\u00e9ployer le bot dans son IDE \u00b6 Si vous pr\u00e9f\u00e9rez d\u00e9ployer une plateforme Tock sans le Bot Open Data, et ex\u00e9cuter celui-ci dans votre IDE (vous permettant par exemple de faire du debug pas-\u00e0-pas), suivez ces instructions : D\u00e9ployez une stack Tock NLU gr\u00e2ce au descripteur docker-compose.yml comme expliqu\u00e9 ici Demandez votre propre clef SNCF Open Data (gratuite) et configurez la variable d'environnement (voir OpenDataConfiguration ) Configurez un connecteur : Messenger, Google Assistant ou autre (voir canaux et connecteurs ) D\u00e9marrez le lanceur OpenDataBot dans votre IDE, IntelliJ ou autre. Le bot est op\u00e9rationnel, parlez-lui ! :)","title":"Exemples de code"},{"location":"dev/exemples-code/#exemples-de-code-tock","text":"","title":"Exemples de code Tock"},{"location":"dev/exemples-code/#les-exemples-dans-bot-samples","text":"Le d\u00e9p\u00f4t tock-bot-samples contient des exemples de code, notamment ceux utilis\u00e9s dans la documentation Tock pour programmer des parcours en modes WebHook ou WebSocket .","title":"Les exemples dans Bot Samples"},{"location":"dev/exemples-code/#le-bot-open-data","text":"Le d\u00e9p\u00f4t tock-bot-open-data contient un exemple d'impl\u00e9mentation de bot bas\u00e9 sur les API Open Data de la SNCF . Ce bot utilise le framework Kotlin pour Tock (et pas le mode Bot API via Webhook ou WebSocket ). Il impl\u00e9mente \u00e9galement une internationalisation avec deux langues propos\u00e9es : Fran\u00e7ais et Anglais.","title":"Le bot Open Data"},{"location":"dev/exemples-code/#deployer-le-bot-avec-docker","text":"Pour d\u00e9ployer le bot avec Docker / Docker Compose , suivez les instructions du d\u00e9p\u00f4t tock-docker .","title":"D\u00e9ployer le bot avec Docker"},{"location":"dev/exemples-code/#deployer-le-bot-dans-son-ide","text":"Si vous pr\u00e9f\u00e9rez d\u00e9ployer une plateforme Tock sans le Bot Open Data, et ex\u00e9cuter celui-ci dans votre IDE (vous permettant par exemple de faire du debug pas-\u00e0-pas), suivez ces instructions : D\u00e9ployez une stack Tock NLU gr\u00e2ce au descripteur docker-compose.yml comme expliqu\u00e9 ici Demandez votre propre clef SNCF Open Data (gratuite) et configurez la variable d'environnement (voir OpenDataConfiguration ) Configurez un connecteur : Messenger, Google Assistant ou autre (voir canaux et connecteurs ) D\u00e9marrez le lanceur OpenDataBot dans votre IDE, IntelliJ ou autre. Le bot est op\u00e9rationnel, parlez-lui ! :)","title":"D\u00e9ployer le bot dans son IDE"},{"location":"dev/i18n/","text":"D\u00e9velopper un bot multilingue (i18n) \u00b6 La page Bot multilingue de la documentation utilisateur pr\u00e9sente les bases de l'internationalisation ( i18n ) pour construire des bots avec Tock : pr\u00e9-requis, Locale , etc. Cette page vient compl\u00e9ter cette documentation avec des \u00e9l\u00e9ments propres au d\u00e9veloppement. Pr\u00e9-requis \u00b6 Pour activer l'internationalisation dans Tock, programmatiquement ou pas, voir Bot multilingue . Principes \u00b6 Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : send ( \"Arrival at {0}\" , time ) est un code valide que le module soit activ\u00e9 ou non. Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement. Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es : Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot) et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 app_arrivals_Arrival at {0} o\u00f9 app est le namespace et arrivals l'intention principale de la story. Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la langue demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte) Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la langue courante Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration : Format des messages \u00b6 Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe MessageFormat en java. Cela inclut le support de ChoiceFormat : send ( \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\" , 2 ) Par ailleurs, Tock met \u00e0 disposition une extension by pour les dates qui permet d'indiquer un format dans les param\u00e8tres : send ( \"Departure at {0}\" , departureDateTime by timeFormat ) Locale utilisateur \u00b6 Voir Bot multilingue . Points d'attention \u00b6 Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin, sont \u00e0 bannir sous peine de mauvaises surprises. Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9. send ( \"There are $nb files\" ) //DANGER!! mais pose probl\u00e8me si il est activ\u00e9. En effet, un nouveau libell\u00e9 sera cr\u00e9\u00e9 pour chaque valeur diff\u00e9rente de la variable nb ! Si il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez les m\u00e9thodes BotBus.sendRaw , BotBus.endRaw ou String.raw send ( \"There are $nb files\" . raw ) //CORRECT send ( \"There are {0} files\" , nb ) //FORMAT A SUIVRE Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. Si vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode i18nKey : send ( i18nKey ( \"my_unique_key\" , \"There are {0} files\" , nb )) Tester l'internationalisation \u00b6 Un exemple de dispositif de test est disponible dans le code source du bot d'exemple Il est n\u00e9cessaire d'\u00e9tendre l'extension de test pour ensuite indiquer la correspondance des libell\u00e9s \u00e0 tester. Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } }","title":"i18n"},{"location":"dev/i18n/#developper-un-bot-multilingue-i18n","text":"La page Bot multilingue de la documentation utilisateur pr\u00e9sente les bases de l'internationalisation ( i18n ) pour construire des bots avec Tock : pr\u00e9-requis, Locale , etc. Cette page vient compl\u00e9ter cette documentation avec des \u00e9l\u00e9ments propres au d\u00e9veloppement.","title":"D\u00e9velopper un bot multilingue (i18n)"},{"location":"dev/i18n/#pre-requis","text":"Pour activer l'internationalisation dans Tock, programmatiquement ou pas, voir Bot multilingue .","title":"Pr\u00e9-requis"},{"location":"dev/i18n/#principes","text":"Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : send ( \"Arrival at {0}\" , time ) est un code valide que le module soit activ\u00e9 ou non. Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement. Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es : Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot) et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 app_arrivals_Arrival at {0} o\u00f9 app est le namespace et arrivals l'intention principale de la story. Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la langue demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte) Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la langue courante Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration :","title":"Principes"},{"location":"dev/i18n/#format-des-messages","text":"Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe MessageFormat en java. Cela inclut le support de ChoiceFormat : send ( \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\" , 2 ) Par ailleurs, Tock met \u00e0 disposition une extension by pour les dates qui permet d'indiquer un format dans les param\u00e8tres : send ( \"Departure at {0}\" , departureDateTime by timeFormat )","title":"Format des messages"},{"location":"dev/i18n/#locale-utilisateur","text":"Voir Bot multilingue .","title":"Locale utilisateur"},{"location":"dev/i18n/#points-dattention","text":"Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin, sont \u00e0 bannir sous peine de mauvaises surprises. Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9. send ( \"There are $nb files\" ) //DANGER!! mais pose probl\u00e8me si il est activ\u00e9. En effet, un nouveau libell\u00e9 sera cr\u00e9\u00e9 pour chaque valeur diff\u00e9rente de la variable nb ! Si il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez les m\u00e9thodes BotBus.sendRaw , BotBus.endRaw ou String.raw send ( \"There are $nb files\" . raw ) //CORRECT send ( \"There are {0} files\" , nb ) //FORMAT A SUIVRE Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. Si vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode i18nKey : send ( i18nKey ( \"my_unique_key\" , \"There are {0} files\" , nb ))","title":"Points d'attention"},{"location":"dev/i18n/#tester-linternationalisation","text":"Un exemple de dispositif de test est disponible dans le code source du bot d'exemple Il est n\u00e9cessaire d'\u00e9tendre l'extension de test pour ensuite indiquer la correspondance des libell\u00e9s \u00e0 tester. Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } }","title":"Tester l'internationalisation"},{"location":"dev/modes/","text":"D\u00e9velopper des bots avec Tock \u00b6 Tock Studio permet de construire des parcours conversationnels (ou stories ) incluant du texte, des boutons, images, caroussels, etc. Pour aller plus loin il est possible de programmer des parcours des parcours en Kotlin , Javascript , Python ou d'autres langages. Deux modes / frameworks / architectures sont propos\u00e9s : Le mode Bot API \u00b6 Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas) permet de d\u00e9velopper en Kotlin ou d'autres langages avec les clients fournis pour Javascript/Nodejs et Python ou n'importe quel langage gr\u00e2ce \u00e0 l'API de Tock : Ce mode est le seul disponible sur la plateforme de d\u00e9monstration Tock . C'est aussi le seul mode permettant de d\u00e9velopper dans n'importe quel langage de programmation, via l'API. Pour en savoir plus, voir la page Bot API . Le mode Bot int\u00e9gr\u00e9 \u00b6 Dans ce mode, vous pouvez acc\u00e9der \u00e0 toutes les fonctionnalit\u00e9s et possibilit\u00e9s du framework Tock pour d\u00e9velopper un bot. C'est le mode de d\u00e9veloppement historique de Tock, et actuellement la plupart des bots publi\u00e9s par les concepteurs de Tock. sont d\u00e9velopp\u00e9s de cette mani\u00e8re. La mise en place de la solution est plus complexe que le mode Bot API et n\u00e9cessite notamment que le composant bot acc\u00e8de directement \u00e0 la base de donn\u00e9es MongoDB. Il est donc n\u00e9cessaire pour utiliser ce mode : D'installer une plateforme (g\u00e9n\u00e9ralement avec Docker ) sur son poste ou sur un serveur De partager la connexion \u00e0 la base MongoDB entre les poste de d\u00e9veloppement et les autres composants de la plateforme Tock utilis\u00e9e De ma\u00eetriser le langage de programmation Kotlin Pour en savoir plus, voir la page Bot int\u00e9gr\u00e9 .","title":"Modes disponibles"},{"location":"dev/modes/#developper-des-bots-avec-tock","text":"Tock Studio permet de construire des parcours conversationnels (ou stories ) incluant du texte, des boutons, images, caroussels, etc. Pour aller plus loin il est possible de programmer des parcours des parcours en Kotlin , Javascript , Python ou d'autres langages. Deux modes / frameworks / architectures sont propos\u00e9s :","title":"D\u00e9velopper des bots avec Tock"},{"location":"dev/modes/#le-mode-bot-api","text":"Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas) permet de d\u00e9velopper en Kotlin ou d'autres langages avec les clients fournis pour Javascript/Nodejs et Python ou n'importe quel langage gr\u00e2ce \u00e0 l'API de Tock : Ce mode est le seul disponible sur la plateforme de d\u00e9monstration Tock . C'est aussi le seul mode permettant de d\u00e9velopper dans n'importe quel langage de programmation, via l'API. Pour en savoir plus, voir la page Bot API .","title":"Le mode Bot API"},{"location":"dev/modes/#le-mode-bot-integre","text":"Dans ce mode, vous pouvez acc\u00e9der \u00e0 toutes les fonctionnalit\u00e9s et possibilit\u00e9s du framework Tock pour d\u00e9velopper un bot. C'est le mode de d\u00e9veloppement historique de Tock, et actuellement la plupart des bots publi\u00e9s par les concepteurs de Tock. sont d\u00e9velopp\u00e9s de cette mani\u00e8re. La mise en place de la solution est plus complexe que le mode Bot API et n\u00e9cessite notamment que le composant bot acc\u00e8de directement \u00e0 la base de donn\u00e9es MongoDB. Il est donc n\u00e9cessaire pour utiliser ce mode : D'installer une plateforme (g\u00e9n\u00e9ralement avec Docker ) sur son poste ou sur un serveur De partager la connexion \u00e0 la base MongoDB entre les poste de d\u00e9veloppement et les autres composants de la plateforme Tock utilis\u00e9e De ma\u00eetriser le langage de programmation Kotlin Pour en savoir plus, voir la page Bot int\u00e9gr\u00e9 .","title":"Le mode Bot int\u00e9gr\u00e9"},{"location":"dev/tester/","text":"Utiliser le framework de test \u00b6 Tock met \u00e0 disposition des extensions pour tester le bot unitairement. Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie bot-test \u00e0 votre projet. Avec Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> bot-test </artifactId> <version> 20.9.2-1 </version> <scope> test </scope> </dependency> ou Gradle : testCompile 'ai.tock:bot-test:20.9.2-1' L'ensemble de ce framework est document\u00e9 au format KDoc ici . Ecrire un test simple \u00b6 L'ensemble des exemples suivants utilisent JUnit5 . Une extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est disponible . @RegisterExtension @JvmField val ext = TockJUnit5Extension ( bot ) Afin de tester la story greetings du bot Open Data, il suffit d'utiliser la m\u00e9thode ext.send() qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi : @Test fun `greetings story displays welcome message WHEN locale is fr` () { ext . send ( locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) } } Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : lastAnswer . assertMessage ( buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) ) Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur), il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester : ext . send ( connectorType = gaConnectorType , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) lastAnswer . assertMessage ( gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) ) } Tester une Story sp\u00e9cifique \u00b6 Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester ( greetings \u00e9tant la story par d\u00e9faut). Supposons que nous souhaitons la story search , nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante : @Test fun `search story asks for destination WHEN there is no destination in context` () { ext . send ( intent = search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } } Tester un dialogue \u00b6 Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine : @Test fun `search story asks for origin WHEN there is a destination but no origin in context` () { ext . send ( \"Je voudrais rechercher un itin\u00e9raire\" , search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) { firstBusAnswer . assertText ( \"Pour quelle origine?\" ) } ext . send ( \"Paris\" , indicate_location , locationEntity setTo paris ) { firstBusAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Le texte en premier param\u00e8tre de la m\u00e9thode send est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests. Les param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase. Par exemple : private val lille = PlaceValue ( SncfPlace ( \"stop_area\" , 90 , \"Lille Europe\" , \"Lille Europe (Lille)\" , \"stop_area:OCE:SA:87223263\" , Coordinates ( 50.638861 , 3.075774 ) ) ) ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention indicate_location et avec une valeur pour l'entit\u00e9 location qui va \u00eatre la localisation lille Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire indicate_location afin d'indiquer l'origine : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Les variables origin et destination sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction run() .","title":"Tester le mode int\u00e9gr\u00e9"},{"location":"dev/tester/#utiliser-le-framework-de-test","text":"Tock met \u00e0 disposition des extensions pour tester le bot unitairement. Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie bot-test \u00e0 votre projet. Avec Maven : <dependency> <groupId> ai.tock </groupId> <artifactId> bot-test </artifactId> <version> 20.9.2-1 </version> <scope> test </scope> </dependency> ou Gradle : testCompile 'ai.tock:bot-test:20.9.2-1' L'ensemble de ce framework est document\u00e9 au format KDoc ici .","title":"Utiliser le framework de test"},{"location":"dev/tester/#ecrire-un-test-simple","text":"L'ensemble des exemples suivants utilisent JUnit5 . Une extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est disponible . @RegisterExtension @JvmField val ext = TockJUnit5Extension ( bot ) Afin de tester la story greetings du bot Open Data, il suffit d'utiliser la m\u00e9thode ext.send() qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi : @Test fun `greetings story displays welcome message WHEN locale is fr` () { ext . send ( locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) } } Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : lastAnswer . assertMessage ( buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) ) Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur), il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester : ext . send ( connectorType = gaConnectorType , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\" ) lastAnswer . assertMessage ( gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) ) }","title":"Ecrire un test simple"},{"location":"dev/tester/#tester-une-story-specifique","text":"Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester ( greetings \u00e9tant la story par d\u00e9faut). Supposons que nous souhaitons la story search , nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante : @Test fun `search story asks for destination WHEN there is no destination in context` () { ext . send ( intent = search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } }","title":"Tester une Story sp\u00e9cifique"},{"location":"dev/tester/#tester-un-dialogue","text":"Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine : @Test fun `search story asks for origin WHEN there is a destination but no origin in context` () { ext . send ( \"Je voudrais rechercher un itin\u00e9raire\" , search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) { firstBusAnswer . assertText ( \"Pour quelle origine?\" ) } ext . send ( \"Paris\" , indicate_location , locationEntity setTo paris ) { firstBusAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Le texte en premier param\u00e8tre de la m\u00e9thode send est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests. Les param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase. Par exemple : private val lille = PlaceValue ( SncfPlace ( \"stop_area\" , 90 , \"Lille Europe\" , \"Lille Europe (Lille)\" , \"stop_area:OCE:SA:87223263\" , Coordinates ( 50.638861 , 3.075774 ) ) ) ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention indicate_location et avec une valeur pour l'entit\u00e9 location qui va \u00eatre la localisation lille Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire indicate_location afin d'indiquer l'origine : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Les variables origin et destination sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction run() .","title":"Tester un dialogue"},{"location":"guide/api/","text":"Programmer des parcours en Kotlin \u00b6 Les interfaces Tock Studio permettent de cr\u00e9er des bots et des parcours relativement simples, comme des arbres de d\u00e9cision et des r\u00e9ponses \u00e0 des questions courantes. Cela s'av\u00e8re suffisant pour de nombreux cas d'usages conversationnels. Toutefois, il est possible de construire des r\u00e9ponses et des parcours plus complexes : Se brancher \u00e0 un compte utilisateur Aggr\u00e9ger les informations de r\u00e9f\u00e9rentiels m\u00e9tier Appeler les services du SI (Syst\u00e8me d'Information) dans une organisation Int\u00e9grer des API externes pour enrichir ses parcours de services tiers Effectuer des actions et des transactions : cr\u00e9ation de tickets, paiements, etc. Impl\u00e9menter des r\u00e8gles de gestion et comportements sp\u00e9cifiques Optimiser les encha\u00eenements entre les intentions Pour construire des parcours complexes, Tock propose plusieurs modes d'int\u00e9gration destin\u00e9s \u00e0 diff\u00e9rents langages et frameworks de d\u00e9veloppement. Dans ce guide, vous utiliserez le langage Kotlin et le mode WebSocket pour ajouter une intention \u00e0 un bot initi\u00e9 dans Tock Studio . Si vous le souhaitez, vous pouvez sauter cette \u00e9tape et d\u00e9ployer un plateforme avec Docker ou passer directement au manuel utilisateur pour en savoir plus sur les possibilit\u00e9s de Tock Studio . Ce que vous allez cr\u00e9er \u00b6 Une intention Tock d\u00e9velopp\u00e9e avec le langage Kotlin Un programme se connectant au bot en WebSocket pour l'enrichir de parcours programm\u00e9s Pr\u00e9-requis \u00b6 Environ 10 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Si vous ne souhaitez pas utiliser d' IDE , ou Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de r\u00e9aliser le m\u00eame exercice avec d'autres outils. Il est \u00e9galement possible d'utiliser d'autres mani\u00e8res de d\u00e9velopper que le mode WebSocket et d'autres langages que Kotlin. Vous en apprendrez plus dans le manuel utilisateur Tock . Cr\u00e9er un programme Kotlin avec la d\u00e9pendance Tock \u00b6 Il existe de nombreuses mani\u00e8res de cr\u00e9er un projet en Kotlin. Ajoutez au classpath la biblioth\u00e8que tock-bot-api-websocket pour le mode WebSocket . Si vous utilisez Apache Maven , voici un exemple de POM ( pom.xml ) pour Kotlin avec la d\u00e9pendance tock-bot-api-websocket incluse : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> test </groupId> <artifactId> tock-kotlin-websocket </artifactId> <version> 0.0.1-SNAPSHOT </version> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <plugin.kotlin.version> 1.3.41 </plugin.kotlin.version> <plugin.source.version> 3.1.0 </plugin.source.version> <lib.tock.version> 20.9.2-1 </lib.tock.version> </properties> <dependencies> <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> ${lib.tock.version} </version> </dependency> </dependencies> <build> <sourceDirectory> ${project.basedir}/src/main/kotlin </sourceDirectory> <plugins> <plugin> <groupId> org.jetbrains.kotlin </groupId> <artifactId> kotlin-maven-plugin </artifactId> <version> ${plugin.kotlin.version} </version> <executions> <execution> <id> compile </id> <phase> compile </phase> <goals> <goal> compile </goal> </goals> </execution> <execution> <id> test-compile </id> <phase> test-compile </phase> <goals> <goal> test-compile </goal> </goals> </execution> </executions> </plugin> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-source-plugin </artifactId> <version> ${plugin.source.version} </version> <executions> <execution> <id> attach-sources </id> <phase> verify </phase> <goals> <goal> jar-no-fork </goal> </goals> </execution> </executions> </plugin> </plugins> </build> </project> Vous pouvez retrouver ce code et d'autres exemples dans le d\u00e9p\u00f4t tock-bot-samples . Cr\u00e9er une fonction qui se connecte \u00e0 Tock \u00b6 Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import ai.tock.bot.api.client.newBot import ai.tock.bot.api.client.newStory import ai.tock.bot.api.websocket.startWithDemo fun main () { startWithDemo ( // Integrate with the Tock demo platform by default newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // Get your app API key from Bot Configurations in Tock Studio newStory ( \"qui-es-tu\" ) { // Answer for the 'qui-es-tu' story send ( \"Je suis un assistant conversationnel construit avec Tock\" ) end ( \"Comment puis-je aider ?\" ) } ) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration > Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Vous devriez voir appara\u00eetre une ligne de log ressemblant \u00e0 celle-ci : [main] INFO ai.tock.bot.api.websocket.BotApiWebSocketClient - start web socket client: {...} V\u00e9rifiez \u00e9ventuellement que d'autres logs provenant de BotApiWebSocketClient n'indiquent pas d'erreur. Si c'est le cas, il peut s'agir d'une erreur de configuration de la clef d'API. Terminer la configuration dans Tock Studio \u00b6 Retournez dans Tock et allez dans Stories & Answers > Stories D\u00e9cochez l'option Only Configured Stories . Vous voyez alors tous parcours, y compris \"qui-es-tu\" que vous venez de d\u00e9clarer programmatiquement Allez dans Test > Test the Bot et saisissez une ou plusieurs phrases comme \"qui es-tu ?\" par exemple. Vous contastez que le bot ne r\u00e9pond pas encore \u00e0 cette question - il r\u00e9pond peut-\u00eatre m\u00eame \u00e0 une autre intention. Il reste en effet une configuration \u00e0 effectuer pour que la qualification fonctionne. A ce stade, le parcours existe bien dans Tock, mais l' intention n'a pas \u00e9t\u00e9 cr\u00e9\u00e9e automatiquement. Vous pouvez le v\u00e9rifier en regardant la liste des intentions disponibles dans Language Understanding > Intents > build (la cat\u00e9gorie par d\u00e9faut). Ce point sera bient\u00f4t am\u00e9lior\u00e9 ( issue #533 ). Allez dans Language Understanding > Inbox , pour la derni\u00e8re phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Puis terminez la qualification de la phrase avec Validate Si vous avez saisi d'autres phrases pour cette intention, pour chacune d'elles s\u00e9lectionnez l'intention dans la liste puis confirmez avec Validate Retournez dans Test > Test the Bot . Si vous reposez la question, le bot vous donne d\u00e9sormais la r\u00e9ponse construite dans le code Kotlin (ie. \"Je suis un assistant...\"). F\u00e9licitations! \u00b6 Vous venez de configurer votre premi\u00e8re story programmatique en Kotlin. De cette mani\u00e8re, vous pouvez tirer pleinement parti des possibilit\u00e9s d'un langage de programmation pour construire toutes sortes de parcours simples et complexes, interroger des API tierces, impl\u00e9menter des r\u00e8gles de gestion, etc. Si vous programmez ainsi une story d\u00e9j\u00e0 d\u00e9finie dans Tock Studio , c'est la d\u00e9finition pr\u00e9sente dans Tock Studio qui est utilis\u00e9e pour construire les r\u00e9ponses \u00e0 l'ex\u00e9cution. Continuer... \u00b6 Dans la section suivante vous apprendez \u00e0 : D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur l'utilisation de Tock Bot API en mode WebSocket , mais aussi les autres modes de d\u00e9ploiement, les types de messages support\u00e9s par Tock, etc. vous pouvez consulter le manuel utilisateur .","title":"Programmer des parcours"},{"location":"guide/api/#programmer-des-parcours-en-kotlin","text":"Les interfaces Tock Studio permettent de cr\u00e9er des bots et des parcours relativement simples, comme des arbres de d\u00e9cision et des r\u00e9ponses \u00e0 des questions courantes. Cela s'av\u00e8re suffisant pour de nombreux cas d'usages conversationnels. Toutefois, il est possible de construire des r\u00e9ponses et des parcours plus complexes : Se brancher \u00e0 un compte utilisateur Aggr\u00e9ger les informations de r\u00e9f\u00e9rentiels m\u00e9tier Appeler les services du SI (Syst\u00e8me d'Information) dans une organisation Int\u00e9grer des API externes pour enrichir ses parcours de services tiers Effectuer des actions et des transactions : cr\u00e9ation de tickets, paiements, etc. Impl\u00e9menter des r\u00e8gles de gestion et comportements sp\u00e9cifiques Optimiser les encha\u00eenements entre les intentions Pour construire des parcours complexes, Tock propose plusieurs modes d'int\u00e9gration destin\u00e9s \u00e0 diff\u00e9rents langages et frameworks de d\u00e9veloppement. Dans ce guide, vous utiliserez le langage Kotlin et le mode WebSocket pour ajouter une intention \u00e0 un bot initi\u00e9 dans Tock Studio . Si vous le souhaitez, vous pouvez sauter cette \u00e9tape et d\u00e9ployer un plateforme avec Docker ou passer directement au manuel utilisateur pour en savoir plus sur les possibilit\u00e9s de Tock Studio .","title":"Programmer des parcours en Kotlin"},{"location":"guide/api/#ce-que-vous-allez-creer","text":"Une intention Tock d\u00e9velopp\u00e9e avec le langage Kotlin Un programme se connectant au bot en WebSocket pour l'enrichir de parcours programm\u00e9s","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/api/#pre-requis","text":"Environ 10 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Si vous ne souhaitez pas utiliser d' IDE , ou Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de r\u00e9aliser le m\u00eame exercice avec d'autres outils. Il est \u00e9galement possible d'utiliser d'autres mani\u00e8res de d\u00e9velopper que le mode WebSocket et d'autres langages que Kotlin. Vous en apprendrez plus dans le manuel utilisateur Tock .","title":"Pr\u00e9-requis"},{"location":"guide/api/#creer-un-programme-kotlin-avec-la-dependance-tock","text":"Il existe de nombreuses mani\u00e8res de cr\u00e9er un projet en Kotlin. Ajoutez au classpath la biblioth\u00e8que tock-bot-api-websocket pour le mode WebSocket . Si vous utilisez Apache Maven , voici un exemple de POM ( pom.xml ) pour Kotlin avec la d\u00e9pendance tock-bot-api-websocket incluse : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> test </groupId> <artifactId> tock-kotlin-websocket </artifactId> <version> 0.0.1-SNAPSHOT </version> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <plugin.kotlin.version> 1.3.41 </plugin.kotlin.version> <plugin.source.version> 3.1.0 </plugin.source.version> <lib.tock.version> 20.9.2-1 </lib.tock.version> </properties> <dependencies> <dependency> <groupId> ai.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> ${lib.tock.version} </version> </dependency> </dependencies> <build> <sourceDirectory> ${project.basedir}/src/main/kotlin </sourceDirectory> <plugins> <plugin> <groupId> org.jetbrains.kotlin </groupId> <artifactId> kotlin-maven-plugin </artifactId> <version> ${plugin.kotlin.version} </version> <executions> <execution> <id> compile </id> <phase> compile </phase> <goals> <goal> compile </goal> </goals> </execution> <execution> <id> test-compile </id> <phase> test-compile </phase> <goals> <goal> test-compile </goal> </goals> </execution> </executions> </plugin> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-source-plugin </artifactId> <version> ${plugin.source.version} </version> <executions> <execution> <id> attach-sources </id> <phase> verify </phase> <goals> <goal> jar-no-fork </goal> </goals> </execution> </executions> </plugin> </plugins> </build> </project> Vous pouvez retrouver ce code et d'autres exemples dans le d\u00e9p\u00f4t tock-bot-samples .","title":"Cr\u00e9er un programme Kotlin avec la d\u00e9pendance Tock"},{"location":"guide/api/#creer-une-fonction-qui-se-connecte-a-tock","text":"Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import ai.tock.bot.api.client.newBot import ai.tock.bot.api.client.newStory import ai.tock.bot.api.websocket.startWithDemo fun main () { startWithDemo ( // Integrate with the Tock demo platform by default newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // Get your app API key from Bot Configurations in Tock Studio newStory ( \"qui-es-tu\" ) { // Answer for the 'qui-es-tu' story send ( \"Je suis un assistant conversationnel construit avec Tock\" ) end ( \"Comment puis-je aider ?\" ) } ) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration > Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Vous devriez voir appara\u00eetre une ligne de log ressemblant \u00e0 celle-ci : [main] INFO ai.tock.bot.api.websocket.BotApiWebSocketClient - start web socket client: {...} V\u00e9rifiez \u00e9ventuellement que d'autres logs provenant de BotApiWebSocketClient n'indiquent pas d'erreur. Si c'est le cas, il peut s'agir d'une erreur de configuration de la clef d'API.","title":"Cr\u00e9er une fonction qui se connecte \u00e0 Tock"},{"location":"guide/api/#terminer-la-configuration-dans-tock-studio","text":"Retournez dans Tock et allez dans Stories & Answers > Stories D\u00e9cochez l'option Only Configured Stories . Vous voyez alors tous parcours, y compris \"qui-es-tu\" que vous venez de d\u00e9clarer programmatiquement Allez dans Test > Test the Bot et saisissez une ou plusieurs phrases comme \"qui es-tu ?\" par exemple. Vous contastez que le bot ne r\u00e9pond pas encore \u00e0 cette question - il r\u00e9pond peut-\u00eatre m\u00eame \u00e0 une autre intention. Il reste en effet une configuration \u00e0 effectuer pour que la qualification fonctionne. A ce stade, le parcours existe bien dans Tock, mais l' intention n'a pas \u00e9t\u00e9 cr\u00e9\u00e9e automatiquement. Vous pouvez le v\u00e9rifier en regardant la liste des intentions disponibles dans Language Understanding > Intents > build (la cat\u00e9gorie par d\u00e9faut). Ce point sera bient\u00f4t am\u00e9lior\u00e9 ( issue #533 ). Allez dans Language Understanding > Inbox , pour la derni\u00e8re phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Puis terminez la qualification de la phrase avec Validate Si vous avez saisi d'autres phrases pour cette intention, pour chacune d'elles s\u00e9lectionnez l'intention dans la liste puis confirmez avec Validate Retournez dans Test > Test the Bot . Si vous reposez la question, le bot vous donne d\u00e9sormais la r\u00e9ponse construite dans le code Kotlin (ie. \"Je suis un assistant...\").","title":"Terminer la configuration dans Tock Studio"},{"location":"guide/api/#felicitations","text":"Vous venez de configurer votre premi\u00e8re story programmatique en Kotlin. De cette mani\u00e8re, vous pouvez tirer pleinement parti des possibilit\u00e9s d'un langage de programmation pour construire toutes sortes de parcours simples et complexes, interroger des API tierces, impl\u00e9menter des r\u00e8gles de gestion, etc. Si vous programmez ainsi une story d\u00e9j\u00e0 d\u00e9finie dans Tock Studio , c'est la d\u00e9finition pr\u00e9sente dans Tock Studio qui est utilis\u00e9e pour construire les r\u00e9ponses \u00e0 l'ex\u00e9cution.","title":"F\u00e9licitations!"},{"location":"guide/api/#continuer","text":"Dans la section suivante vous apprendez \u00e0 : D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur l'utilisation de Tock Bot API en mode WebSocket , mais aussi les autres modes de d\u00e9ploiement, les types de messages support\u00e9s par Tock, etc. vous pouvez consulter le manuel utilisateur .","title":"Continuer..."},{"location":"guide/messenger/","text":"Configurer son bot pour Messenger \u00b6 Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack. Dans ce guide, vous allez cr\u00e9er une configuration pour Facebook Messenger et int\u00e9grer le bot pour dialoguer avec lui sur ce r\u00e9seau social. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et passer directement \u00e0 la suite . Ce que vous allez cr\u00e9er \u00b6 Une configuration (dans Facebook et dans Tock) pour recevoir et envoyer des messages via Messenger Un bot qui parle sur une page Facebook ou dans Messenger Pr\u00e9-requis \u00b6 Environ 20 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Facebook Developer Cr\u00e9er une page Facebook \u00b6 Cr\u00e9ez une page Facebook Donnez-lui un nom (par exemple My Tock Bot ) Recommandation : ne publiez pas la page pour limiter son acc\u00e8s des utilisateurs Messenger : Param\u00e8tres > G\u00e9n\u00e9ral > Visibilit\u00e9 de la page > Non publi\u00e9e Cr\u00e9er une application Facebook \u00b6 Allez sur la page Facebook for developers > Voir toutes les applications Ajouter une app Entrez un nom pour l' application Cr\u00e9er un ID d'app ... Notez l'ID de la page, vous en aurez besoin plus tard. Ajoutez un produit : Messenger Dans les param\u00e8tres, g\u00e9n\u00e9rez un jeton ( token ) pour votre page. Notez ce token pour la suite. Configurer un connecteur Messenger dans Tock \u00b6 Dans Tock Studio allez dans Settings > Configurations Cr\u00e9ez un connecteur de type Messenger et ouvrez la section Connector Custom Configuration Configurez l'ID de page et le token pr\u00e9c\u00e9demment g\u00e9n\u00e9r\u00e9s c\u00f4t\u00e9 Facebook Comme Webhook token , saisissez token (par exemple) Dans le champ Secret , entrez la clef secr\u00e8te que vous trouverez dans le portail Facebook for developers : param\u00e8tres > g\u00e9n\u00e9ral > afficher la clef secr\u00e8te V\u00e9rifiez que la configuration du connecteur est bien enregistr\u00e9e ... Testez votre bot sur Messenger ! F\u00e9licitations! \u00b6 Votre bot dialogue d\u00e9sormais sur Messenger, en plus des autres canaux auquel vous l'avez int\u00e9gr\u00e9. Le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant sont construits et restent ind\u00e9pendants des canaux sur lesquels le bot est pr\u00e9sent. Toutefois, rien ne vous emp\u00eache de cr\u00e9er des parcours ou des r\u00e9ponses sp\u00e9cifiquement pour tel ou tel canal, comme vous le verrez au travers de diff\u00e9rents outils Tock : \u00e9cran de gestion des Responses , activation d'intentions sur tel ou tel canal avec l'\u00e9cran Story Rules , utilisation des DSLs et de la Bot API pour tirer parti de composants graphiques sp\u00e9cifiques, etc. Continuer... \u00b6 Dans les sections suivantes vous apprendez \u00e0 : Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Configurer Messenger"},{"location":"guide/messenger/#configurer-son-bot-pour-messenger","text":"Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack. Dans ce guide, vous allez cr\u00e9er une configuration pour Facebook Messenger et int\u00e9grer le bot pour dialoguer avec lui sur ce r\u00e9seau social. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et passer directement \u00e0 la suite .","title":"Configurer son bot pour Messenger"},{"location":"guide/messenger/#ce-que-vous-allez-creer","text":"Une configuration (dans Facebook et dans Tock) pour recevoir et envoyer des messages via Messenger Un bot qui parle sur une page Facebook ou dans Messenger","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/messenger/#pre-requis","text":"Environ 20 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Facebook Developer","title":"Pr\u00e9-requis"},{"location":"guide/messenger/#creer-une-page-facebook","text":"Cr\u00e9ez une page Facebook Donnez-lui un nom (par exemple My Tock Bot ) Recommandation : ne publiez pas la page pour limiter son acc\u00e8s des utilisateurs Messenger : Param\u00e8tres > G\u00e9n\u00e9ral > Visibilit\u00e9 de la page > Non publi\u00e9e","title":"Cr\u00e9er une page Facebook"},{"location":"guide/messenger/#creer-une-application-facebook","text":"Allez sur la page Facebook for developers > Voir toutes les applications Ajouter une app Entrez un nom pour l' application Cr\u00e9er un ID d'app ... Notez l'ID de la page, vous en aurez besoin plus tard. Ajoutez un produit : Messenger Dans les param\u00e8tres, g\u00e9n\u00e9rez un jeton ( token ) pour votre page. Notez ce token pour la suite.","title":"Cr\u00e9er une application Facebook"},{"location":"guide/messenger/#configurer-un-connecteur-messenger-dans-tock","text":"Dans Tock Studio allez dans Settings > Configurations Cr\u00e9ez un connecteur de type Messenger et ouvrez la section Connector Custom Configuration Configurez l'ID de page et le token pr\u00e9c\u00e9demment g\u00e9n\u00e9r\u00e9s c\u00f4t\u00e9 Facebook Comme Webhook token , saisissez token (par exemple) Dans le champ Secret , entrez la clef secr\u00e8te que vous trouverez dans le portail Facebook for developers : param\u00e8tres > g\u00e9n\u00e9ral > afficher la clef secr\u00e8te V\u00e9rifiez que la configuration du connecteur est bien enregistr\u00e9e ... Testez votre bot sur Messenger !","title":"Configurer un connecteur Messenger dans Tock"},{"location":"guide/messenger/#felicitations","text":"Votre bot dialogue d\u00e9sormais sur Messenger, en plus des autres canaux auquel vous l'avez int\u00e9gr\u00e9. Le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant sont construits et restent ind\u00e9pendants des canaux sur lesquels le bot est pr\u00e9sent. Toutefois, rien ne vous emp\u00eache de cr\u00e9er des parcours ou des r\u00e9ponses sp\u00e9cifiquement pour tel ou tel canal, comme vous le verrez au travers de diff\u00e9rents outils Tock : \u00e9cran de gestion des Responses , activation d'intentions sur tel ou tel canal avec l'\u00e9cran Story Rules , utilisation des DSLs et de la Bot API pour tirer parti de composants graphiques sp\u00e9cifiques, etc.","title":"F\u00e9licitations!"},{"location":"guide/messenger/#continuer","text":"Dans les sections suivantes vous apprendez \u00e0 : Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Continuer..."},{"location":"guide/plateforme/","text":"D\u00e9ployer une plateforme avec Docker \u00b6 Dans les sections pr\u00e9c\u00e9dentes pour d\u00e9couvrir et tester Tock, vous avez utilis\u00e9 la plateforme de d\u00e9monstration . Cela vous a permis de d\u00e9couvrir la construction et la configuration des bots Tock sans avoir \u00e0 installer la plateforme au pr\u00e9alable. Dans ce guide, vous allez apprendre \u00e0 d\u00e9ployer une plateforme compl\u00e8te Tock en quelques minutes, gr\u00e2ce aux exemples d'impl\u00e9mentations Docker / Docker Compose fournies. Notez qu'il est tout \u00e0 fait possible de d\u00e9ployer Tock sans utiliser Docker. Une section sp\u00e9cifique du manuel utilisateur vous en apprendra plus sur l'architecture, les possibilit\u00e9s et les recommandations pour le d\u00e9ploiement et l'utilisation de Tock en production. Ce que vous allez cr\u00e9er \u00b6 Une plateforme Tock compl\u00e8te en local : Tock Studio , Bot API , etc. Un bot et une configuration minimale pour tester la plateforme (Optionnel) Un programme Kotlin se connectant \u00e0 la plateforme locale en WebSocket Pr\u00e9-requis \u00b6 Environ 20 minutes Pour d\u00e9ployer la plateforme en local, un environnement de d\u00e9veloppement avec des versions r\u00e9centes de Docker et Docker Compose install\u00e9es Si vous ne souhaitez pas utiliser Docker, pas de probl\u00e8me. Il y a d'autres mani\u00e8res de d\u00e9ployer la base MongoDB et les services Kotlin sur JVM. Vous pouvez toutefois parcourir les Dockerfile et docker-compose.yml \u00e0 titre d'exemples pour instancier ces services. (Optionnel) Pour le programme en WebSocket, un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Sans IDE ou sans Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de compiler et ex\u00e9cuter le programme avec d'autres outils. D'autres modes que Kotlin et WebSocket sont pr\u00e9sent\u00e9s dans le manuel utilisateur Tock . D\u00e9ployer une plateforme Tock - sans les sources \u00b6 Il est possible de r\u00e9cup\u00e9rer seulement quelques fichiers du d\u00e9p\u00f4t GitHub, sans t\u00e9l\u00e9charger toutes les sources Tock. En quelques lignes de commande, la plateforme est op\u00e9rationnelle. Il est cependant indispensable d'avoir des versions r\u00e9centes de Docker et Docker Compose . Pour d\u00e9marrer depuis les sources du d\u00e9p\u00f4t Tock Docker, passez plut\u00f4t au paragraphe suivant . # Get the lastest docker-compose from GitHub (including Bot API) $ curl -o docker-compose.yml https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/docker-compose-bot.yml # Get the lastest database-init script from GitHub $ mkdir -p scripts && curl -o scripts/setup.sh https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/scripts/setup.sh && chmod +x scripts/setup.sh # Get the lastest Tock version/tag from GitHub $ curl -o .env https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/.env # Run the stack $ docker-compose up D\u00e9ployer une plateforme Tock - depuis les sources \u00b6 Ceci est une mani\u00e8re alternative de d\u00e9marrer Tock, \u00e0 partir du d\u00e9p\u00f4t Tock Docker . Il vous faut, en plus de Docker et Docker Compose , soit un client Git pour r\u00e9cup\u00e9rer les sources (commande git clone ) soit avoir d\u00e9j\u00e0 copi\u00e9 les sources de GitHub en local. Pour d\u00e9marrer sans Git ni les sources du d\u00e9p\u00f4t en local, suivez le paragraphe pr\u00e9c\u00e9dent . # Get the lastest sources from GitHub $ git clone https://github.com/theopenconversationkit/tock-docker.git && cd tock-docker # Make the database-init script executable $ chmod +x scripts/setup.sh # Run the stack (including Bot API) $ docker-compose -f docker-compose-bot.yml up Acc\u00e9der \u00e0 Tock Studio \u00b6 Une fois la plateforme pr\u00eate, les interfaces Tock Studio sont sur le port 80 par d\u00e9faut : Allez sur http://localhost Apr\u00e8s le d\u00e9ploiement de la plateforme, celle-ci s'initialise, et il peut falloir attendre quelques secondes avant que les interfaces Tock Studio soient accessibles. Connectez-vous avec les identifiants admin@app.com / password par d\u00e9faut Il est \u00e9videmment recommand\u00e9 de changer ces valeurs \u00e0 l'installation d'une plateforme destin\u00e9e \u00e0 une utilisation p\u00e9renne (production, plateforme partag\u00e9e entre \u00e9quipes, etc.). Cr\u00e9er une application, un connecteur et une intention \u00b6 Comme dans le guide premier bot utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Tock et un connecteur pour commencer \u00e0 utiliser la plateforme locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de commentaires. Au premier acc\u00e8s \u00e0 la plateforme locale : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Allez dans Settings > Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Create Notez l' API Key automatiquement g\u00e9n\u00e9r\u00e9e pour votre application. Elle vous servira si vous essayez le mode WebSocket dans la suite de ce guide (optionnel). Allez dans Stories & Answers > New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Allez dans Test > Test the Bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16 Connecter un parcours en Kotlin (optionnel) \u00b6 Comme dans le guide programmer des parcours utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Kotlin se connectant en WebSocket \u00e0 la plateforme Tock locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de d\u00e9tails. Cr\u00e9ez un projet Kotlin par exemple avec Maven comme indiqu\u00e9 dans le guide programmer des parcours Le classpath doit inclure tock-bot-api-websocket pour utiliser le mode WebSocket . Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import ai.tock.bot.api.client.newBot import ai.tock.bot.api.client.newStory import ai.tock.bot.api.websocket.start fun main () { start ( // Do not use #startWithDemo when integrating with a local platform newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // Get your app API key from Bot Configurations in Tock Studio newStory ( \"qui-es-tu\" ) { // Answer for the 'qui-es-tu' story send ( \"Je suis un assistant conversationnel construit avec Tock\" ) end ( \"Comment puis-je aider ?\" ) } ), \"http://localhost:8080\" // Local platform URL (default host/port) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Settings > Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Retournez dans Tock dans Test > Test the Bot et dites \"qui es-tu ?\" : le bot ne r\u00e9pond pas encore. Allez dans Language Understanding > Inbox , pour la phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Terminez la qualification de la phrase avec Validate Retournez dans Test > Test the Bot . Dites \"qui es-tu ?\" : le bot r\u00e9pond ! F\u00e9licitations! \u00b6 Vous venez de d\u00e9ployer votre propre plateforme conversationnelle Tock en local. Cela peut servir \u00e0 mieux appr\u00e9hender l'architecture et v\u00e9rifier la portabilit\u00e9 de la solution, mais aussi lors de d\u00e9veloppements, pour les contributeurs Tock ou encore si vous devez travailler sans acc\u00e8s \u00e0 Internet (en mobilit\u00e9, sur un r\u00e9seau restreint, etc.). Attention, l'impl\u00e9mentation Docker fournie ne suffit pas \u00e0 garantir r\u00e9silience et mont\u00e9e en charge de la plateforme quelles que soient les conditions en production. Pour cela, quelques recommandations sont propos\u00e9es dans la section haute disponibilit\u00e9 du manuel Tock. Continuer... \u00b6 Vous venez de terminer les guides de d\u00e9marrage rapide Tock. A partir de l\u00e0, vous pouvez vous lancer directement sur une plateforme Tock, ou parcourir le manuel utilisateur pour en savoir plus sur Tock Studio , Bot API et Bot Flow par exemple. D'autres pages pr\u00e9sentent aussi des \u00e9tudes de cas clients, des exemples de code, comment contacter la communaut\u00e9 Tock, etc.","title":"D\u00e9ployer avec Docker"},{"location":"guide/plateforme/#deployer-une-plateforme-avec-docker","text":"Dans les sections pr\u00e9c\u00e9dentes pour d\u00e9couvrir et tester Tock, vous avez utilis\u00e9 la plateforme de d\u00e9monstration . Cela vous a permis de d\u00e9couvrir la construction et la configuration des bots Tock sans avoir \u00e0 installer la plateforme au pr\u00e9alable. Dans ce guide, vous allez apprendre \u00e0 d\u00e9ployer une plateforme compl\u00e8te Tock en quelques minutes, gr\u00e2ce aux exemples d'impl\u00e9mentations Docker / Docker Compose fournies. Notez qu'il est tout \u00e0 fait possible de d\u00e9ployer Tock sans utiliser Docker. Une section sp\u00e9cifique du manuel utilisateur vous en apprendra plus sur l'architecture, les possibilit\u00e9s et les recommandations pour le d\u00e9ploiement et l'utilisation de Tock en production.","title":"D\u00e9ployer une plateforme avec Docker"},{"location":"guide/plateforme/#ce-que-vous-allez-creer","text":"Une plateforme Tock compl\u00e8te en local : Tock Studio , Bot API , etc. Un bot et une configuration minimale pour tester la plateforme (Optionnel) Un programme Kotlin se connectant \u00e0 la plateforme locale en WebSocket","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/plateforme/#pre-requis","text":"Environ 20 minutes Pour d\u00e9ployer la plateforme en local, un environnement de d\u00e9veloppement avec des versions r\u00e9centes de Docker et Docker Compose install\u00e9es Si vous ne souhaitez pas utiliser Docker, pas de probl\u00e8me. Il y a d'autres mani\u00e8res de d\u00e9ployer la base MongoDB et les services Kotlin sur JVM. Vous pouvez toutefois parcourir les Dockerfile et docker-compose.yml \u00e0 titre d'exemples pour instancier ces services. (Optionnel) Pour le programme en WebSocket, un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Sans IDE ou sans Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de compiler et ex\u00e9cuter le programme avec d'autres outils. D'autres modes que Kotlin et WebSocket sont pr\u00e9sent\u00e9s dans le manuel utilisateur Tock .","title":"Pr\u00e9-requis"},{"location":"guide/plateforme/#deployer-une-plateforme-tock-sans-les-sources","text":"Il est possible de r\u00e9cup\u00e9rer seulement quelques fichiers du d\u00e9p\u00f4t GitHub, sans t\u00e9l\u00e9charger toutes les sources Tock. En quelques lignes de commande, la plateforme est op\u00e9rationnelle. Il est cependant indispensable d'avoir des versions r\u00e9centes de Docker et Docker Compose . Pour d\u00e9marrer depuis les sources du d\u00e9p\u00f4t Tock Docker, passez plut\u00f4t au paragraphe suivant . # Get the lastest docker-compose from GitHub (including Bot API) $ curl -o docker-compose.yml https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/docker-compose-bot.yml # Get the lastest database-init script from GitHub $ mkdir -p scripts && curl -o scripts/setup.sh https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/scripts/setup.sh && chmod +x scripts/setup.sh # Get the lastest Tock version/tag from GitHub $ curl -o .env https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/.env # Run the stack $ docker-compose up","title":"D\u00e9ployer une plateforme Tock - sans les sources"},{"location":"guide/plateforme/#deployer-une-plateforme-tock-depuis-les-sources","text":"Ceci est une mani\u00e8re alternative de d\u00e9marrer Tock, \u00e0 partir du d\u00e9p\u00f4t Tock Docker . Il vous faut, en plus de Docker et Docker Compose , soit un client Git pour r\u00e9cup\u00e9rer les sources (commande git clone ) soit avoir d\u00e9j\u00e0 copi\u00e9 les sources de GitHub en local. Pour d\u00e9marrer sans Git ni les sources du d\u00e9p\u00f4t en local, suivez le paragraphe pr\u00e9c\u00e9dent . # Get the lastest sources from GitHub $ git clone https://github.com/theopenconversationkit/tock-docker.git && cd tock-docker # Make the database-init script executable $ chmod +x scripts/setup.sh # Run the stack (including Bot API) $ docker-compose -f docker-compose-bot.yml up","title":"D\u00e9ployer une plateforme Tock - depuis les sources"},{"location":"guide/plateforme/#acceder-a-tock-studio","text":"Une fois la plateforme pr\u00eate, les interfaces Tock Studio sont sur le port 80 par d\u00e9faut : Allez sur http://localhost Apr\u00e8s le d\u00e9ploiement de la plateforme, celle-ci s'initialise, et il peut falloir attendre quelques secondes avant que les interfaces Tock Studio soient accessibles. Connectez-vous avec les identifiants admin@app.com / password par d\u00e9faut Il est \u00e9videmment recommand\u00e9 de changer ces valeurs \u00e0 l'installation d'une plateforme destin\u00e9e \u00e0 une utilisation p\u00e9renne (production, plateforme partag\u00e9e entre \u00e9quipes, etc.).","title":"Acc\u00e9der \u00e0 Tock Studio"},{"location":"guide/plateforme/#creer-une-application-un-connecteur-et-une-intention","text":"Comme dans le guide premier bot utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Tock et un connecteur pour commencer \u00e0 utiliser la plateforme locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de commentaires. Au premier acc\u00e8s \u00e0 la plateforme locale : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Allez dans Settings > Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Create Notez l' API Key automatiquement g\u00e9n\u00e9r\u00e9e pour votre application. Elle vous servira si vous essayez le mode WebSocket dans la suite de ce guide (optionnel). Allez dans Stories & Answers > New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Allez dans Test > Test the Bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16","title":"Cr\u00e9er une application, un connecteur et une intention"},{"location":"guide/plateforme/#connecter-un-parcours-en-kotlin-optionnel","text":"Comme dans le guide programmer des parcours utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Kotlin se connectant en WebSocket \u00e0 la plateforme Tock locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de d\u00e9tails. Cr\u00e9ez un projet Kotlin par exemple avec Maven comme indiqu\u00e9 dans le guide programmer des parcours Le classpath doit inclure tock-bot-api-websocket pour utiliser le mode WebSocket . Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import ai.tock.bot.api.client.newBot import ai.tock.bot.api.client.newStory import ai.tock.bot.api.websocket.start fun main () { start ( // Do not use #startWithDemo when integrating with a local platform newBot ( \"PUT-YOUR-TOCK-APP-API-KEY-HERE\" , // Get your app API key from Bot Configurations in Tock Studio newStory ( \"qui-es-tu\" ) { // Answer for the 'qui-es-tu' story send ( \"Je suis un assistant conversationnel construit avec Tock\" ) end ( \"Comment puis-je aider ?\" ) } ), \"http://localhost:8080\" // Local platform URL (default host/port) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Settings > Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Retournez dans Tock dans Test > Test the Bot et dites \"qui es-tu ?\" : le bot ne r\u00e9pond pas encore. Allez dans Language Understanding > Inbox , pour la phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Terminez la qualification de la phrase avec Validate Retournez dans Test > Test the Bot . Dites \"qui es-tu ?\" : le bot r\u00e9pond !","title":"Connecter un parcours en Kotlin (optionnel)"},{"location":"guide/plateforme/#felicitations","text":"Vous venez de d\u00e9ployer votre propre plateforme conversationnelle Tock en local. Cela peut servir \u00e0 mieux appr\u00e9hender l'architecture et v\u00e9rifier la portabilit\u00e9 de la solution, mais aussi lors de d\u00e9veloppements, pour les contributeurs Tock ou encore si vous devez travailler sans acc\u00e8s \u00e0 Internet (en mobilit\u00e9, sur un r\u00e9seau restreint, etc.). Attention, l'impl\u00e9mentation Docker fournie ne suffit pas \u00e0 garantir r\u00e9silience et mont\u00e9e en charge de la plateforme quelles que soient les conditions en production. Pour cela, quelques recommandations sont propos\u00e9es dans la section haute disponibilit\u00e9 du manuel Tock.","title":"F\u00e9licitations!"},{"location":"guide/plateforme/#continuer","text":"Vous venez de terminer les guides de d\u00e9marrage rapide Tock. A partir de l\u00e0, vous pouvez vous lancer directement sur une plateforme Tock, ou parcourir le manuel utilisateur pour en savoir plus sur Tock Studio , Bot API et Bot Flow par exemple. D'autres pages pr\u00e9sentent aussi des \u00e9tudes de cas clients, des exemples de code, comment contacter la communaut\u00e9 Tock, etc.","title":"Continuer..."},{"location":"guide/slack/","text":"Configurer son bot pour Slack \u00b6 Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack mais celui-ci n'est pas encore configur\u00e9 pour que le bot parle r\u00e9ellement sur Slack . Avec un peu de configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock, un bot peut recevoir des messages et r\u00e9pondre sur ce canal. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et configurer un canal Messenger ou passer directement \u00e0 la suite . Ce que vous allez cr\u00e9er \u00b6 Une configuration (dans Slack et dans Tock) pour recevoir et envoyer des messages Slack Un bot qui parle sur une cha\u00eene Slack Pr\u00e9-requis \u00b6 Environ 15 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Slack et un espace de travail / une cha\u00eene o\u00f9 int\u00e9grer le bot Si vous n'avez jamais utilis\u00e9 Slack, rendez-vous sur sur https://slack.com/ Cr\u00e9er une application dans Slack \u00b6 Allez sur la page Create a Slack app Entrez un nom pour l' application S\u00e9lectionnez un espace de travail Terminez avec Create App Activer l'envoi de messages \u00e0 Slack \u00b6 Ouvrez Incoming Webhooks et cochez Activate Incoming Webhooks Cliquez sur Add New Webhook to Workspace S\u00e9lectionnez une cha\u00eene ou une personne pour la conversation avec le bot Terminez par Installer Copiez la Webhook URL qui vient d'\u00eatre cr\u00e9\u00e9e La Webhook URL ressemble dans son format \u00e0 quelque chose comme : https://hooks.slack.com/services/{workspaceToken}/{webhookToken}/{authToken} Dans Tock Studio allez dans Configuration > Bot Configurations Trouvez votre connecteur de type Slack (ou cr\u00e9ez-en un nouveau si besoin) et ouvrez la section Connector Custom Configuration Saisissez dans les trois champs tokens les jetons issus de l'adresse pr\u00e9c\u00e9demment copi\u00e9e : Token 1 : le premier token de la WebhookURL , ou workspaceToken Token 2 : le deuxi\u00e8me token de la WebhookURL , ou webhookToken Token 3 : le dernier token de la WebhookURL , ou authToken Terminez avec Update Attention : en cas de r\u00e9installation de l'application Slack dans le workspace , URL et jetons sont chang\u00e9s et doivent \u00eatre report\u00e9s dans la configuration c\u00f4t\u00e9 Tock. Activer la reception de messages depuis Slack \u00b6 Dans la page de votre application Slack, allez dans Event Subscriptions et activez Enable Events Entrez dans le champ Request URL l'adresse compl\u00e8te de votre connecteur Slack dans Tock. Sur la plateforme de d\u00e9monstration Tock, cette adresse sera du type https://demo.tock.ai/{chemin_relatif_du_connecteur_slack} Le chemin relatif du connecteur est indiqu\u00e9 dans la page Bot Configurations . Sur la ligne correspondant \u00e0 votre connecteur Slack, il s'agit du champ Relative REST path Ouvrez Add Workspace Event et s\u00e9lectionnez l'\u00e9venement message.channels pour utiliser le bot sur une cha\u00eene Slack. D'autres \u00e9v\u00e9nements \"message\" sont \u00e9galement disponibles : message.im pour les messages priv\u00e9s, message.groups , etc. Cf la documentation Slack . Validez avec Save Changes Allez dans Interactive Components et activez Interactivity Entrez la m\u00eame Request URL que pr\u00e9c\u00e9demment Validez avec Save Changes Cr\u00e9er un bot Slack (et lui parler) \u00b6 Dans la page de votre application Slack, allez dans Bot Users et faites Add a Bot User Choisissez un nom / identifiant pour le bot dans Slack Validez avec Add Bot User Allez dans Install App et Reinstall App S\u00e9lectionnez la cha\u00eene Slack puis Installer Dans Slack, allez sur la cha\u00eene et ajoutez le bot \u00e0 la cha\u00eene Parlez au bot (par exemple \"bonjour\"). Il vous r\u00e9pond maintenant dans Slack ! Regarder la conversation dans Tock Studio (optionnel) \u00b6 Quelque soient les canaux utilis\u00e9s pour converser avec le bot, vous pouvez suivre les conversations directement dans tous les \u00e9crans Tock Studio , par exemple : Language Understanding > Inbox et Logs , ou encore toutes vues du menu Analytics : Dans Tock, ouvrez Analytics > Users et cliquez sur l'ic\u00f4ne Display dialog pour voir toute la conversation provenant de Slack F\u00e9licitations! \u00b6 Vous venez de configurer votre bot pour qu'il parle \u00e9galement sur Slack. Comme vous le constatez, connecter un bot Tock \u00e0 un (ou plusieurs) canaux externes n'est qu'une affaire de configuration. Vous pouvez construire le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant ind\u00e9pendamment des canaux sur lesquels vous souhaitez lui parler, aujourd'hui ou \u00e0 l'avenir. Continuer... \u00b6 Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Configurer Slack"},{"location":"guide/slack/#configurer-son-bot-pour-slack","text":"Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack mais celui-ci n'est pas encore configur\u00e9 pour que le bot parle r\u00e9ellement sur Slack . Avec un peu de configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock, un bot peut recevoir des messages et r\u00e9pondre sur ce canal. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et configurer un canal Messenger ou passer directement \u00e0 la suite .","title":"Configurer son bot pour Slack"},{"location":"guide/slack/#ce-que-vous-allez-creer","text":"Une configuration (dans Slack et dans Tock) pour recevoir et envoyer des messages Slack Un bot qui parle sur une cha\u00eene Slack","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/slack/#pre-requis","text":"Environ 15 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Slack et un espace de travail / une cha\u00eene o\u00f9 int\u00e9grer le bot Si vous n'avez jamais utilis\u00e9 Slack, rendez-vous sur sur https://slack.com/","title":"Pr\u00e9-requis"},{"location":"guide/slack/#creer-une-application-dans-slack","text":"Allez sur la page Create a Slack app Entrez un nom pour l' application S\u00e9lectionnez un espace de travail Terminez avec Create App","title":"Cr\u00e9er une application dans Slack"},{"location":"guide/slack/#activer-lenvoi-de-messages-a-slack","text":"Ouvrez Incoming Webhooks et cochez Activate Incoming Webhooks Cliquez sur Add New Webhook to Workspace S\u00e9lectionnez une cha\u00eene ou une personne pour la conversation avec le bot Terminez par Installer Copiez la Webhook URL qui vient d'\u00eatre cr\u00e9\u00e9e La Webhook URL ressemble dans son format \u00e0 quelque chose comme : https://hooks.slack.com/services/{workspaceToken}/{webhookToken}/{authToken} Dans Tock Studio allez dans Configuration > Bot Configurations Trouvez votre connecteur de type Slack (ou cr\u00e9ez-en un nouveau si besoin) et ouvrez la section Connector Custom Configuration Saisissez dans les trois champs tokens les jetons issus de l'adresse pr\u00e9c\u00e9demment copi\u00e9e : Token 1 : le premier token de la WebhookURL , ou workspaceToken Token 2 : le deuxi\u00e8me token de la WebhookURL , ou webhookToken Token 3 : le dernier token de la WebhookURL , ou authToken Terminez avec Update Attention : en cas de r\u00e9installation de l'application Slack dans le workspace , URL et jetons sont chang\u00e9s et doivent \u00eatre report\u00e9s dans la configuration c\u00f4t\u00e9 Tock.","title":"Activer l'envoi de messages \u00e0 Slack"},{"location":"guide/slack/#activer-la-reception-de-messages-depuis-slack","text":"Dans la page de votre application Slack, allez dans Event Subscriptions et activez Enable Events Entrez dans le champ Request URL l'adresse compl\u00e8te de votre connecteur Slack dans Tock. Sur la plateforme de d\u00e9monstration Tock, cette adresse sera du type https://demo.tock.ai/{chemin_relatif_du_connecteur_slack} Le chemin relatif du connecteur est indiqu\u00e9 dans la page Bot Configurations . Sur la ligne correspondant \u00e0 votre connecteur Slack, il s'agit du champ Relative REST path Ouvrez Add Workspace Event et s\u00e9lectionnez l'\u00e9venement message.channels pour utiliser le bot sur une cha\u00eene Slack. D'autres \u00e9v\u00e9nements \"message\" sont \u00e9galement disponibles : message.im pour les messages priv\u00e9s, message.groups , etc. Cf la documentation Slack . Validez avec Save Changes Allez dans Interactive Components et activez Interactivity Entrez la m\u00eame Request URL que pr\u00e9c\u00e9demment Validez avec Save Changes","title":"Activer la reception de messages depuis Slack"},{"location":"guide/slack/#creer-un-bot-slack-et-lui-parler","text":"Dans la page de votre application Slack, allez dans Bot Users et faites Add a Bot User Choisissez un nom / identifiant pour le bot dans Slack Validez avec Add Bot User Allez dans Install App et Reinstall App S\u00e9lectionnez la cha\u00eene Slack puis Installer Dans Slack, allez sur la cha\u00eene et ajoutez le bot \u00e0 la cha\u00eene Parlez au bot (par exemple \"bonjour\"). Il vous r\u00e9pond maintenant dans Slack !","title":"Cr\u00e9er un bot Slack (et lui parler)"},{"location":"guide/slack/#regarder-la-conversation-dans-tock-studio-optionnel","text":"Quelque soient les canaux utilis\u00e9s pour converser avec le bot, vous pouvez suivre les conversations directement dans tous les \u00e9crans Tock Studio , par exemple : Language Understanding > Inbox et Logs , ou encore toutes vues du menu Analytics : Dans Tock, ouvrez Analytics > Users et cliquez sur l'ic\u00f4ne Display dialog pour voir toute la conversation provenant de Slack","title":"Regarder la conversation dans Tock Studio (optionnel)"},{"location":"guide/slack/#felicitations","text":"Vous venez de configurer votre bot pour qu'il parle \u00e9galement sur Slack. Comme vous le constatez, connecter un bot Tock \u00e0 un (ou plusieurs) canaux externes n'est qu'une affaire de configuration. Vous pouvez construire le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant ind\u00e9pendamment des canaux sur lesquels vous souhaitez lui parler, aujourd'hui ou \u00e0 l'avenir.","title":"F\u00e9licitations!"},{"location":"guide/slack/#continuer","text":"Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Continuer..."},{"location":"guide/studio/","text":"Cr\u00e9er son premier bot avec Tock Studio \u00b6 Un bon moyen de tester Tock est certainement de cr\u00e9er son premier bot conversationnel dans Tock Studio (l'interface graphiques fournie avec la plateforme). En se connectant \u00e0 la plateforme de d\u00e9monstration Tock, il est possible de cr\u00e9er et tester un assistant en quelques minutes sans \u00e9crire de code. Ce que vous allez cr\u00e9er \u00b6 Une application et un connecteur sur la plateforme de d\u00e9monstration Tock Une story : phrase utilisateur / r\u00e9ponse du bot, testable dans l'interface Tock Studio Un assistant qui r\u00e9pond quand vous lui dites \"bonjour\" ! \ud83d\ude42 Pr\u00e9-requis \u00b6 Entre 5 et 15 minutes environ (en lisant les commentaires) Un compte GitHub pour se connecter \u00e0 la plateforme de d\u00e9monstration Connexion \u00e0 la plateforme d\u00e9mo \u00b6 Rendez-vous sur https://demo.tock.ai/ pour acc\u00e9der \u00e0 la plateforme de d\u00e9monstration Tock. Remarque importante : Cette plateforme n'a pas vocation \u00e0 accueillir de v\u00e9ritables bots en production. C'est un moyen de tester et prendre en main la solution Tock sans avoir \u00e0 l'installer. Une invite appara\u00eet pour vous identifier avec votre compte GitHub. Apr\u00e8s cela, vous devez accepter que Tock acc\u00e8de \u00e0 votre compte - seul l'identifiant de votre compte GitHub sera lu. Cr\u00e9er une application Tock \u00b6 Au premier acc\u00e8s \u00e0 la plateforme de d\u00e9monstration, un assistant invite \u00e0 cr\u00e9er une application : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Vous pouvez retrouver l'application cr\u00e9\u00e9e dans le menu : Settings > Applications . Si vous aviez d\u00e9j\u00e0 cr\u00e9\u00e9 une ou plusieurs applications, vous pouvez en cr\u00e9er de nouvelles en revenant \u00e0 cet \u00e9cran puis Create New Application . Ajouter un connecteur \u00b6 Pour int\u00e9ragir avec le bot, il faut utiliser un connecteur afin de l'exposer \u00e0 un canal de communication. De nombreux connecteurs existent pour Tock : Messenger , WhatsApp , Google Assistant et Google Home , Twitter , Alexa , Business Chat , Teams , Slack , Rocket.Chat ... Il est m\u00eame possible de d\u00e9velopper ses propres connecteurs pour ouvrir le bot \u00e0 de nouveaux canaux. Pour ce tutoriel, vous allez configurer un connecteur pour Slack . Dans un premier temps, vous testerez le bot en restant dans l'interface Tock Studio , et n'aurez pas besoin d'utiliser Slack. Dans la section suivante Configurer Slack , vous pourrez compl\u00e9ter la configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock afin que le bot soit fonctionnel sur cette plateforme collaborative. De m\u00eame, la section Configurer Messenger vous montrera comment activer le m\u00eame bot sur la messagerie du r\u00e9seau social Facebook. Cr\u00e9ez un premier connecteur pour votre application : Allez dans Settings > Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Entrez token dans les champs Token (pour le moment) Create Notez qu'une API Key a \u00e9t\u00e9 automatiquement g\u00e9n\u00e9r\u00e9e pour votre application \u00e0 la cr\u00e9ation du premier connecteur. Celle-ci vous servira \u00e0 vous connecter \u00e0 l'API du bot si vous essayez le mode WebHook ou WebSocket dans le guide Programmer des parcours . Si vous cliquez sur Display test configurations , vous pouvez voir qu'une seconde configuration est cr\u00e9\u00e9e. Ce connecteur sp\u00e9cial sera utilis\u00e9 pour tester le bot directement depuis l'interface Tock Studio . Gr\u00e2ce \u00e0 lui, vous pourrez parler au bot sans passer par Slack. Cr\u00e9er un parcours \u00b6 Un bot conversationnel analyse les phrases des utilisateurs en langage naturel, pour en d\u00e9terminer l' intention et \u00e9ventuellement des entit\u00e9s . Exemple : dans la phrase \"Quel temps fera-t-il demain ?\", le moteur NLU (Natural Language Understanding) de Tock va reconna\u00eetre une intention \"m\u00e9t\u00e9o\" et une entit\u00e9 \"demain\" venant pr\u00e9ciser/param\u00e9trer cette intention. Encore faut-il avoir d\u00e9clar\u00e9 les intentions et entit\u00e9s possibles, puis qualifi\u00e9 des phrases pour apprendre au bot \u00e0 les d\u00e9tecter. Le menu Language Understanding de Tock permet de g\u00e9rer intentions et entit\u00e9s, qualifier les phrases et ainsi superviser l'apprentissage du bot : plus on qualifie de phrases, plus le bot devient pertinent dans sa compr\u00e9hension du langage. Mais laissons intentions et entit\u00e9s de c\u00f4t\u00e9 pour le moment... Le mode Stories de Tock permet en quelques clics de cr\u00e9er automatiquement des intentions ainsi que les r\u00e9ponses \u00e0 fournir. Ainsi, sans quitter l'interface Tock Studio , vous allez cr\u00e9er un premier parcours de question(s)-r\u00e9ponse(s). Allez dans Stories & Answers > New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Un formulaire s'ouvre vous permettant de configurer la cr\u00e9ation de la story , l'intention qui sera \u00e9galement cr\u00e9\u00e9e, le type de r\u00e9ponse, etc. Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Il est possible de r\u00e9pondre par plusieurs messages, ou des messages plus \u00e9volu\u00e9s comme des images, des liens, des boutons d' Action de mani\u00e8re \u00e0 continuer le dialogue, etc. La section Tock Studio du manuel utilisateur Tock vous en apprendra plus. Tester le bot \u00b6 Il est maintenant temps de tester le bot et votre premier parcours! Allez dans Test > Test the Bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16 Si le bot r\u00e9pond qu'il n'a pas compris, c'est certainement un probl\u00e8me de qualification. Vous pouvez v\u00e9rifier que la story et/ou l' intention ont bien \u00e9t\u00e9 cr\u00e9\u00e9s en allant dans Build > Search Stories . V\u00e9rifiez aussi que vous \u00eates sur la bonne application et la bonne langue (au cas o\u00f9 vous en auriez cr\u00e9\u00e9 plusieurs) pour faire le test : ils sont visibles en haut \u00e0 droite de l'interface. Si malgr\u00e9 tout le bot r\u00e9pond qu'il ne comprend pas, peut-\u00eatre n'avez-vous pas saisi exactement la phrase utilis\u00e9e \u00e0 la cr\u00e9ation de la story , et le bot ne fait pas encore le lien avec cette seconde phrase. Dans le paragraphe suivant, vous verrez comment am\u00e9liorer la compr\u00e9hension du bot en qualifiant plus de phrases utilisateur. Si vous obtenez un message d'erreur technique, il s'agit probablement d'une erreur de configuration du connecteur. Am\u00e9liorer la compr\u00e9hension \u00b6 En saisissant des phrases un peu diff\u00e9rentes dans l'\u00e9cran Test the Bot , vous pouvez constater qu'il ne comprend pas encore tr\u00e8s bien votre langage - m\u00eame lorsque les phrases sont proches de celle saisie \u00e0 la cr\u00e9ation de la story . C'est normal. Le mod\u00e8le conversationnel et la partie Language Understanding de Tock s'enrichissent progressivement de phrases qualifi\u00e9es pour alimenter les algorithmes et donner des r\u00e9sultats de plus en plus pertinents. Les premiers essais peuvent \u00eatre d\u00e9cevants, mais souvent apr\u00e8s quelques qualifications, voire une ou deux dizaines de phrases qualifi\u00e9es si besoin, votre bot vous comprend d\u00e9j\u00e0 bien mieux. Allez dans Language Understanding > Inbox Vous voyez les phrases que vous avez saisies, et comment le bot les a interpr\u00eat\u00e9es. Pour chacune s'affichent l'intention reconnue, la langue ainsi que le score (que se donnent les algorithmes selon leur niveau de confiance sur cette phrase). Choisissez quelques phrases, pour chacune s\u00e9lectionnez la bonne intention puis Validate Retournez dans Test > Test the Bot V\u00e9rifiez que le bot comprend mieux ces phrases, et m\u00eames d'autres un peu diff\u00e9rentes alors que vous ne les avez pas qualifi\u00e9es explicitement! Cr\u00e9er d'autres parcours (optionnel) \u00b6 Pour aller un peu plus loin avec les stories Tock, vous pouvez cr\u00e9er d'autres parcours et les tester directement dans Tock Studio . Le bot vous r\u00e9pond alors selon l'intention d\u00e9clench\u00e9e, sans autre forme de navigation que le fil que vous donnez \u00e0 la conversation. C'est la magie du conversationnel : le langage naturel est la seule navigation, et l'utilisateur est soustrait aux liens et menus traditionnellement impos\u00e9s par les interfaces Web ou mobiles. Remarque : si vous preniez le temps de cr\u00e9er de tr\u00e8s nombreuses stories , vous contasteriez peut-\u00eatre quelques effets ind\u00e9sirables propres au mode de fonctionnement des mod\u00e8les et algorithmes NLU . Par exemple, un tr\u00e8s grand nombre d'intentions et d'entit\u00e9s peut rendre plus difficile leur d\u00e9tection. On recommande souvent de commencer par cr\u00e9er des bots d\u00e9di\u00e9s \u00e0 un domaine fonctionnel limit\u00e9, facilitant son apprentissage en focalisant le mod\u00e8le sur ce domaine. Qualifier beaucoup de phrases permet en g\u00e9n\u00e9ral d'am\u00e9liorer la compr\u00e9hension, mais \u00e0 l'inverse qualifier trop de phrases (ou trop proches) peut sur-entra\u00eener le mod\u00e8le pour une intention, avec pour effet de r\u00e9duire la reconnaissance des phrases un peu diff\u00e9rentes. Retenez que la conception et la maintenance des mod\u00e8les conversationnels est un sujet complexe qui n\u00e9cessite de l'apprentissage (du bot mais aussi de ceux qui le construisent), de r\u00e9-\u00e9valuer et r\u00e9-adapter r\u00e9guli\u00e8rement ces mod\u00e8les aux besoins et aux nouvelles demandes des utilisateurs. F\u00e9licitations! \u00b6 Vous venez de cr\u00e9er votre premier bot conversationnel avec Tock. Comme vous avez pu vous en apercevoir, quelques minutes suffisent, sans connaissances techniques approfondies, pour cr\u00e9er des parcours conversationnels simples sans \u00e9crire ni d\u00e9ployer de code. Continuer... \u00b6 Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Slack (requiert un compte Slack) Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Cr\u00e9er son premier bot"},{"location":"guide/studio/#creer-son-premier-bot-avec-tock-studio","text":"Un bon moyen de tester Tock est certainement de cr\u00e9er son premier bot conversationnel dans Tock Studio (l'interface graphiques fournie avec la plateforme). En se connectant \u00e0 la plateforme de d\u00e9monstration Tock, il est possible de cr\u00e9er et tester un assistant en quelques minutes sans \u00e9crire de code.","title":"Cr\u00e9er son premier bot avec Tock Studio"},{"location":"guide/studio/#ce-que-vous-allez-creer","text":"Une application et un connecteur sur la plateforme de d\u00e9monstration Tock Une story : phrase utilisateur / r\u00e9ponse du bot, testable dans l'interface Tock Studio Un assistant qui r\u00e9pond quand vous lui dites \"bonjour\" ! \ud83d\ude42","title":"Ce que vous allez cr\u00e9er"},{"location":"guide/studio/#pre-requis","text":"Entre 5 et 15 minutes environ (en lisant les commentaires) Un compte GitHub pour se connecter \u00e0 la plateforme de d\u00e9monstration","title":"Pr\u00e9-requis"},{"location":"guide/studio/#connexion-a-la-plateforme-demo","text":"Rendez-vous sur https://demo.tock.ai/ pour acc\u00e9der \u00e0 la plateforme de d\u00e9monstration Tock. Remarque importante : Cette plateforme n'a pas vocation \u00e0 accueillir de v\u00e9ritables bots en production. C'est un moyen de tester et prendre en main la solution Tock sans avoir \u00e0 l'installer. Une invite appara\u00eet pour vous identifier avec votre compte GitHub. Apr\u00e8s cela, vous devez accepter que Tock acc\u00e8de \u00e0 votre compte - seul l'identifiant de votre compte GitHub sera lu.","title":"Connexion \u00e0 la plateforme d\u00e9mo"},{"location":"guide/studio/#creer-une-application-tock","text":"Au premier acc\u00e8s \u00e0 la plateforme de d\u00e9monstration, un assistant invite \u00e0 cr\u00e9er une application : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Vous pouvez retrouver l'application cr\u00e9\u00e9e dans le menu : Settings > Applications . Si vous aviez d\u00e9j\u00e0 cr\u00e9\u00e9 une ou plusieurs applications, vous pouvez en cr\u00e9er de nouvelles en revenant \u00e0 cet \u00e9cran puis Create New Application .","title":"Cr\u00e9er une application Tock"},{"location":"guide/studio/#ajouter-un-connecteur","text":"Pour int\u00e9ragir avec le bot, il faut utiliser un connecteur afin de l'exposer \u00e0 un canal de communication. De nombreux connecteurs existent pour Tock : Messenger , WhatsApp , Google Assistant et Google Home , Twitter , Alexa , Business Chat , Teams , Slack , Rocket.Chat ... Il est m\u00eame possible de d\u00e9velopper ses propres connecteurs pour ouvrir le bot \u00e0 de nouveaux canaux. Pour ce tutoriel, vous allez configurer un connecteur pour Slack . Dans un premier temps, vous testerez le bot en restant dans l'interface Tock Studio , et n'aurez pas besoin d'utiliser Slack. Dans la section suivante Configurer Slack , vous pourrez compl\u00e9ter la configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock afin que le bot soit fonctionnel sur cette plateforme collaborative. De m\u00eame, la section Configurer Messenger vous montrera comment activer le m\u00eame bot sur la messagerie du r\u00e9seau social Facebook. Cr\u00e9ez un premier connecteur pour votre application : Allez dans Settings > Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Entrez token dans les champs Token (pour le moment) Create Notez qu'une API Key a \u00e9t\u00e9 automatiquement g\u00e9n\u00e9r\u00e9e pour votre application \u00e0 la cr\u00e9ation du premier connecteur. Celle-ci vous servira \u00e0 vous connecter \u00e0 l'API du bot si vous essayez le mode WebHook ou WebSocket dans le guide Programmer des parcours . Si vous cliquez sur Display test configurations , vous pouvez voir qu'une seconde configuration est cr\u00e9\u00e9e. Ce connecteur sp\u00e9cial sera utilis\u00e9 pour tester le bot directement depuis l'interface Tock Studio . Gr\u00e2ce \u00e0 lui, vous pourrez parler au bot sans passer par Slack.","title":"Ajouter un connecteur"},{"location":"guide/studio/#creer-un-parcours","text":"Un bot conversationnel analyse les phrases des utilisateurs en langage naturel, pour en d\u00e9terminer l' intention et \u00e9ventuellement des entit\u00e9s . Exemple : dans la phrase \"Quel temps fera-t-il demain ?\", le moteur NLU (Natural Language Understanding) de Tock va reconna\u00eetre une intention \"m\u00e9t\u00e9o\" et une entit\u00e9 \"demain\" venant pr\u00e9ciser/param\u00e9trer cette intention. Encore faut-il avoir d\u00e9clar\u00e9 les intentions et entit\u00e9s possibles, puis qualifi\u00e9 des phrases pour apprendre au bot \u00e0 les d\u00e9tecter. Le menu Language Understanding de Tock permet de g\u00e9rer intentions et entit\u00e9s, qualifier les phrases et ainsi superviser l'apprentissage du bot : plus on qualifie de phrases, plus le bot devient pertinent dans sa compr\u00e9hension du langage. Mais laissons intentions et entit\u00e9s de c\u00f4t\u00e9 pour le moment... Le mode Stories de Tock permet en quelques clics de cr\u00e9er automatiquement des intentions ainsi que les r\u00e9ponses \u00e0 fournir. Ainsi, sans quitter l'interface Tock Studio , vous allez cr\u00e9er un premier parcours de question(s)-r\u00e9ponse(s). Allez dans Stories & Answers > New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Un formulaire s'ouvre vous permettant de configurer la cr\u00e9ation de la story , l'intention qui sera \u00e9galement cr\u00e9\u00e9e, le type de r\u00e9ponse, etc. Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Il est possible de r\u00e9pondre par plusieurs messages, ou des messages plus \u00e9volu\u00e9s comme des images, des liens, des boutons d' Action de mani\u00e8re \u00e0 continuer le dialogue, etc. La section Tock Studio du manuel utilisateur Tock vous en apprendra plus.","title":"Cr\u00e9er un parcours"},{"location":"guide/studio/#tester-le-bot","text":"Il est maintenant temps de tester le bot et votre premier parcours! Allez dans Test > Test the Bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16 Si le bot r\u00e9pond qu'il n'a pas compris, c'est certainement un probl\u00e8me de qualification. Vous pouvez v\u00e9rifier que la story et/ou l' intention ont bien \u00e9t\u00e9 cr\u00e9\u00e9s en allant dans Build > Search Stories . V\u00e9rifiez aussi que vous \u00eates sur la bonne application et la bonne langue (au cas o\u00f9 vous en auriez cr\u00e9\u00e9 plusieurs) pour faire le test : ils sont visibles en haut \u00e0 droite de l'interface. Si malgr\u00e9 tout le bot r\u00e9pond qu'il ne comprend pas, peut-\u00eatre n'avez-vous pas saisi exactement la phrase utilis\u00e9e \u00e0 la cr\u00e9ation de la story , et le bot ne fait pas encore le lien avec cette seconde phrase. Dans le paragraphe suivant, vous verrez comment am\u00e9liorer la compr\u00e9hension du bot en qualifiant plus de phrases utilisateur. Si vous obtenez un message d'erreur technique, il s'agit probablement d'une erreur de configuration du connecteur.","title":"Tester le bot"},{"location":"guide/studio/#ameliorer-la-comprehension","text":"En saisissant des phrases un peu diff\u00e9rentes dans l'\u00e9cran Test the Bot , vous pouvez constater qu'il ne comprend pas encore tr\u00e8s bien votre langage - m\u00eame lorsque les phrases sont proches de celle saisie \u00e0 la cr\u00e9ation de la story . C'est normal. Le mod\u00e8le conversationnel et la partie Language Understanding de Tock s'enrichissent progressivement de phrases qualifi\u00e9es pour alimenter les algorithmes et donner des r\u00e9sultats de plus en plus pertinents. Les premiers essais peuvent \u00eatre d\u00e9cevants, mais souvent apr\u00e8s quelques qualifications, voire une ou deux dizaines de phrases qualifi\u00e9es si besoin, votre bot vous comprend d\u00e9j\u00e0 bien mieux. Allez dans Language Understanding > Inbox Vous voyez les phrases que vous avez saisies, et comment le bot les a interpr\u00eat\u00e9es. Pour chacune s'affichent l'intention reconnue, la langue ainsi que le score (que se donnent les algorithmes selon leur niveau de confiance sur cette phrase). Choisissez quelques phrases, pour chacune s\u00e9lectionnez la bonne intention puis Validate Retournez dans Test > Test the Bot V\u00e9rifiez que le bot comprend mieux ces phrases, et m\u00eames d'autres un peu diff\u00e9rentes alors que vous ne les avez pas qualifi\u00e9es explicitement!","title":"Am\u00e9liorer la compr\u00e9hension"},{"location":"guide/studio/#creer-dautres-parcours-optionnel","text":"Pour aller un peu plus loin avec les stories Tock, vous pouvez cr\u00e9er d'autres parcours et les tester directement dans Tock Studio . Le bot vous r\u00e9pond alors selon l'intention d\u00e9clench\u00e9e, sans autre forme de navigation que le fil que vous donnez \u00e0 la conversation. C'est la magie du conversationnel : le langage naturel est la seule navigation, et l'utilisateur est soustrait aux liens et menus traditionnellement impos\u00e9s par les interfaces Web ou mobiles. Remarque : si vous preniez le temps de cr\u00e9er de tr\u00e8s nombreuses stories , vous contasteriez peut-\u00eatre quelques effets ind\u00e9sirables propres au mode de fonctionnement des mod\u00e8les et algorithmes NLU . Par exemple, un tr\u00e8s grand nombre d'intentions et d'entit\u00e9s peut rendre plus difficile leur d\u00e9tection. On recommande souvent de commencer par cr\u00e9er des bots d\u00e9di\u00e9s \u00e0 un domaine fonctionnel limit\u00e9, facilitant son apprentissage en focalisant le mod\u00e8le sur ce domaine. Qualifier beaucoup de phrases permet en g\u00e9n\u00e9ral d'am\u00e9liorer la compr\u00e9hension, mais \u00e0 l'inverse qualifier trop de phrases (ou trop proches) peut sur-entra\u00eener le mod\u00e8le pour une intention, avec pour effet de r\u00e9duire la reconnaissance des phrases un peu diff\u00e9rentes. Retenez que la conception et la maintenance des mod\u00e8les conversationnels est un sujet complexe qui n\u00e9cessite de l'apprentissage (du bot mais aussi de ceux qui le construisent), de r\u00e9-\u00e9valuer et r\u00e9-adapter r\u00e9guli\u00e8rement ces mod\u00e8les aux besoins et aux nouvelles demandes des utilisateurs.","title":"Cr\u00e9er d'autres parcours (optionnel)"},{"location":"guide/studio/#felicitations","text":"Vous venez de cr\u00e9er votre premier bot conversationnel avec Tock. Comme vous avez pu vous en apercevoir, quelques minutes suffisent, sans connaissances techniques approfondies, pour cr\u00e9er des parcours conversationnels simples sans \u00e9crire ni d\u00e9ployer de code.","title":"F\u00e9licitations!"},{"location":"guide/studio/#continuer","text":"Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Slack (requiert un compte Slack) Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Continuer..."},{"location":"user/concepts/","text":"Concepts conversationnels pour Tock \u00b6 Cette page pr\u00e9sente et vulgarise les principaux concepts et la terminologie conversationnelle utilis\u00e9e dans Tock et sa documentation. Un tableau propose \u00e9galement des \u00e9quivalences et termes similaires dans d'autres solutions conversationnelles. Notions de base \u00b6 Application \u00b6 Une application correspond \u00e0 un corpus de phrases dont Tock va tirer un ensemble de mod\u00e8les statistiques lui permettant d'analyser les phrases utilisateurs. Dans son mode conversationnel, elle correspond aussi \u00e0 diff\u00e9rent param\u00e8tres qui permettent de d\u00e9finir les r\u00e9ponses et le comportement du ou des bots de cette application. Connecteur \u00b6 Un connecteur permet \u00e0 Tock de connecter un bot \u00e0 un canal comme Messenger, Slack, etc. Il se configure dans l'onglet Bot Configurations . Tock permet de mutualiser tr\u00e8s facilement le code d'un bot pour qu'il puisse r\u00e9pondre \u00e0 plusieurs connecteurs. Namespace \u00b6 Le namespace permet d'identifier le groupe organisationnel d'un objet. Il appara\u00eet en g\u00e9n\u00e9ral comme un pr\u00e9fixe suivit de \":\" dans une cha\u00eene de caract\u00e8res. Par exemple l'entit\u00e9 de type \"duckling:datetime\" est l'entit\u00e9 de type \"datetime\" qui vient du module \"duckling\" : ici \"duckling\" est le namespace. Si vous utilisez la plateforme de d\u00e9monstration, votre namespace est votre login Github. Intentions \u00b6 Pour pouvoir d\u00e9finir des actions suite \u00e0 une demande utilisateur, il est n\u00e9cessaire au pr\u00e9alable de classifier ou cat\u00e9goriser cette demande. Ce qu'on appelle une intention est justement cette classification. Par exemple, les phrases \"Quel temps fait-il?\", \"Il fait beau demain ?\", \"J'esp\u00e8re qu'il ne va pas pleuvoir \u00e0 Paris ?\" peuvent toutes \u00eatre cat\u00e9goris\u00e9es avec l'intention \"m\u00e9t\u00e9o\". A partir des phrases classifi\u00e9es manuellement par un utilisateur, Tock va automatiquement construire un mod\u00e8le statistique qui va lui permettre, pour une nouvelle phrase, de d\u00e9terminer quelle est l'intention la plus probable. Pour reprendre l'exemple ci-dessus, avec un mod\u00e8le constitu\u00e9 des trois phrases d'exemple, il est probable qu'une nouvelle phrase du type \"Quel temps fera t'il demain ?\" sera reconnue automatiquement par Tock comme correspondant \u00e0 l'intention \"m\u00e9t\u00e9o\". Entit\u00e9s \u00b6 Une fois l'intention d\u00e9termin\u00e9e, il est souvent utile d'identifier le sens de certains mots de la phrase. Dans la phrase \"Il fait beau demain ?\", le mot \"demain\" a une signification qu'il faudra utiliser pour r\u00e9pondre de mani\u00e8re pertinente \u00e0 la question. On appelle entit\u00e9s ces mots significatifs de la phrase. Une entit\u00e9 \u00e0 un type et un role. Par exemple, dans la phrase \"Je pars \u00e0 11h et j'arrive \u00e0 18h\", les mots \"\u00e0 11h\" et \"\u00e0 18h\" sont tous les deux des entit\u00e9s de type 'datetime' mais \"11h\" aura un r\u00f4le depart l\u00e0 ou \"18h\" aura un r\u00f4le arriv\u00e9e . Dans les cas o\u00f9 le r\u00f4le n'apporte pas d'information suppl\u00e9mentaire, il est souvent \u00e9gal au type. On distingue deux \u00e9tapes dans la prise en compte d'une entit\u00e9 : L' identification : quels sont les mots de la phrase qui constituent l'entit\u00e9 La valorisation : quelle est la valeur de cette entit\u00e9. Par exemple comment traduire \"\u00e0 11h\" en date syst\u00e8me. Tock par d\u00e9faut identifie l'entit\u00e9, mais ne la valorise pas, sauf pour certains types. Par d\u00e9faut, les entit\u00e9s de namespace \"duckling\" seront automatiquement valoris\u00e9es. Sc\u00e9nario (ou Story ) \u00b6 Un sc\u00e9nario ou story est un regroupement fonctionnel qui permet de r\u00e9pondre aux questions sur un sujet bien d\u00e9limit\u00e9. Il est en g\u00e9n\u00e9ral initi\u00e9 par une intention principale et peut aussi utiliser, de mani\u00e8re optionelle, une arborescence d'intentions dites \"secondaires\". Pour reprendre l'exemple de la m\u00e9t\u00e9o, \u00e0 quelqu'un demandant \"Quel temps fait-il ?\", il peut \u00eatre utile de poser la question de l'endroit o\u00f9 il se trouve. Cette question sera prise en compte dans la story \"m\u00e9t\u00e9o\" puisqu'elle n'est qu'une extension de la question initiale. La Story est l'unit\u00e9 principale du framework conversationnel de Tock. Termes & correspondances \u00b6 Le tableau ci-dessous propose des correspondances entre les termes utilis\u00e9s dans Tock et ceux d'autres solutions conversationnelles : Tock DialogFlow Alexa Intent Intent Intent Entity Entity Sentence Query Utterance / Slot Story Connector Integration Application Project / Agent Skill La documentation des connecteurs Tock donne \u00e9galement la correspondance avec d'autres termes propres \u00e0 tel ou tel canal. Continuer... \u00b6 Vous pouvez maintenant entamer le chapitre suivant : Interfaces Tock Studio .","title":"Concepts"},{"location":"user/concepts/#concepts-conversationnels-pour-tock","text":"Cette page pr\u00e9sente et vulgarise les principaux concepts et la terminologie conversationnelle utilis\u00e9e dans Tock et sa documentation. Un tableau propose \u00e9galement des \u00e9quivalences et termes similaires dans d'autres solutions conversationnelles.","title":"Concepts conversationnels pour Tock"},{"location":"user/concepts/#notions-de-base","text":"","title":"Notions de base"},{"location":"user/concepts/#application","text":"Une application correspond \u00e0 un corpus de phrases dont Tock va tirer un ensemble de mod\u00e8les statistiques lui permettant d'analyser les phrases utilisateurs. Dans son mode conversationnel, elle correspond aussi \u00e0 diff\u00e9rent param\u00e8tres qui permettent de d\u00e9finir les r\u00e9ponses et le comportement du ou des bots de cette application.","title":"Application"},{"location":"user/concepts/#connecteur","text":"Un connecteur permet \u00e0 Tock de connecter un bot \u00e0 un canal comme Messenger, Slack, etc. Il se configure dans l'onglet Bot Configurations . Tock permet de mutualiser tr\u00e8s facilement le code d'un bot pour qu'il puisse r\u00e9pondre \u00e0 plusieurs connecteurs.","title":"Connecteur"},{"location":"user/concepts/#namespace","text":"Le namespace permet d'identifier le groupe organisationnel d'un objet. Il appara\u00eet en g\u00e9n\u00e9ral comme un pr\u00e9fixe suivit de \":\" dans une cha\u00eene de caract\u00e8res. Par exemple l'entit\u00e9 de type \"duckling:datetime\" est l'entit\u00e9 de type \"datetime\" qui vient du module \"duckling\" : ici \"duckling\" est le namespace. Si vous utilisez la plateforme de d\u00e9monstration, votre namespace est votre login Github.","title":"Namespace"},{"location":"user/concepts/#intentions","text":"Pour pouvoir d\u00e9finir des actions suite \u00e0 une demande utilisateur, il est n\u00e9cessaire au pr\u00e9alable de classifier ou cat\u00e9goriser cette demande. Ce qu'on appelle une intention est justement cette classification. Par exemple, les phrases \"Quel temps fait-il?\", \"Il fait beau demain ?\", \"J'esp\u00e8re qu'il ne va pas pleuvoir \u00e0 Paris ?\" peuvent toutes \u00eatre cat\u00e9goris\u00e9es avec l'intention \"m\u00e9t\u00e9o\". A partir des phrases classifi\u00e9es manuellement par un utilisateur, Tock va automatiquement construire un mod\u00e8le statistique qui va lui permettre, pour une nouvelle phrase, de d\u00e9terminer quelle est l'intention la plus probable. Pour reprendre l'exemple ci-dessus, avec un mod\u00e8le constitu\u00e9 des trois phrases d'exemple, il est probable qu'une nouvelle phrase du type \"Quel temps fera t'il demain ?\" sera reconnue automatiquement par Tock comme correspondant \u00e0 l'intention \"m\u00e9t\u00e9o\".","title":"Intentions"},{"location":"user/concepts/#entites","text":"Une fois l'intention d\u00e9termin\u00e9e, il est souvent utile d'identifier le sens de certains mots de la phrase. Dans la phrase \"Il fait beau demain ?\", le mot \"demain\" a une signification qu'il faudra utiliser pour r\u00e9pondre de mani\u00e8re pertinente \u00e0 la question. On appelle entit\u00e9s ces mots significatifs de la phrase. Une entit\u00e9 \u00e0 un type et un role. Par exemple, dans la phrase \"Je pars \u00e0 11h et j'arrive \u00e0 18h\", les mots \"\u00e0 11h\" et \"\u00e0 18h\" sont tous les deux des entit\u00e9s de type 'datetime' mais \"11h\" aura un r\u00f4le depart l\u00e0 ou \"18h\" aura un r\u00f4le arriv\u00e9e . Dans les cas o\u00f9 le r\u00f4le n'apporte pas d'information suppl\u00e9mentaire, il est souvent \u00e9gal au type. On distingue deux \u00e9tapes dans la prise en compte d'une entit\u00e9 : L' identification : quels sont les mots de la phrase qui constituent l'entit\u00e9 La valorisation : quelle est la valeur de cette entit\u00e9. Par exemple comment traduire \"\u00e0 11h\" en date syst\u00e8me. Tock par d\u00e9faut identifie l'entit\u00e9, mais ne la valorise pas, sauf pour certains types. Par d\u00e9faut, les entit\u00e9s de namespace \"duckling\" seront automatiquement valoris\u00e9es.","title":"Entit\u00e9s"},{"location":"user/concepts/#scenario-ou-story","text":"Un sc\u00e9nario ou story est un regroupement fonctionnel qui permet de r\u00e9pondre aux questions sur un sujet bien d\u00e9limit\u00e9. Il est en g\u00e9n\u00e9ral initi\u00e9 par une intention principale et peut aussi utiliser, de mani\u00e8re optionelle, une arborescence d'intentions dites \"secondaires\". Pour reprendre l'exemple de la m\u00e9t\u00e9o, \u00e0 quelqu'un demandant \"Quel temps fait-il ?\", il peut \u00eatre utile de poser la question de l'endroit o\u00f9 il se trouve. Cette question sera prise en compte dans la story \"m\u00e9t\u00e9o\" puisqu'elle n'est qu'une extension de la question initiale. La Story est l'unit\u00e9 principale du framework conversationnel de Tock.","title":"Sc\u00e9nario (ou Story)"},{"location":"user/concepts/#termes-correspondances","text":"Le tableau ci-dessous propose des correspondances entre les termes utilis\u00e9s dans Tock et ceux d'autres solutions conversationnelles : Tock DialogFlow Alexa Intent Intent Intent Entity Entity Sentence Query Utterance / Slot Story Connector Integration Application Project / Agent Skill La documentation des connecteurs Tock donne \u00e9galement la correspondance avec d'autres termes propres \u00e0 tel ou tel canal.","title":"Termes &amp; correspondances"},{"location":"user/concepts/#continuer","text":"Vous pouvez maintenant entamer le chapitre suivant : Interfaces Tock Studio .","title":"Continuer..."},{"location":"user/guides/","text":"Guides utilisateur \u00b6 Pour apprendre plus sur les fonctionnalit\u00e9s Tock Studio voici les tutoriels pas \u00e0 pas pour : Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation)","title":"Guides utilisateur"},{"location":"user/guides/#guides-utilisateur","text":"Pour apprendre plus sur les fonctionnalit\u00e9s Tock Studio voici les tutoriels pas \u00e0 pas pour : Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation)","title":"Guides utilisateur"},{"location":"user/studio/","text":"Les interfaces Tock Studio \u00b6 Tock Studio regroupe l'ensemble des interfaces utilisateur, techniques et m\u00e9tier, permettant de concevoir les mod\u00e8les conversationnels, cr\u00e9er des parcours et des r\u00e9ponses, suivre les conversations, analyser les tendances, etc. Dans cette section, vous trouverez la description de chaque vue et interface. Pour des th\u00e8mes ou fonctionnalit\u00e9s particuli\u00e8res, voir aussi les guides utilisateur. Interfaces de Tock Studio : Interface g\u00e9n\u00e9rale Le menu Language Understanding Le menu Stories & Answers Le menu Test Le menu Analytics Le menu Model Quality Le menu Settings Guides utilisateur : Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation) Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Pr\u00e9sentation"},{"location":"user/studio/#les-interfaces-tock-studio","text":"Tock Studio regroupe l'ensemble des interfaces utilisateur, techniques et m\u00e9tier, permettant de concevoir les mod\u00e8les conversationnels, cr\u00e9er des parcours et des r\u00e9ponses, suivre les conversations, analyser les tendances, etc. Dans cette section, vous trouverez la description de chaque vue et interface. Pour des th\u00e8mes ou fonctionnalit\u00e9s particuli\u00e8res, voir aussi les guides utilisateur. Interfaces de Tock Studio : Interface g\u00e9n\u00e9rale Le menu Language Understanding Le menu Stories & Answers Le menu Test Le menu Analytics Le menu Model Quality Le menu Settings Guides utilisateur : Construire un mod\u00e8le conversationnel Cr\u00e9er un bot multicanal (connecteurs) Cr\u00e9er un bot multilingue (internationalisation) Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Les interfaces Tock Studio"},{"location":"user/guides/build-model/","text":"Construire les mod\u00e8les conversationnels \u00b6 La documentation Tock Studio peut \u00eatre parcourue \u00e9cran par \u00e9cran, notamment les menus Language Understanding et Model Quality pour la gestion des mod\u00e8les conversationnels. N'h\u00e9sitez pas \u00e0 vous y r\u00e9f\u00e9rer si vous avez une question sur un onglet / une option en particulier. Cette page pr\u00e9sente la construction des mod\u00e8les en se focalisant plus sur l'usage et l'apprentissage, s'autorisant \u00e0 passer d'un \u00e9cran \u00e0 un autre sans d\u00e9tailler exhaustivement chaque fonctionnalit\u00e9 de la plateforme. Notez qu'il est possible de d\u00e9ployer la plateforme Tock NLU seule, dans ce cas les interfaces graphiques Tock se limitent aux menus Settings , Language Understanding et Model Quality . Cette page peut donc servir de tutoriel pour une utilisation de Tock restreinte au Language Understanding , par exemple pour un usage comme l' Internet des objets . Rendez-vous dans la section Language Understanding \u00b6 Le menu Language Understanding renvoie sur l'onglet Inbox par d\u00e9faut. Au d\u00e9part vous n'avez pas de phrases si personne n'a encore parl\u00e9 au bot : Ajoutez et qualifiez des phrases \u00b6 Ajoutez une phrase \u00b6 Rendez-vous dans l'\u00e9cran New Sentence Saisissez une phrase Cr\u00e9ez une nouvelle intention \u00b6 Attribuez \u00e0 la phrase une nouvelle intention en s\u00e9lectionnant Create a New Intent dans la liste de s\u00e9lection Intent . Sp\u00e9cifiez des entit\u00e9s \u00b6 Selon ce \u00e0 quoi est destin\u00e9e l'intention, vous pouvez sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse dans la phrase : S\u00e9lectionnez une portion de phrase correspondant \u00e0 l'entit\u00e9 (ie. un groupe de mots \u00e0 s\u00e9lectionner avec la souris) Cliquez sur Add New Entity qui vient d'appara\u00eetre Choisissez un type d'entit\u00e9 existant ou cr\u00e9ez-en un nouveau Donnez un r\u00f4le \u00e0 cette entit\u00e9 Exemple : dans la phrase \"je veux aller de Paris \u00e0 New York\", probablement que Paris et New York sont deux entit\u00e9s du m\u00eame type (localit\u00e9) mais n'ont pas le m\u00eame r\u00f4le dans l'intention (origine et destination). Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase. Tirez parti des entit\u00e9s pr\u00e9d\u00e9finies \u00b6 Par d\u00e9faut, Tock propose un certain nombre de types d' entit\u00e9s pr\u00e9d\u00e9finies , notamment les types support\u00e9s par la biblioth\u00e8que Duckling : montants, dates, etc. Si vous s\u00e9lectionnez ces types d'entit\u00e9s, celles-ci seront automatiquement reconnues et valoris\u00e9es. Validez la phrase \u00b6 Lorsque l'intention et les entit\u00e9s sont correctes, terminez la qualification de la phrase en cliquant sur Validate . Qualifiez d'autres phrases \u00b6 Apr\u00e8s deux ou trois phrases pour une intention donn\u00e9e, il est courant que le mod\u00e8le commence \u00e0 reconna\u00eetre les phrases suivantes et d\u00e9tectent bien l'intention (avec un score grandissant, du moment que les phrases sont relativement proches / en rapport avec l'intention bien s\u00fbr) : Si une phrase n'est pas bien qualifi\u00e9e, changez l'intention / les entit\u00e9s puis faites Validate pour appliquer la correction. Si la phrase \u00e9tait bien qualifi\u00e9e, faites directement Validate . Dans les deux cas, vous alimentez ainsi le mod\u00e8le, qui se reconstruit, et devient plus pertinent pour les pharses suivantes. Vous \u00eates en train de construire votre mod\u00e8le conversationnel ! C'est le d\u00e9but de l' apprentissage pour votre bot ou votre application conversationnelle. La qualification de phrases, leur nombre mais aussi leur vari\u00e9t\u00e9 (notamment dans le temps, car les utilisateurs d'aujourd'hui ne sont pas exactement les utilisateurs de demain) sont la base d'un mod\u00e8le pertinent et d'une bonne exp\u00e9rience conversationnelle pour les utilisateurs. Parcourez les phrases du mod\u00e8le \u00b6 L'onglet Search permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res. Le plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res. Chaque phrase \u00e0 un \u00e9tat Status qui peut \u00e9voluer au cours du temps : Inbox : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le Validated : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante) Included in model : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP Cet \u00e9cran permet donc de consulter les phrases faisant d\u00e9j\u00e0 partie du mod\u00e8le (autrement dit d\u00e9j\u00e0 qualifi\u00e9s), et de faire \u00e9voluer les qualifications de phrases au cours du temps. Il est notamment possible de re-qualifier tout un groupe de phrases. Par exemple, vous pourrez cr\u00e9er une nouvelle intention plus tard et d\u00e9cider que toutes les phrases remplissant un certain crit\u00e8re (mot-clef ou autre) devront dor\u00e9navant \u00eatre qualifi\u00e9es dans cette nouvelle intention. Modifiez les caract\u00e9ristiques avanc\u00e9es de l'application \u00b6 Le menu Applications donne acc\u00e8s \u00e0 la liste des applications/bots disponibles sur la plateforme : Avec le bouton de modification, plusieurs options sont disponibles, en particulier : La s\u00e9lection du moteur NLU \u00b6 Vous avez la possibilit\u00e9 de s\u00e9lectionner la biblioth\u00e8que NLU utilis\u00e9e par ce bot (\u00e0 condition que plusieurs moteurs soient pr\u00e9sents dans l'installation de la plateforme). L'activation des mod\u00e8les d'entit\u00e9s \u00b6 Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. Par exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 duckling:datetime , les dates seront automatiquement reconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention. En interne, un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le. Cette option est activ\u00e9e par d\u00e9faut. Il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels la d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s. L'activation des sous-entit\u00e9s \u00b6 Si vous activez cette option, vous pourrez qualifier plusieurs niveaux d'entit\u00e9s : Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4. Valeurs pr\u00e9definies d'entit\u00e9s \u00b6 Une entit\u00e9 donn\u00e9e peut avoir des valeurs pr\u00e9d\u00e9finies . Pour cela vous devez aller dans l'onglet Entities , selectionnez une entit\u00e9. L'ic\u00f4ne \u00e0 cot\u00e9 de l'ic\u00f4ne de suppression montre les types d'entit\u00e9s que vous pouvez modifier : Dans l'exemple ci-dessus, deux labels sont d\u00e9finis pour la valeur de semaine : Semaine hebdomadaire Continuer... \u00b6 Pour en savoir plus sur la gestion des entit\u00e9s, notamment dans des intentions cr\u00e9\u00e9es programmatiquement, out tout simplement pour continuer de parcourir le manuel utilisateur Tock, vous pouvez vous rendre dans le chapitre D\u00e9veloppement .","title":"Construire un mod\u00e8le conversationnel"},{"location":"user/guides/build-model/#construire-les-modeles-conversationnels","text":"La documentation Tock Studio peut \u00eatre parcourue \u00e9cran par \u00e9cran, notamment les menus Language Understanding et Model Quality pour la gestion des mod\u00e8les conversationnels. N'h\u00e9sitez pas \u00e0 vous y r\u00e9f\u00e9rer si vous avez une question sur un onglet / une option en particulier. Cette page pr\u00e9sente la construction des mod\u00e8les en se focalisant plus sur l'usage et l'apprentissage, s'autorisant \u00e0 passer d'un \u00e9cran \u00e0 un autre sans d\u00e9tailler exhaustivement chaque fonctionnalit\u00e9 de la plateforme. Notez qu'il est possible de d\u00e9ployer la plateforme Tock NLU seule, dans ce cas les interfaces graphiques Tock se limitent aux menus Settings , Language Understanding et Model Quality . Cette page peut donc servir de tutoriel pour une utilisation de Tock restreinte au Language Understanding , par exemple pour un usage comme l' Internet des objets .","title":"Construire les mod\u00e8les conversationnels"},{"location":"user/guides/build-model/#rendez-vous-dans-la-section-language-understanding","text":"Le menu Language Understanding renvoie sur l'onglet Inbox par d\u00e9faut. Au d\u00e9part vous n'avez pas de phrases si personne n'a encore parl\u00e9 au bot :","title":"Rendez-vous dans la section Language Understanding"},{"location":"user/guides/build-model/#ajoutez-et-qualifiez-des-phrases","text":"","title":"Ajoutez et qualifiez des phrases"},{"location":"user/guides/build-model/#ajoutez-une-phrase","text":"Rendez-vous dans l'\u00e9cran New Sentence Saisissez une phrase","title":"Ajoutez une phrase"},{"location":"user/guides/build-model/#creez-une-nouvelle-intention","text":"Attribuez \u00e0 la phrase une nouvelle intention en s\u00e9lectionnant Create a New Intent dans la liste de s\u00e9lection Intent .","title":"Cr\u00e9ez une nouvelle intention"},{"location":"user/guides/build-model/#specifiez-des-entites","text":"Selon ce \u00e0 quoi est destin\u00e9e l'intention, vous pouvez sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse dans la phrase : S\u00e9lectionnez une portion de phrase correspondant \u00e0 l'entit\u00e9 (ie. un groupe de mots \u00e0 s\u00e9lectionner avec la souris) Cliquez sur Add New Entity qui vient d'appara\u00eetre Choisissez un type d'entit\u00e9 existant ou cr\u00e9ez-en un nouveau Donnez un r\u00f4le \u00e0 cette entit\u00e9 Exemple : dans la phrase \"je veux aller de Paris \u00e0 New York\", probablement que Paris et New York sont deux entit\u00e9s du m\u00eame type (localit\u00e9) mais n'ont pas le m\u00eame r\u00f4le dans l'intention (origine et destination). Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase.","title":"Sp\u00e9cifiez des entit\u00e9s"},{"location":"user/guides/build-model/#tirez-parti-des-entites-predefinies","text":"Par d\u00e9faut, Tock propose un certain nombre de types d' entit\u00e9s pr\u00e9d\u00e9finies , notamment les types support\u00e9s par la biblioth\u00e8que Duckling : montants, dates, etc. Si vous s\u00e9lectionnez ces types d'entit\u00e9s, celles-ci seront automatiquement reconnues et valoris\u00e9es.","title":"Tirez parti des entit\u00e9s pr\u00e9d\u00e9finies"},{"location":"user/guides/build-model/#validez-la-phrase","text":"Lorsque l'intention et les entit\u00e9s sont correctes, terminez la qualification de la phrase en cliquant sur Validate .","title":"Validez la phrase"},{"location":"user/guides/build-model/#qualifiez-dautres-phrases","text":"Apr\u00e8s deux ou trois phrases pour une intention donn\u00e9e, il est courant que le mod\u00e8le commence \u00e0 reconna\u00eetre les phrases suivantes et d\u00e9tectent bien l'intention (avec un score grandissant, du moment que les phrases sont relativement proches / en rapport avec l'intention bien s\u00fbr) : Si une phrase n'est pas bien qualifi\u00e9e, changez l'intention / les entit\u00e9s puis faites Validate pour appliquer la correction. Si la phrase \u00e9tait bien qualifi\u00e9e, faites directement Validate . Dans les deux cas, vous alimentez ainsi le mod\u00e8le, qui se reconstruit, et devient plus pertinent pour les pharses suivantes. Vous \u00eates en train de construire votre mod\u00e8le conversationnel ! C'est le d\u00e9but de l' apprentissage pour votre bot ou votre application conversationnelle. La qualification de phrases, leur nombre mais aussi leur vari\u00e9t\u00e9 (notamment dans le temps, car les utilisateurs d'aujourd'hui ne sont pas exactement les utilisateurs de demain) sont la base d'un mod\u00e8le pertinent et d'une bonne exp\u00e9rience conversationnelle pour les utilisateurs.","title":"Qualifiez d'autres phrases"},{"location":"user/guides/build-model/#parcourez-les-phrases-du-modele","text":"L'onglet Search permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res. Le plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res. Chaque phrase \u00e0 un \u00e9tat Status qui peut \u00e9voluer au cours du temps : Inbox : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le Validated : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante) Included in model : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP Cet \u00e9cran permet donc de consulter les phrases faisant d\u00e9j\u00e0 partie du mod\u00e8le (autrement dit d\u00e9j\u00e0 qualifi\u00e9s), et de faire \u00e9voluer les qualifications de phrases au cours du temps. Il est notamment possible de re-qualifier tout un groupe de phrases. Par exemple, vous pourrez cr\u00e9er une nouvelle intention plus tard et d\u00e9cider que toutes les phrases remplissant un certain crit\u00e8re (mot-clef ou autre) devront dor\u00e9navant \u00eatre qualifi\u00e9es dans cette nouvelle intention.","title":"Parcourez les phrases du mod\u00e8le"},{"location":"user/guides/build-model/#modifiez-les-caracteristiques-avancees-de-lapplication","text":"Le menu Applications donne acc\u00e8s \u00e0 la liste des applications/bots disponibles sur la plateforme : Avec le bouton de modification, plusieurs options sont disponibles, en particulier :","title":"Modifiez les caract\u00e9ristiques avanc\u00e9es de l'application"},{"location":"user/guides/build-model/#la-selection-du-moteur-nlu","text":"Vous avez la possibilit\u00e9 de s\u00e9lectionner la biblioth\u00e8que NLU utilis\u00e9e par ce bot (\u00e0 condition que plusieurs moteurs soient pr\u00e9sents dans l'installation de la plateforme).","title":"La s\u00e9lection du moteur NLU"},{"location":"user/guides/build-model/#lactivation-des-modeles-dentites","text":"Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. Par exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 duckling:datetime , les dates seront automatiquement reconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention. En interne, un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le. Cette option est activ\u00e9e par d\u00e9faut. Il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels la d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s.","title":"L'activation des mod\u00e8les d'entit\u00e9s"},{"location":"user/guides/build-model/#lactivation-des-sous-entites","text":"Si vous activez cette option, vous pourrez qualifier plusieurs niveaux d'entit\u00e9s : Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4.","title":"L'activation des sous-entit\u00e9s"},{"location":"user/guides/build-model/#valeurs-predefinies-dentites","text":"Une entit\u00e9 donn\u00e9e peut avoir des valeurs pr\u00e9d\u00e9finies . Pour cela vous devez aller dans l'onglet Entities , selectionnez une entit\u00e9. L'ic\u00f4ne \u00e0 cot\u00e9 de l'ic\u00f4ne de suppression montre les types d'entit\u00e9s que vous pouvez modifier : Dans l'exemple ci-dessus, deux labels sont d\u00e9finis pour la valeur de semaine : Semaine hebdomadaire","title":"Valeurs pr\u00e9definies d'entit\u00e9s"},{"location":"user/guides/build-model/#continuer","text":"Pour en savoir plus sur la gestion des entit\u00e9s, notamment dans des intentions cr\u00e9\u00e9es programmatiquement, out tout simplement pour continuer de parcourir le manuel utilisateur Tock, vous pouvez vous rendre dans le chapitre D\u00e9veloppement .","title":"Continuer..."},{"location":"user/guides/canaux/","text":"Construire un bot multicanal avec Tock \u00b6 Notion de connecteur \u00b6 Un connecteur Tock permet d'int\u00e9grer un bot \u00e0 un canal de communication (textuel ou vocal) externe. Mis \u00e0 part le type connecteur de test (utilis\u00e9 en interne par l'interface Tock Studio ), les connecteurs sont associ\u00e9s \u00e0 des canaux externes \u00e0 la plateforme Tock. Tout l'int\u00e9r\u00eat des connecteurs Tock r\u00e9side dans la possibilit\u00e9 de d\u00e9velopper des assistants conversationnels ind\u00e9pendamment du ou des canaux utilis\u00e9s pour lui parler. Il est ainsi possible de cr\u00e9er un bot pour un canal, puis le rendre multicanal par la suite en ajoutant des connecteurs. Le connecteur Web a la particularit\u00e9 d'exposer une API g\u00e9n\u00e9rique pour interagir avec un bot Tock. En cons\u00e9quence, il permet encore davantage d'int\u00e9grations c\u00f4t\u00e9 \"frontend\", utilisant cette API comme passerelle. Cette page liste en fait : Les connecteurs fournis avec la distribution Tock : Les kits utilisant le connecteur Web pour int\u00e9grer d'autres canaux : Les int\u00e9grations possibles pour le traitement de la voix : Connecteurs fournis avec Tock \u00b6 Tock fournit de nombreux connecteurs pour diff\u00e9rents types de canaux (voir ci-dessous). De nouveaux connecteurs sont r\u00e9guli\u00e8rement ajout\u00e9s \u00e0 la plateforme, en fonction des besoins projets mais aussi du calendrier d'ouverture aux bots des canaux grand public. Exemples : arriv\u00e9e de Google Home en France en 2017, Alexa en 2018, ouverture des API WhatsApp puis Business Chat en 2019, etc. Pour en savoir plus sur les bots r\u00e9f\u00e9renc\u00e9s utilisant tel ou tel connecteur en production, n'h\u00e9sitez pas \u00e0 consulter la page vitrine Tock . Messenger \u00b6 Canal : Facebook Messenger Type : texte (+ voix via l'upload de messages vocaux) Status : connecteur Tock utilis\u00e9 en production depuis 2016 Le guide Connecter son bot \u00e0 Messenger explique comment int\u00e9grer un bot Tock avec une page Facebook / Messenger . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-messenger sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Slack \u00b6 Canal : Slack Type : texte Status : connecteur Tock utilis\u00e9 hors production Le guide Connecter son bot \u00e0 Slack explique comment int\u00e9grer un bot Tock avec une cha\u00eene Slack . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur. Google Assistant / Home \u00b6 Canal : Google Assistant / Google Home Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2017 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-ga sur GitHub. Alexa / Echo \u00b6 Canal : Amazon Alexa / Amazon Echo Type : voix Status : connecteur Tock utilis\u00e9 en production depuis 2018 Remarque importante : dans le cas d'Alexa, le mod\u00e8le NLP est forc\u00e9ment construit et h\u00e9berg\u00e9 chez Amazon. Seul la partie framework conversationel de Tock peut \u00eatre utilis\u00e9e. Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-alexa sur GitHub. Rocket.Chat \u00b6 Canal : Rocket.Chat Type : texte Status : \u00e0 pr\u00e9ciser Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-rocketchat sur GitHub. WhatsApp \u00b6 Canal : WhatsApp from Facebook Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-whatsapp sur GitHub. Teams \u00b6 Canal : Microsoft Teams Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-teams sur GitHub. Business Chat \u00b6 Canal : Apple Business Chat (Messages) Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-businesschat sur GitHub. Twitter \u00b6 Canal : Twitter (messages priv\u00e9s) Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-twitter sur GitHub. Allo-Media \u00b6 Canal : Allo-Media (t\u00e9l\u00e9phonie) Type : voix Status : connecteur Tock utilis\u00e9 en production depuis 2020 Ce connecteur a \u00e9t\u00e9 d\u00e9velopp\u00e9 pour le bot AlloCovid . Pour en savoir plus, voir la classe AlloMediaConnector avec les sources du bot sur GitHub. Google Chat \u00b6 Canal : Google Chat (anciennement Google Hangouts) Type : texte Status : connecteur Tock utilis\u00e9 hors production Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-google-chat sur GitHub. Web (g\u00e9n\u00e9rique) \u00b6 Ce connecteur g\u00e9n\u00e9rique permet d'int\u00e9grer un bot Tock \u00e0 n'importe quel site Web ou application : portail, application Web ou mobile, client REST, etc. Le connecteur expose une API REST vers le bot, facilement int\u00e9grable depuis n'importe quelle application Web ou mobile, ou langage de programmation. Plusieurs kits et composants bas\u00e9s sur le connecteur Web sont d\u00e9j\u00e0 disponibles pour int\u00e9grer des bots Tock \u00e0 diff\u00e9rents sites et applications, comme des sites Web avec React , des applications mobiles natives avec Flutter ou encore des intranets SharePoint . Canal : Web (g\u00e9n\u00e9rique pour tous sites & applications Web) Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2020 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-web sur GitHub. Il contient exemples et documentation format Swagger de l'API REST. Test (g\u00e9n\u00e9rique) \u00b6 Ce connecteur est interne \u00e0 Tock, il sert \u00e0 dialoguer avec un bot directement dans l'interface Tock Studio (vue Test > Test the bot ) en \u00e9mulant d'autres connecteurs. Int\u00e9grations via le connecteur Web \u00b6 Le connecteur Web expose une API g\u00e9n\u00e9rique pour interagir avec un bot Tock. En cons\u00e9quence, il permet encore davantage d'int\u00e9grations c\u00f4t\u00e9 \"frontend\", utilisant cette API comme passerelle. React \u00b6 Ce composant React int\u00e8gre un bot Tock et en assure le rendu graphique dans une application Web. L'application Web communique avec le bot via un connecteur Web . Int\u00e9gration : React (JavaScript / JSX) Type : applications Web Status : utilis\u00e9 en production depuis 2020 Pour en savoir plus, voir les sources et le README dans le d\u00e9p\u00f4t tock-react-kit sur GitHub. Flutter (beta) \u00b6 Ce composant Flutter int\u00e8gre un bot Tock et en assure le rendu graphique dans une application mobile ou Web. L'application communique avec le bot via un connecteur Web . Int\u00e9gration : Flutter (Dart) Type : applications mobiles natives et Web Status : beta, en d\u00e9veloppement Pour en savoir plus, voir les sources et le README dans le d\u00e9p\u00f4t tock-flutter-kit sur GitHub. SharePoint (beta) \u00b6 Ce composant WebPart permet d'int\u00e9grer un bot Tock dans un site SharePoint. Il embarque le tock-react-kit pour communiquer avec le bot via un connecteur Web et g\u00e9rer le rendu graphique du bot dans la page SharePoint. Int\u00e9gration : Microsoft SharePoint Type : sites Web & intranets Status : beta, en d\u00e9veloppement Pour en savoir plus, voir les sources et le README dans le d\u00e9p\u00f4t tock-sharepoint sur GitHub. Technologies vocales \u00b6 Les bots Tock traitent des phrases en format texte par d\u00e9faut ( chatbots ). N\u00e9anmoins, on peut int\u00e9grer des technologies vocales aux \"bornes\" du bot afin d'obtenir des conversations vocales ( voicebots et callbots ) : Traduction de la voix en texte ( Speech-To-Text ) en amont du traitement par le bot (ie. avant l'\u00e9tape NLU ) Traduction du texte en voix ( Text-To-Speech ) en aval du traitement par le bot (ie. synth\u00e8se vocale de la r\u00e9ponse du bot) Certains connecteurs fournis avec Tock permettent d'int\u00e9grer un bot \u00e0 un canal externe g\u00e9rant les aspects vocaux STT et TTS. En outre, d'autres technologies vocales ont pu \u00eatre int\u00e9gr\u00e9es \u00e0 Tock ces derni\u00e8res ann\u00e9es. Elles sont mentionn\u00e9es \u00e0 titre indicatif, m\u00eame quand il n'est pas fourni de connecteur pr\u00eat \u00e0 l'emploi. Google / Android \u00b6 Les fonctions Speech-To-Text et Text-To-Speech de Google sont utilis\u00e9es \u00e0 travers le connecteur Google Assistant / Home , \u00e9galement par les fonctions vocales de l' application Microsoft Teams pour Android compatible avec le connecteur Teams , ainsi qu'au sein de la plateforme Android notamment pour des d\u00e9veloppements mobiles natifs. Technologie : STT & TTS Google / Android Status : utilis\u00e9 avec Tock en production (via connecteurs Google Assistant / Home , Microsoft Teams et en natif Android pour les bots int\u00e9gr\u00e9s on-app ) Apple / iOS \u00b6 Les fonctions Speech-To-Text et Text-To-Speech d'Apple sont utilis\u00e9es \u00e0 travers le connecteur Business Chat , ainsi qu'au sein d'iOS pour des d\u00e9veloppements mobiles natifs. Technologie : STT & TTS Apple / iOS Status : utilis\u00e9 avec Tock en production (via connecteur Business Chat et en natif iOS pour les bots int\u00e9gr\u00e9s on-app ) Amazon / Alexa \u00b6 Les fonctions Speech-To-Text et Text-To-Speech d'Alexa (Amazon) sont utilis\u00e9es \u00e0 travers le connecteur Alexa / Echo . Technologie : STT & TTS Amazon / Alexa Status : utilis\u00e9 avec Tock en production (via connecteur Alexa) Allo-Media & Voxygen \u00b6 La soci\u00e9t\u00e9 Allo-Media propose une plateforme IA bas\u00e9e sur les appels t\u00e9l\u00e9phoniques. Voxygen propose des services de synth\u00e8se vocale. A l'occasion du d\u00e9veloppement du bot AlloCovid , un connecteur Allo-Media a \u00e9t\u00e9 d\u00e9velopp\u00e9 pour int\u00e9grer le bot (Tock) aux services Allo-Media : Speech-To-Text et Text-To-Speech avec Voxygen. Technologie : Allo-Media & Voxygen Status : utilis\u00e9 avec Tock en production (via connecteur Allo-Media) Nuance \u00b6 Nuance propose des solutions de reconnaissance vocale & IA. Pour des exp\u00e9rimentations de commande vocale en 2016, Nuance avait \u00e9t\u00e9 int\u00e9gr\u00e9 \u00e0 Tock pour ses fonctions Speech-To-Text . M\u00eame si cette int\u00e9gration n'a pas \u00e9t\u00e9 maintenue depuis, cela fonctionnait apr\u00e8s quelques jours de mise en place. Technologie : Nuance Status : utilis\u00e9 avec Tock en 2016 Architecture de connecteurs & gouvernance des donn\u00e9es \u00b6 Dans une optique de gouvernance des mod\u00e8les et donn\u00e9es conversationnelles, l'architecture en connecteurs Tock pr\u00e9sente plusieurs avantages : Le mod\u00e8le est construit dans Tock, il n'est pas partag\u00e9 via les connecteurs Le choix des connecteurs d'un bot permet de maitriser la propagation (ou non) des conversations Par exemple, pour un bot interne \u00e0 une entreprise, on peut choisir de n'utiliser que des connecteurs vers des canaux propres (site Web, etc.) ou internes \u00e0 l'entreprise (applications d'entreprise, espace pro sur un t\u00e9l\u00e9phone Android, etc.). M\u00eame si un bot est connect\u00e9 \u00e0 plusieurs canaux/partenaires externes, seule la plateforme Tock poss\u00e8de l'ensemble des conversations sur tous ces canaux. D\u00e9velopper son propre connecteur \u00b6 Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. La section Bot Framework du manuel d\u00e9veloppeur Tock donne des indications pour impl\u00e9menter son propre connecteur.","title":"Bot multicanal"},{"location":"user/guides/canaux/#construire-un-bot-multicanal-avec-tock","text":"","title":"Construire un bot multicanal avec Tock"},{"location":"user/guides/canaux/#notion-de-connecteur","text":"Un connecteur Tock permet d'int\u00e9grer un bot \u00e0 un canal de communication (textuel ou vocal) externe. Mis \u00e0 part le type connecteur de test (utilis\u00e9 en interne par l'interface Tock Studio ), les connecteurs sont associ\u00e9s \u00e0 des canaux externes \u00e0 la plateforme Tock. Tout l'int\u00e9r\u00eat des connecteurs Tock r\u00e9side dans la possibilit\u00e9 de d\u00e9velopper des assistants conversationnels ind\u00e9pendamment du ou des canaux utilis\u00e9s pour lui parler. Il est ainsi possible de cr\u00e9er un bot pour un canal, puis le rendre multicanal par la suite en ajoutant des connecteurs. Le connecteur Web a la particularit\u00e9 d'exposer une API g\u00e9n\u00e9rique pour interagir avec un bot Tock. En cons\u00e9quence, il permet encore davantage d'int\u00e9grations c\u00f4t\u00e9 \"frontend\", utilisant cette API comme passerelle. Cette page liste en fait : Les connecteurs fournis avec la distribution Tock : Les kits utilisant le connecteur Web pour int\u00e9grer d'autres canaux : Les int\u00e9grations possibles pour le traitement de la voix :","title":"Notion de connecteur"},{"location":"user/guides/canaux/#connecteurs-fournis-avec-tock","text":"Tock fournit de nombreux connecteurs pour diff\u00e9rents types de canaux (voir ci-dessous). De nouveaux connecteurs sont r\u00e9guli\u00e8rement ajout\u00e9s \u00e0 la plateforme, en fonction des besoins projets mais aussi du calendrier d'ouverture aux bots des canaux grand public. Exemples : arriv\u00e9e de Google Home en France en 2017, Alexa en 2018, ouverture des API WhatsApp puis Business Chat en 2019, etc. Pour en savoir plus sur les bots r\u00e9f\u00e9renc\u00e9s utilisant tel ou tel connecteur en production, n'h\u00e9sitez pas \u00e0 consulter la page vitrine Tock .","title":"Connecteurs fournis avec Tock"},{"location":"user/guides/canaux/#messenger","text":"Canal : Facebook Messenger Type : texte (+ voix via l'upload de messages vocaux) Status : connecteur Tock utilis\u00e9 en production depuis 2016 Le guide Connecter son bot \u00e0 Messenger explique comment int\u00e9grer un bot Tock avec une page Facebook / Messenger . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-messenger sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur.","title":"Messenger"},{"location":"user/guides/canaux/#slack","text":"Canal : Slack Type : texte Status : connecteur Tock utilis\u00e9 hors production Le guide Connecter son bot \u00e0 Slack explique comment int\u00e9grer un bot Tock avec une cha\u00eene Slack . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-slack sur GitHub, o\u00f9 vous retrouverez les sources et le README du connecteur.","title":"Slack"},{"location":"user/guides/canaux/#google-assistant-home","text":"Canal : Google Assistant / Google Home Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2017 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-ga sur GitHub.","title":"Google Assistant / Home"},{"location":"user/guides/canaux/#alexa-echo","text":"Canal : Amazon Alexa / Amazon Echo Type : voix Status : connecteur Tock utilis\u00e9 en production depuis 2018 Remarque importante : dans le cas d'Alexa, le mod\u00e8le NLP est forc\u00e9ment construit et h\u00e9berg\u00e9 chez Amazon. Seul la partie framework conversationel de Tock peut \u00eatre utilis\u00e9e. Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-alexa sur GitHub.","title":"Alexa / Echo"},{"location":"user/guides/canaux/#rocketchat","text":"Canal : Rocket.Chat Type : texte Status : \u00e0 pr\u00e9ciser Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-rocketchat sur GitHub.","title":"Rocket.Chat"},{"location":"user/guides/canaux/#whatsapp","text":"Canal : WhatsApp from Facebook Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-whatsapp sur GitHub.","title":"WhatsApp"},{"location":"user/guides/canaux/#teams","text":"Canal : Microsoft Teams Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-teams sur GitHub.","title":"Teams"},{"location":"user/guides/canaux/#business-chat","text":"Canal : Apple Business Chat (Messages) Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-businesschat sur GitHub.","title":"Business Chat"},{"location":"user/guides/canaux/#twitter","text":"Canal : Twitter (messages priv\u00e9s) Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-twitter sur GitHub.","title":"Twitter"},{"location":"user/guides/canaux/#allo-media","text":"Canal : Allo-Media (t\u00e9l\u00e9phonie) Type : voix Status : connecteur Tock utilis\u00e9 en production depuis 2020 Ce connecteur a \u00e9t\u00e9 d\u00e9velopp\u00e9 pour le bot AlloCovid . Pour en savoir plus, voir la classe AlloMediaConnector avec les sources du bot sur GitHub.","title":"Allo-Media"},{"location":"user/guides/canaux/#google-chat","text":"Canal : Google Chat (anciennement Google Hangouts) Type : texte Status : connecteur Tock utilis\u00e9 hors production Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-google-chat sur GitHub.","title":"Google Chat"},{"location":"user/guides/canaux/#web-generique","text":"Ce connecteur g\u00e9n\u00e9rique permet d'int\u00e9grer un bot Tock \u00e0 n'importe quel site Web ou application : portail, application Web ou mobile, client REST, etc. Le connecteur expose une API REST vers le bot, facilement int\u00e9grable depuis n'importe quelle application Web ou mobile, ou langage de programmation. Plusieurs kits et composants bas\u00e9s sur le connecteur Web sont d\u00e9j\u00e0 disponibles pour int\u00e9grer des bots Tock \u00e0 diff\u00e9rents sites et applications, comme des sites Web avec React , des applications mobiles natives avec Flutter ou encore des intranets SharePoint . Canal : Web (g\u00e9n\u00e9rique pour tous sites & applications Web) Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2020 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-web sur GitHub. Il contient exemples et documentation format Swagger de l'API REST.","title":"Web (g\u00e9n\u00e9rique)"},{"location":"user/guides/canaux/#test-generique","text":"Ce connecteur est interne \u00e0 Tock, il sert \u00e0 dialoguer avec un bot directement dans l'interface Tock Studio (vue Test > Test the bot ) en \u00e9mulant d'autres connecteurs.","title":"Test (g\u00e9n\u00e9rique)"},{"location":"user/guides/canaux/#integrations-via-le-connecteur-web","text":"Le connecteur Web expose une API g\u00e9n\u00e9rique pour interagir avec un bot Tock. En cons\u00e9quence, il permet encore davantage d'int\u00e9grations c\u00f4t\u00e9 \"frontend\", utilisant cette API comme passerelle.","title":"Int\u00e9grations via le connecteur Web"},{"location":"user/guides/canaux/#react","text":"Ce composant React int\u00e8gre un bot Tock et en assure le rendu graphique dans une application Web. L'application Web communique avec le bot via un connecteur Web . Int\u00e9gration : React (JavaScript / JSX) Type : applications Web Status : utilis\u00e9 en production depuis 2020 Pour en savoir plus, voir les sources et le README dans le d\u00e9p\u00f4t tock-react-kit sur GitHub.","title":"React"},{"location":"user/guides/canaux/#flutter-beta","text":"Ce composant Flutter int\u00e8gre un bot Tock et en assure le rendu graphique dans une application mobile ou Web. L'application communique avec le bot via un connecteur Web . Int\u00e9gration : Flutter (Dart) Type : applications mobiles natives et Web Status : beta, en d\u00e9veloppement Pour en savoir plus, voir les sources et le README dans le d\u00e9p\u00f4t tock-flutter-kit sur GitHub.","title":"Flutter (beta)"},{"location":"user/guides/canaux/#sharepoint-beta","text":"Ce composant WebPart permet d'int\u00e9grer un bot Tock dans un site SharePoint. Il embarque le tock-react-kit pour communiquer avec le bot via un connecteur Web et g\u00e9rer le rendu graphique du bot dans la page SharePoint. Int\u00e9gration : Microsoft SharePoint Type : sites Web & intranets Status : beta, en d\u00e9veloppement Pour en savoir plus, voir les sources et le README dans le d\u00e9p\u00f4t tock-sharepoint sur GitHub.","title":"SharePoint (beta)"},{"location":"user/guides/canaux/#technologies-vocales","text":"Les bots Tock traitent des phrases en format texte par d\u00e9faut ( chatbots ). N\u00e9anmoins, on peut int\u00e9grer des technologies vocales aux \"bornes\" du bot afin d'obtenir des conversations vocales ( voicebots et callbots ) : Traduction de la voix en texte ( Speech-To-Text ) en amont du traitement par le bot (ie. avant l'\u00e9tape NLU ) Traduction du texte en voix ( Text-To-Speech ) en aval du traitement par le bot (ie. synth\u00e8se vocale de la r\u00e9ponse du bot) Certains connecteurs fournis avec Tock permettent d'int\u00e9grer un bot \u00e0 un canal externe g\u00e9rant les aspects vocaux STT et TTS. En outre, d'autres technologies vocales ont pu \u00eatre int\u00e9gr\u00e9es \u00e0 Tock ces derni\u00e8res ann\u00e9es. Elles sont mentionn\u00e9es \u00e0 titre indicatif, m\u00eame quand il n'est pas fourni de connecteur pr\u00eat \u00e0 l'emploi.","title":"Technologies vocales"},{"location":"user/guides/canaux/#google-android","text":"Les fonctions Speech-To-Text et Text-To-Speech de Google sont utilis\u00e9es \u00e0 travers le connecteur Google Assistant / Home , \u00e9galement par les fonctions vocales de l' application Microsoft Teams pour Android compatible avec le connecteur Teams , ainsi qu'au sein de la plateforme Android notamment pour des d\u00e9veloppements mobiles natifs. Technologie : STT & TTS Google / Android Status : utilis\u00e9 avec Tock en production (via connecteurs Google Assistant / Home , Microsoft Teams et en natif Android pour les bots int\u00e9gr\u00e9s on-app )","title":"Google / Android"},{"location":"user/guides/canaux/#apple-ios","text":"Les fonctions Speech-To-Text et Text-To-Speech d'Apple sont utilis\u00e9es \u00e0 travers le connecteur Business Chat , ainsi qu'au sein d'iOS pour des d\u00e9veloppements mobiles natifs. Technologie : STT & TTS Apple / iOS Status : utilis\u00e9 avec Tock en production (via connecteur Business Chat et en natif iOS pour les bots int\u00e9gr\u00e9s on-app )","title":"Apple / iOS"},{"location":"user/guides/canaux/#amazon-alexa","text":"Les fonctions Speech-To-Text et Text-To-Speech d'Alexa (Amazon) sont utilis\u00e9es \u00e0 travers le connecteur Alexa / Echo . Technologie : STT & TTS Amazon / Alexa Status : utilis\u00e9 avec Tock en production (via connecteur Alexa)","title":"Amazon / Alexa"},{"location":"user/guides/canaux/#allo-media-voxygen","text":"La soci\u00e9t\u00e9 Allo-Media propose une plateforme IA bas\u00e9e sur les appels t\u00e9l\u00e9phoniques. Voxygen propose des services de synth\u00e8se vocale. A l'occasion du d\u00e9veloppement du bot AlloCovid , un connecteur Allo-Media a \u00e9t\u00e9 d\u00e9velopp\u00e9 pour int\u00e9grer le bot (Tock) aux services Allo-Media : Speech-To-Text et Text-To-Speech avec Voxygen. Technologie : Allo-Media & Voxygen Status : utilis\u00e9 avec Tock en production (via connecteur Allo-Media)","title":"Allo-Media &amp; Voxygen"},{"location":"user/guides/canaux/#nuance","text":"Nuance propose des solutions de reconnaissance vocale & IA. Pour des exp\u00e9rimentations de commande vocale en 2016, Nuance avait \u00e9t\u00e9 int\u00e9gr\u00e9 \u00e0 Tock pour ses fonctions Speech-To-Text . M\u00eame si cette int\u00e9gration n'a pas \u00e9t\u00e9 maintenue depuis, cela fonctionnait apr\u00e8s quelques jours de mise en place. Technologie : Nuance Status : utilis\u00e9 avec Tock en 2016","title":"Nuance"},{"location":"user/guides/canaux/#architecture-de-connecteurs-gouvernance-des-donnees","text":"Dans une optique de gouvernance des mod\u00e8les et donn\u00e9es conversationnelles, l'architecture en connecteurs Tock pr\u00e9sente plusieurs avantages : Le mod\u00e8le est construit dans Tock, il n'est pas partag\u00e9 via les connecteurs Le choix des connecteurs d'un bot permet de maitriser la propagation (ou non) des conversations Par exemple, pour un bot interne \u00e0 une entreprise, on peut choisir de n'utiliser que des connecteurs vers des canaux propres (site Web, etc.) ou internes \u00e0 l'entreprise (applications d'entreprise, espace pro sur un t\u00e9l\u00e9phone Android, etc.). M\u00eame si un bot est connect\u00e9 \u00e0 plusieurs canaux/partenaires externes, seule la plateforme Tock poss\u00e8de l'ensemble des conversations sur tous ces canaux.","title":"Architecture de connecteurs &amp; gouvernance des donn\u00e9es"},{"location":"user/guides/canaux/#developper-son-propre-connecteur","text":"Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. La section Bot Framework du manuel d\u00e9veloppeur Tock donne des indications pour impl\u00e9menter son propre connecteur.","title":"D\u00e9velopper son propre connecteur"},{"location":"user/guides/i18n/","text":"Construire un bot multilingue avec Tock \u00b6 L'interface Tock Studio permet de traduire et moduler les r\u00e9ponses d'un bot en fonction de la langue mais aussi du canal utilis\u00e9s. Pr\u00e9-requis \u00b6 Tock met \u00e0 disposition un framework complet d'internationalisation. Il est activ\u00e9 par d\u00e9faut en mode Bot API (par exemple sur la plateforme de d\u00e9monstration ). Dans le mode Bot int\u00e9gr\u00e9 (voir le manuel d\u00e9veloppeur ), l'internationalisation est d\u00e9sactiv\u00e9e par d\u00e9faut. Pour l'activer, il est alors n\u00e9cessaire de configurer la plateforme \u00e0 son d\u00e9marrage : Soit via le code de d\u00e9marrage du bot (d\u00e9veloppeur) : Translator . enabled = true Soit avec une propri\u00e9t\u00e9 Syst\u00e8me (administrateur) en passant -Dtock_i18n_enabled=true au d\u00e9marrage de la JVM Activer plusieurs langues pour un bot \u00b6 Il est possible d'ajouter et de g\u00e9rer les langues actives pour un bot dans la section NLU Applications (dans Tock Studio ). Voir Le menu Settings . A tout moment dans Tock Studio , il est possible de changer la langue s\u00e9lectionn\u00e9e dans la banni\u00e8re en haut de page, notamment pour dialoguer avec un bot dans l'interface Test the bot . Voir Interface g\u00e9n\u00e9rale . Langue et locale utilisateur \u00b6 Quand c'est possible, la locale de l'utilisateur (langue / r\u00e9gion) est import\u00e9e de celle de son compte. Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en Fran\u00e7ais, le Fran\u00e7ais sera automatiquement s\u00e9lectionn\u00e9 par Tock. S'il n'y a pas d'indication de locale, c'est la locale par d\u00e9faut de Tock qui est utilis\u00e9e. Un d\u00e9veloppeur peut modifier la locale de l'utilisateur dans le code du bot lui-m\u00eame : userPreferences . locale = Locale . FRENCH Enfin, la locale par d\u00e9faut peut \u00eatre modifi\u00e9e par un administrateur de la plateforme, en passant la propri\u00e9t\u00e9 Syst\u00e8me -Dtock_default_locale=fr au d\u00e9marrage de la JVM. Traduire et faire varier les r\u00e9ponses du bot \u00b6 Dans Tock Studio , la section Stories & Answers > Answers permet de g\u00e9rer les libell\u00e9s des r\u00e9ponses du bot. Voir Le menu Stories & Answers . Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot. Il est possible de concevoir et configurer diff\u00e9rentes variantes : En fonction de la langue En fonction du canal / connecteur Par exemple, certains canaux requi\u00e8rent des libell\u00e9s sp\u00e9cifiques, soit parce que le propri\u00e9taire du canal l'exige (sur Alexa le vouvoiement est requis), soit parce que l'exp\u00e9rience utilisateur diff\u00e8re des autres canaux (par exemple en vocal on \u00e9vitera de trop longues phrases). Al\u00e9atoirement (pour que le bot ne r\u00e9ponde pas toujours la m\u00eame chose) Traduire massivement les mod\u00e8les et r\u00e9ponses \u00b6 Des fonctionnalit\u00e9s sont \u00e0 l'\u00e9tude pour permettre la traduction plus ou moins automatis\u00e9e de nombreuses phrases utilisateur (corpus / mod\u00e8le conversationnel) et r\u00e9ponses (libell\u00e9s / i18n). A suivre... Pour le moment, pour envisager une traduction de masse, on peut par exemple : Exporter les donn\u00e9es en JSON ou CSV avec Tock Studio Traduire les phrases/r\u00e9ponses en dehors de Tock (API SaaS, agence...) Importer les traductions avec Tock Studio Remarque : au moment de l'import seuls les libell\u00e9s marqu\u00e9s valid\u00e9s sont pris en compte. D\u00e9velopper avec l'internationalisation \u00b6 Le manuel d\u00e9veloppeur Tock donne plus de d\u00e9tails sur le d\u00e9veloppement des bots multilingues.","title":"Bot multilingue"},{"location":"user/guides/i18n/#construire-un-bot-multilingue-avec-tock","text":"L'interface Tock Studio permet de traduire et moduler les r\u00e9ponses d'un bot en fonction de la langue mais aussi du canal utilis\u00e9s.","title":"Construire un bot multilingue avec Tock"},{"location":"user/guides/i18n/#pre-requis","text":"Tock met \u00e0 disposition un framework complet d'internationalisation. Il est activ\u00e9 par d\u00e9faut en mode Bot API (par exemple sur la plateforme de d\u00e9monstration ). Dans le mode Bot int\u00e9gr\u00e9 (voir le manuel d\u00e9veloppeur ), l'internationalisation est d\u00e9sactiv\u00e9e par d\u00e9faut. Pour l'activer, il est alors n\u00e9cessaire de configurer la plateforme \u00e0 son d\u00e9marrage : Soit via le code de d\u00e9marrage du bot (d\u00e9veloppeur) : Translator . enabled = true Soit avec une propri\u00e9t\u00e9 Syst\u00e8me (administrateur) en passant -Dtock_i18n_enabled=true au d\u00e9marrage de la JVM","title":"Pr\u00e9-requis"},{"location":"user/guides/i18n/#activer-plusieurs-langues-pour-un-bot","text":"Il est possible d'ajouter et de g\u00e9rer les langues actives pour un bot dans la section NLU Applications (dans Tock Studio ). Voir Le menu Settings . A tout moment dans Tock Studio , il est possible de changer la langue s\u00e9lectionn\u00e9e dans la banni\u00e8re en haut de page, notamment pour dialoguer avec un bot dans l'interface Test the bot . Voir Interface g\u00e9n\u00e9rale .","title":"Activer plusieurs langues pour un bot"},{"location":"user/guides/i18n/#langue-et-locale-utilisateur","text":"Quand c'est possible, la locale de l'utilisateur (langue / r\u00e9gion) est import\u00e9e de celle de son compte. Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en Fran\u00e7ais, le Fran\u00e7ais sera automatiquement s\u00e9lectionn\u00e9 par Tock. S'il n'y a pas d'indication de locale, c'est la locale par d\u00e9faut de Tock qui est utilis\u00e9e. Un d\u00e9veloppeur peut modifier la locale de l'utilisateur dans le code du bot lui-m\u00eame : userPreferences . locale = Locale . FRENCH Enfin, la locale par d\u00e9faut peut \u00eatre modifi\u00e9e par un administrateur de la plateforme, en passant la propri\u00e9t\u00e9 Syst\u00e8me -Dtock_default_locale=fr au d\u00e9marrage de la JVM.","title":"Langue et locale utilisateur"},{"location":"user/guides/i18n/#traduire-et-faire-varier-les-reponses-du-bot","text":"Dans Tock Studio , la section Stories & Answers > Answers permet de g\u00e9rer les libell\u00e9s des r\u00e9ponses du bot. Voir Le menu Stories & Answers . Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot. Il est possible de concevoir et configurer diff\u00e9rentes variantes : En fonction de la langue En fonction du canal / connecteur Par exemple, certains canaux requi\u00e8rent des libell\u00e9s sp\u00e9cifiques, soit parce que le propri\u00e9taire du canal l'exige (sur Alexa le vouvoiement est requis), soit parce que l'exp\u00e9rience utilisateur diff\u00e8re des autres canaux (par exemple en vocal on \u00e9vitera de trop longues phrases). Al\u00e9atoirement (pour que le bot ne r\u00e9ponde pas toujours la m\u00eame chose)","title":"Traduire et faire varier les r\u00e9ponses du bot"},{"location":"user/guides/i18n/#traduire-massivement-les-modeles-et-reponses","text":"Des fonctionnalit\u00e9s sont \u00e0 l'\u00e9tude pour permettre la traduction plus ou moins automatis\u00e9e de nombreuses phrases utilisateur (corpus / mod\u00e8le conversationnel) et r\u00e9ponses (libell\u00e9s / i18n). A suivre... Pour le moment, pour envisager une traduction de masse, on peut par exemple : Exporter les donn\u00e9es en JSON ou CSV avec Tock Studio Traduire les phrases/r\u00e9ponses en dehors de Tock (API SaaS, agence...) Importer les traductions avec Tock Studio Remarque : au moment de l'import seuls les libell\u00e9s marqu\u00e9s valid\u00e9s sont pris en compte.","title":"Traduire massivement les mod\u00e8les et r\u00e9ponses"},{"location":"user/guides/i18n/#developper-avec-linternationalisation","text":"Le manuel d\u00e9veloppeur Tock donne plus de d\u00e9tails sur le d\u00e9veloppement des bots multilingues.","title":"D\u00e9velopper avec l'internationalisation"},{"location":"user/studio/analytics/","text":"Le menu Analytics \u00b6 Ce menu contient une s\u00e9rie d'onglets permettant de visualiser et d'analyser les cas d'utilisation du bot, des configurations, des stories et des intentions. Le menu Monitoring permet de suivre et observer les utilisateurs connect\u00e9s ainsi que les conversations. L'onglet Activity \u00b6 Cet \u00e9cran permet de suivre diff\u00e9rents indicateurs dans le temps : Nombre de messages re\u00e7us par le bot Messages par Story, Messages par Configuration, Messages par Connecteur, Etc. Un calendrier permet de d\u00e9finir la p\u00e9riode de temps \u00e0 visualiser. Chaque indicateur peut \u00eatre vu de plusieurs mani\u00e8res : Histogramme Diagramme camembert (sur la p\u00e9riode s\u00e9lectionn\u00e9e) Tableau triable Export CSV L'onglet Preferences permet de composer son propre tableau de bord, choisir ses indicateurs et les options de pr\u00e9sentations. L'onglet Behavior \u00b6 Cet \u00e9cran pr\u00e9sente d'autres indicateurs pour un p\u00e9riode d\u00e9finie, sans pour autant repr\u00e9senter leur \u00e9volution : Type de messages re\u00e7us par le bot Canaux les plus utilis\u00e9s Fr\u00e9quentation horaire Fr\u00e9quentation par jour de la semaine Etc. Un calendrier permet de d\u00e9finir la p\u00e9riode de temps \u00e0 visualiser. Chaque indicateur peut \u00eatre vu de plusieurs mani\u00e8res : Diagramme camembert (sur la p\u00e9riode s\u00e9lectionn\u00e9e) Tableau triable Export CSV L'onglet Preferences permet de composer son propre tableau de bord, choisir ses indicateurs et les options de pr\u00e9sentations. L'onglet Flow \u00b6 Cet \u00e9cran permet d'analyser le flot des intentions et des conversations : Flot des conversations ( Dynamic / User Flow ) : analyse dynamique des parcours r\u00e9ellement effectu\u00e9s par les utilisateurs Flot des intentions ( Static / Available Stories ) : analyse statique des parcours et arbres de d\u00e9cisions propos\u00e9s par le bot En d\u00e9veloppant l'interface (fl\u00e8che \u00e0 droite du cadre), de nombreux filtres apparaissent : focalisation sur une intention, transitions entrantes/sortantes, toutes les transitions ou seulement les plus repr\u00e9sentatives en termes de trafic, etc. L'onglet Users \u00b6 Cet onglet vous permet de voir les derniers utilisateurs connect\u00e9s au bot : Nombre d'utilisateurs connect\u00e9s Date du dernier \u00e9change avec un utilisateur Dernier message envoy\u00e9 Etc. En cliquant sur Display dialog , vous pouvez voir la conversation de cet utilisateur. L'onglet Search \u00b6 A l'instar de la vue Users , cette \u00e9cran permet d'observer les derni\u00e8res conversations. Il est possible de les filtrer par connecteur, intention, etc. L'onglet Preferences \u00b6 Cet \u00e9cran permet de configurer les tableaux de bords des vues Activity et Behavior , \u00e0 la fois les indicateurs/graphes \u00e0 afficher mais \u00e9galement diff\u00e9rentes options de pr\u00e9sentations : diagrammes en 3D, lissage des courbes, etc. Une action permet \u00e0 l'utilisateur de sauvegarder ses pr\u00e9f\u00e9rences. Continuer... \u00b6 Rendez-vous dans Menu Model Quality pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu Analytics"},{"location":"user/studio/analytics/#le-menu-analytics","text":"Ce menu contient une s\u00e9rie d'onglets permettant de visualiser et d'analyser les cas d'utilisation du bot, des configurations, des stories et des intentions. Le menu Monitoring permet de suivre et observer les utilisateurs connect\u00e9s ainsi que les conversations.","title":"Le menu Analytics"},{"location":"user/studio/analytics/#longlet-activity","text":"Cet \u00e9cran permet de suivre diff\u00e9rents indicateurs dans le temps : Nombre de messages re\u00e7us par le bot Messages par Story, Messages par Configuration, Messages par Connecteur, Etc. Un calendrier permet de d\u00e9finir la p\u00e9riode de temps \u00e0 visualiser. Chaque indicateur peut \u00eatre vu de plusieurs mani\u00e8res : Histogramme Diagramme camembert (sur la p\u00e9riode s\u00e9lectionn\u00e9e) Tableau triable Export CSV L'onglet Preferences permet de composer son propre tableau de bord, choisir ses indicateurs et les options de pr\u00e9sentations.","title":"L'onglet Activity"},{"location":"user/studio/analytics/#longlet-behavior","text":"Cet \u00e9cran pr\u00e9sente d'autres indicateurs pour un p\u00e9riode d\u00e9finie, sans pour autant repr\u00e9senter leur \u00e9volution : Type de messages re\u00e7us par le bot Canaux les plus utilis\u00e9s Fr\u00e9quentation horaire Fr\u00e9quentation par jour de la semaine Etc. Un calendrier permet de d\u00e9finir la p\u00e9riode de temps \u00e0 visualiser. Chaque indicateur peut \u00eatre vu de plusieurs mani\u00e8res : Diagramme camembert (sur la p\u00e9riode s\u00e9lectionn\u00e9e) Tableau triable Export CSV L'onglet Preferences permet de composer son propre tableau de bord, choisir ses indicateurs et les options de pr\u00e9sentations.","title":"L'onglet Behavior"},{"location":"user/studio/analytics/#longlet-flow","text":"Cet \u00e9cran permet d'analyser le flot des intentions et des conversations : Flot des conversations ( Dynamic / User Flow ) : analyse dynamique des parcours r\u00e9ellement effectu\u00e9s par les utilisateurs Flot des intentions ( Static / Available Stories ) : analyse statique des parcours et arbres de d\u00e9cisions propos\u00e9s par le bot En d\u00e9veloppant l'interface (fl\u00e8che \u00e0 droite du cadre), de nombreux filtres apparaissent : focalisation sur une intention, transitions entrantes/sortantes, toutes les transitions ou seulement les plus repr\u00e9sentatives en termes de trafic, etc.","title":"L'onglet Flow"},{"location":"user/studio/analytics/#longlet-users","text":"Cet onglet vous permet de voir les derniers utilisateurs connect\u00e9s au bot : Nombre d'utilisateurs connect\u00e9s Date du dernier \u00e9change avec un utilisateur Dernier message envoy\u00e9 Etc. En cliquant sur Display dialog , vous pouvez voir la conversation de cet utilisateur.","title":"L'onglet Users"},{"location":"user/studio/analytics/#longlet-search","text":"A l'instar de la vue Users , cette \u00e9cran permet d'observer les derni\u00e8res conversations. Il est possible de les filtrer par connecteur, intention, etc.","title":"L'onglet Search"},{"location":"user/studio/analytics/#longlet-preferences","text":"Cet \u00e9cran permet de configurer les tableaux de bords des vues Activity et Behavior , \u00e0 la fois les indicateurs/graphes \u00e0 afficher mais \u00e9galement diff\u00e9rentes options de pr\u00e9sentations : diagrammes en 3D, lissage des courbes, etc. Une action permet \u00e0 l'utilisateur de sauvegarder ses pr\u00e9f\u00e9rences.","title":"L'onglet Preferences"},{"location":"user/studio/analytics/#continuer","text":"Rendez-vous dans Menu Model Quality pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user/studio/configuration/","text":"Le menu Settings \u00b6 Le menu Settings permet de cr\u00e9er et param\u00e9trer les applications conversationnelles Tock (c'est-\u00e0-dire les mod\u00e8les / bots pouvant co-exister sur une plateforme). Plusieurs fonctions d'administration et de configuration des bots sont \u00e9galement disponibles via ce menu : importer/exporter une configuration, param\u00e9trer la langue, les connecteurs, etc. L'onglet Applications \u00b6 Cet \u00e9cran permet de cr\u00e9er, modifier, supprimer des applications conversationnelles Tock. Lors de la premi\u00e8re connexion \u00e0 la plateforme de d\u00e9monstration , un assistant simplifi\u00e9 permet de cr\u00e9er la premi\u00e8re application (le premier bot). Par la suite, vous pouvez passer par cet \u00e9cran pour ajouter d'autres applications. Cr\u00e9er une application \u00b6 Pour ajouter une application, cliquez sur Create New Application : Saisissez un nom / identifiant pour l'application Choisissez si le mod\u00e8le pourra inclure des entit\u00e9s voire des sous-entit\u00e9s (cf Concepts pour en savoir plus) S\u00e9lectionnez une ou plusieurs langues (voir Construire un bot multilingue pour en savoir plus) S\u00e9lectionnez un moteur NLU ( Apache OpenNLP ou Stanford CoreNLP , voir Installation pour en savoir plus) Modifier, importer et exporter une application \u00b6 Pour chaque application d\u00e9j\u00e0 cr\u00e9\u00e9e, vous pouvez par la suite : Download an application dump : t\u00e9l\u00e9charger sa configuration au format JSON : langue, mod\u00e8le intentions/entit\u00e9s, etc. Download a sentences dump : t\u00e9l\u00e9charger ses phrases qualifi\u00e9es au format JSON Edit : modifier la configuration de l'application Un formulaire permet de modifier la configuraion initiale Une section Advanced options ajoute d'autres param\u00e8tres pour les utilisateurs avertis : Upload dump : charger une configuration ou des phrases qualifi\u00e9es \u00e0 partir d'un fichier au format JSON. Seules les nouvelles intentions/phrases seront ajout\u00e9es, cette fonction ne modifie pas / ne supprime pas les intentions/phrases existantes Trigger build : d\u00e9clencher/forcer la reconstruction du mod\u00e8le NLU Engine configuration : param\u00e9trer finement le moteur NLU sous-jacent (les param\u00e8tres d\u00e9pendant du moteur utilis\u00e9, Apache OpenNLP ou Stanford CoreNLP ) Alexa Export : exporter le mod\u00e8le Tock dans un format utilisable par Alexa La fonction Upload dump (voir ci-dessus) est \u00e9galement accessible directement en bas d'\u00e9cran, permettant : Soit de modifier une application (si l' application name existe) Soit d'en cr\u00e9er/importer une nouvelle L'onglet Configurations \u00b6 Cet \u00e9cran permet d'acc\u00e9der aux connecteurs d'un bot, d'en ajouter, modifier ou supprimer. C'est aussi l\u00e0 que vous trouvez les informations pour se connecter programmatiquement. Se connecter programmatiquement au bot \u00b6 Le param\u00e9trage pour se connecter au bot programmatiquement (ie. via un programme / langage de programmation) se trouve dans cet \u00e9cran : L' API Key peut \u00eatre copi\u00e9e et embarqu\u00e9e dans le code client de la Bot API pour connecter des parcours programm\u00e9s en Kotlin ou dans un autre langage de programmation comme Javascript/Nodejs ou Python Une adresse / URL peut \u00eatre configur\u00e9e pour utiliser le mode WebHook de Bot API Pour en savoir plus sur ces param\u00e8tres et le d\u00e9veloppement de parcours, voir Bot API . G\u00e9rer les connecteurs \u00b6 La liste des connecteurs du bot est affich\u00e9e sous la clef d'API. Pour ajouter un connecteur au bot, cliquez sur Create a new Configuration . Tous les connecteurs poss\u00e8dent la configuration suivante : Configuration name : le nom/identifiant du bot Connector type : le type de canal (par exemple Messenger, Slack, etc.) Connector identifier : un identifiant pour le connecteur, unique pour le bot Relative REST path : un chemin relatif unique pour la plateforme, pour communiquer avec le bot sur ce canal. Par d\u00e9faut, le chemin est de la forme /io/{organisation}/{application}/{canal} ce qui le rend unique sur la plateforme (\u00e0 moins que deux connecteurs du m\u00eame type soient d\u00e9clar\u00e9s pour le m\u00eame bot). Chaque connecteur poss\u00e8de \u00e9galement une configuration suppl\u00e9mentaire sp\u00e9cifique \u00e0 ce type de connecteur. Ces param\u00e8tres sont dans Connector Custom Configuration . Ces param\u00e8tres sp\u00e9cifiques sont document\u00e9s avec chaque type de connecteur/canal, voir Les connecteurs . Connecteurs de test \u00b6 Pour chaque connecteur ajout\u00e9 au bot, un connecteur de test est aussi cr\u00e9\u00e9 et configur\u00e9. Il sert \u00e0 \"simuler\" le connecteur lorsqu'on teste le bot directement dans l'interface Tock Studio (menu Test > Test the bot ). Par d\u00e9faut, les connecteurs de test ne sont pas affich\u00e9s dans l'\u00e9cran Bot Configurations . Cliquez sur Display test configurations pour les voir et \u00e9ventuellement les modifier. En particulier, si vous obtenez des messages d'erreur de connexion dans la page Test the bot , n'h\u00e9sitez pas \u00e0 v\u00e9rfier la configuration de test notamment l'adresse Application base url (pour une plateforme d\u00e9ploy\u00e9e avec Docker Compose par d\u00e9faut, ce devrait \u00eatre http://bot_api:8080 avec le nom du conteneur et le port d\u00e9clar\u00e9s dans le descripteur docker-compose-bot.yml ). L'onglet Namespaces \u00b6 Cet \u00e9cran permet de g\u00e9rer un ou plusieurs espaces de nommage ou namespaces . Chaque application, chaque bot est cr\u00e9\u00e9 au sein d'un namespace. Il est possible de g\u00e9rer plusieurs namespaces, et de partager certains d'entre eux avec une \u00e9quipe ou d'autres utilisateurs Tock Studio. Pour cela, il suffit d'\u00e9diter le namespace et d'ajouter d'autres utilisateurs (en leur donnant plus ou moins de droits sur le namespace). L'onglet Log \u00b6 Cette vue permet de suivre les principales modifications de configuration applicative effectu\u00e9es par les utilisateurs via Tock Studio: cr\u00e9ation d'applications, modifications des connecteurs, imports, etc. Continuer... \u00b6 Rendez-vous dans Guides utilisateur pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu Settings"},{"location":"user/studio/configuration/#le-menu-settings","text":"Le menu Settings permet de cr\u00e9er et param\u00e9trer les applications conversationnelles Tock (c'est-\u00e0-dire les mod\u00e8les / bots pouvant co-exister sur une plateforme). Plusieurs fonctions d'administration et de configuration des bots sont \u00e9galement disponibles via ce menu : importer/exporter une configuration, param\u00e9trer la langue, les connecteurs, etc.","title":"Le menu Settings"},{"location":"user/studio/configuration/#longlet-applications","text":"Cet \u00e9cran permet de cr\u00e9er, modifier, supprimer des applications conversationnelles Tock. Lors de la premi\u00e8re connexion \u00e0 la plateforme de d\u00e9monstration , un assistant simplifi\u00e9 permet de cr\u00e9er la premi\u00e8re application (le premier bot). Par la suite, vous pouvez passer par cet \u00e9cran pour ajouter d'autres applications.","title":"L'onglet Applications"},{"location":"user/studio/configuration/#creer-une-application","text":"Pour ajouter une application, cliquez sur Create New Application : Saisissez un nom / identifiant pour l'application Choisissez si le mod\u00e8le pourra inclure des entit\u00e9s voire des sous-entit\u00e9s (cf Concepts pour en savoir plus) S\u00e9lectionnez une ou plusieurs langues (voir Construire un bot multilingue pour en savoir plus) S\u00e9lectionnez un moteur NLU ( Apache OpenNLP ou Stanford CoreNLP , voir Installation pour en savoir plus)","title":"Cr\u00e9er une application"},{"location":"user/studio/configuration/#modifier-importer-et-exporter-une-application","text":"Pour chaque application d\u00e9j\u00e0 cr\u00e9\u00e9e, vous pouvez par la suite : Download an application dump : t\u00e9l\u00e9charger sa configuration au format JSON : langue, mod\u00e8le intentions/entit\u00e9s, etc. Download a sentences dump : t\u00e9l\u00e9charger ses phrases qualifi\u00e9es au format JSON Edit : modifier la configuration de l'application Un formulaire permet de modifier la configuraion initiale Une section Advanced options ajoute d'autres param\u00e8tres pour les utilisateurs avertis : Upload dump : charger une configuration ou des phrases qualifi\u00e9es \u00e0 partir d'un fichier au format JSON. Seules les nouvelles intentions/phrases seront ajout\u00e9es, cette fonction ne modifie pas / ne supprime pas les intentions/phrases existantes Trigger build : d\u00e9clencher/forcer la reconstruction du mod\u00e8le NLU Engine configuration : param\u00e9trer finement le moteur NLU sous-jacent (les param\u00e8tres d\u00e9pendant du moteur utilis\u00e9, Apache OpenNLP ou Stanford CoreNLP ) Alexa Export : exporter le mod\u00e8le Tock dans un format utilisable par Alexa La fonction Upload dump (voir ci-dessus) est \u00e9galement accessible directement en bas d'\u00e9cran, permettant : Soit de modifier une application (si l' application name existe) Soit d'en cr\u00e9er/importer une nouvelle","title":"Modifier, importer et exporter une application"},{"location":"user/studio/configuration/#longlet-configurations","text":"Cet \u00e9cran permet d'acc\u00e9der aux connecteurs d'un bot, d'en ajouter, modifier ou supprimer. C'est aussi l\u00e0 que vous trouvez les informations pour se connecter programmatiquement.","title":"L'onglet Configurations"},{"location":"user/studio/configuration/#se-connecter-programmatiquement-au-bot","text":"Le param\u00e9trage pour se connecter au bot programmatiquement (ie. via un programme / langage de programmation) se trouve dans cet \u00e9cran : L' API Key peut \u00eatre copi\u00e9e et embarqu\u00e9e dans le code client de la Bot API pour connecter des parcours programm\u00e9s en Kotlin ou dans un autre langage de programmation comme Javascript/Nodejs ou Python Une adresse / URL peut \u00eatre configur\u00e9e pour utiliser le mode WebHook de Bot API Pour en savoir plus sur ces param\u00e8tres et le d\u00e9veloppement de parcours, voir Bot API .","title":"Se connecter programmatiquement au bot"},{"location":"user/studio/configuration/#gerer-les-connecteurs","text":"La liste des connecteurs du bot est affich\u00e9e sous la clef d'API. Pour ajouter un connecteur au bot, cliquez sur Create a new Configuration . Tous les connecteurs poss\u00e8dent la configuration suivante : Configuration name : le nom/identifiant du bot Connector type : le type de canal (par exemple Messenger, Slack, etc.) Connector identifier : un identifiant pour le connecteur, unique pour le bot Relative REST path : un chemin relatif unique pour la plateforme, pour communiquer avec le bot sur ce canal. Par d\u00e9faut, le chemin est de la forme /io/{organisation}/{application}/{canal} ce qui le rend unique sur la plateforme (\u00e0 moins que deux connecteurs du m\u00eame type soient d\u00e9clar\u00e9s pour le m\u00eame bot). Chaque connecteur poss\u00e8de \u00e9galement une configuration suppl\u00e9mentaire sp\u00e9cifique \u00e0 ce type de connecteur. Ces param\u00e8tres sont dans Connector Custom Configuration . Ces param\u00e8tres sp\u00e9cifiques sont document\u00e9s avec chaque type de connecteur/canal, voir Les connecteurs .","title":"G\u00e9rer les connecteurs"},{"location":"user/studio/configuration/#connecteurs-de-test","text":"Pour chaque connecteur ajout\u00e9 au bot, un connecteur de test est aussi cr\u00e9\u00e9 et configur\u00e9. Il sert \u00e0 \"simuler\" le connecteur lorsqu'on teste le bot directement dans l'interface Tock Studio (menu Test > Test the bot ). Par d\u00e9faut, les connecteurs de test ne sont pas affich\u00e9s dans l'\u00e9cran Bot Configurations . Cliquez sur Display test configurations pour les voir et \u00e9ventuellement les modifier. En particulier, si vous obtenez des messages d'erreur de connexion dans la page Test the bot , n'h\u00e9sitez pas \u00e0 v\u00e9rfier la configuration de test notamment l'adresse Application base url (pour une plateforme d\u00e9ploy\u00e9e avec Docker Compose par d\u00e9faut, ce devrait \u00eatre http://bot_api:8080 avec le nom du conteneur et le port d\u00e9clar\u00e9s dans le descripteur docker-compose-bot.yml ).","title":"Connecteurs de test"},{"location":"user/studio/configuration/#longlet-namespaces","text":"Cet \u00e9cran permet de g\u00e9rer un ou plusieurs espaces de nommage ou namespaces . Chaque application, chaque bot est cr\u00e9\u00e9 au sein d'un namespace. Il est possible de g\u00e9rer plusieurs namespaces, et de partager certains d'entre eux avec une \u00e9quipe ou d'autres utilisateurs Tock Studio. Pour cela, il suffit d'\u00e9diter le namespace et d'ajouter d'autres utilisateurs (en leur donnant plus ou moins de droits sur le namespace).","title":"L'onglet Namespaces"},{"location":"user/studio/configuration/#longlet-log","text":"Cette vue permet de suivre les principales modifications de configuration applicative effectu\u00e9es par les utilisateurs via Tock Studio: cr\u00e9ation d'applications, modifications des connecteurs, imports, etc.","title":"L'onglet Log"},{"location":"user/studio/configuration/#continuer","text":"Rendez-vous dans Guides utilisateur pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user/studio/general/","text":"L'interface Tock Studio \u00b6 Cette page pr\u00e9sente les caract\u00e9ristiques g\u00e9n\u00e9rales de Tock Studio . Les pages suivantes couvrent les diff\u00e9rents menus de l'application et diff\u00e9rentes fonctionnalit\u00e9s. Connexion \u00e0 l'application \u00b6 Un navigateur standard suffit pour acc\u00e9der \u00e0 Tock Studio . L'utilisateur est invit\u00e9 \u00e0 s'authentifier : Sur la plateforme Tock de d\u00e9monstration , l'utilisateur est invit\u00e9 \u00e0 s'authentifier via son compte GitHub. Celui-ci doit alors accepter que Tock acc\u00e8de \u00e0 son compte - seul l'identifiant du compte GitHub est lu par Tock. Sur une plateforme Tock par d\u00e9faut, les identifiants sont admin@app.com / password . Les identifiants par d\u00e9faut sont d\u00e9finis dans fichier source bot/admin/web/src/environments/environment.ts et il est recommand\u00e9 de les modifier. Il est aussi possible, en alternative, d'utiliser un m\u00e9canisme d'authentification en amont de l'application, par exemple via un service Apache HTTPd ou un service cloud comme AWS Cognito d'une part et un annuaire type LDAP d'autre part. Le bandeau applicatif \u00b6 En haut \u00e0 gauche de l'interface se trouvent : Un bouton permettant d'afficher (ou de masquer) les diff\u00e9rents menus Tock Studio Le nom de l'interface En haut \u00e0 droite de l'interface se trouvent : L'application / le bot couramment s\u00e9lectionn\u00e9 (utile lorsque plusieurs bots co-existent sur la plateforme) La langue couramment s\u00e9lectionn\u00e9e (utile pour tester un bot multilingue) Un lien pour se d\u00e9connecter Continuer... \u00b6 Rendez-vous dans Menu Configuration pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Interface g\u00e9n\u00e9rale"},{"location":"user/studio/general/#linterface-tock-studio","text":"Cette page pr\u00e9sente les caract\u00e9ristiques g\u00e9n\u00e9rales de Tock Studio . Les pages suivantes couvrent les diff\u00e9rents menus de l'application et diff\u00e9rentes fonctionnalit\u00e9s.","title":"L'interface Tock Studio"},{"location":"user/studio/general/#connexion-a-lapplication","text":"Un navigateur standard suffit pour acc\u00e9der \u00e0 Tock Studio . L'utilisateur est invit\u00e9 \u00e0 s'authentifier : Sur la plateforme Tock de d\u00e9monstration , l'utilisateur est invit\u00e9 \u00e0 s'authentifier via son compte GitHub. Celui-ci doit alors accepter que Tock acc\u00e8de \u00e0 son compte - seul l'identifiant du compte GitHub est lu par Tock. Sur une plateforme Tock par d\u00e9faut, les identifiants sont admin@app.com / password . Les identifiants par d\u00e9faut sont d\u00e9finis dans fichier source bot/admin/web/src/environments/environment.ts et il est recommand\u00e9 de les modifier. Il est aussi possible, en alternative, d'utiliser un m\u00e9canisme d'authentification en amont de l'application, par exemple via un service Apache HTTPd ou un service cloud comme AWS Cognito d'une part et un annuaire type LDAP d'autre part.","title":"Connexion \u00e0 l'application"},{"location":"user/studio/general/#le-bandeau-applicatif","text":"En haut \u00e0 gauche de l'interface se trouvent : Un bouton permettant d'afficher (ou de masquer) les diff\u00e9rents menus Tock Studio Le nom de l'interface En haut \u00e0 droite de l'interface se trouvent : L'application / le bot couramment s\u00e9lectionn\u00e9 (utile lorsque plusieurs bots co-existent sur la plateforme) La langue couramment s\u00e9lectionn\u00e9e (utile pour tester un bot multilingue) Un lien pour se d\u00e9connecter","title":"Le bandeau applicatif"},{"location":"user/studio/general/#continuer","text":"Rendez-vous dans Menu Configuration pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user/studio/monitoring/","text":"Le menu Monitoring \u00b6 Le menu Monitoring permet de suivre et observer les utilisateurs connect\u00e9s ainsi que les conversations. L'onglet Users \u00b6 Cet onglet vous permet de voir les derniers utilisateurs connect\u00e9s au bot : Nombre d'utilisateurs connect\u00e9s Date du dernier \u00e9change avec un utilisateur Dernier message envoy\u00e9 Etc. En cliquant sur Display dialog , vous pouvez voir la conversation de cet utilisateur. L'onglet Dialogs \u00b6 A l'instar de la vue Users , cette \u00e9cran permet d'observer les derni\u00e8res conversations. Il est possible de les filtrer par connecteur, intention, etc. Continuer... \u00b6 Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu Monitoring"},{"location":"user/studio/monitoring/#le-menu-monitoring","text":"Le menu Monitoring permet de suivre et observer les utilisateurs connect\u00e9s ainsi que les conversations.","title":"Le menu Monitoring"},{"location":"user/studio/monitoring/#longlet-users","text":"Cet onglet vous permet de voir les derniers utilisateurs connect\u00e9s au bot : Nombre d'utilisateurs connect\u00e9s Date du dernier \u00e9change avec un utilisateur Dernier message envoy\u00e9 Etc. En cliquant sur Display dialog , vous pouvez voir la conversation de cet utilisateur.","title":"L'onglet Users"},{"location":"user/studio/monitoring/#longlet-dialogs","text":"A l'instar de la vue Users , cette \u00e9cran permet d'observer les derni\u00e8res conversations. Il est possible de les filtrer par connecteur, intention, etc.","title":"L'onglet Dialogs"},{"location":"user/studio/monitoring/#continuer","text":"Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user/studio/nlu-qa/","text":"Le menu Model Quality \u00b6 Le menu Model Quality (ou NLU QA ) permet d'\u00e9valuer et de suivre dans le temps la qualit\u00e9/pertinence/performance des mod\u00e8les conversationnels. L'onglet Model Stats \u00b6 Cet \u00e9cran pr\u00e9sente des graphes pour suivre l'\u00e9volution de plusieurs indicateurs de la qualit\u00e9 du mod\u00e8le conversationnel : Pertinence : les scores des algorithmes de d\u00e9tection sur les intentions ( Intent average probability ) et sur les entit\u00e9s ( Entity average probability ) Trafic / erreurs : le nombre de sollicitations du mod\u00e8le ( Calls ) et le nombre d'erreurs ( Errors ) Performance : le temps de r\u00e9ponse du mod\u00e8le ( Average call duration ) L'onglet Intent Distance \u00b6 Les m\u00e9triques pr\u00e9sent\u00e9es en tableau dans cet page ( Occurrences et Average Diff ) permettent d'identifier les intentions plus ou moins proches dans le mod\u00e8le, notamment afin d'optimiser la mod\u00e9lisation. L'onglet Model Builds \u00b6 Cet \u00e9cran pr\u00e9sente des statistiques sur les derni\u00e8res reconstructions du mod\u00e8le. Il s'agit donc d'indications sur la performance du mod\u00e8le. L'onglet Tests Trends \u00b6 Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification, ou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles. Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire un mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le. Le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois pour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel. Pr\u00e9cision que ces tests ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents. Cet onglet donne l'\u00e9volution de la pertinence des tests partiels de mod\u00e8le. Par d\u00e9faut, les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes. Il est possible de configurer ce comportement avec la propri\u00e9t\u00e9 tock_test_model_timeframe (par d\u00e9faut : 0,5 ). L'onglet Test Intent Errors \u00b6 Cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection d'intentions (voir ci-dessus), avec le d\u00e9tails des phrases/expressions reconnues diff\u00e9remment du mod\u00e8le r\u00e9el. Dans cet exemple, aucune \"vraie\" erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. On peut toutefois constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement, avec une probabilit\u00e9 \u00e9lev\u00e9e. Pour chaque phrase il est possible via la colonne Actions de confirmer que le mod\u00e8le de base est correct (avec Validate Intent ) ou de corriger l'erreur d\u00e9tect\u00e9e ( Change The Intent ). Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le. L'onglet Test Entity Errors \u00b6 A l'instar de Intent Test Errors pour les entit\u00e9s, cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection des entit\u00e9s. Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le. Continuer... \u00b6 Rendez-vous dans Menu Settings pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu Quality"},{"location":"user/studio/nlu-qa/#le-menu-model-quality","text":"Le menu Model Quality (ou NLU QA ) permet d'\u00e9valuer et de suivre dans le temps la qualit\u00e9/pertinence/performance des mod\u00e8les conversationnels.","title":"Le menu Model Quality"},{"location":"user/studio/nlu-qa/#longlet-model-stats","text":"Cet \u00e9cran pr\u00e9sente des graphes pour suivre l'\u00e9volution de plusieurs indicateurs de la qualit\u00e9 du mod\u00e8le conversationnel : Pertinence : les scores des algorithmes de d\u00e9tection sur les intentions ( Intent average probability ) et sur les entit\u00e9s ( Entity average probability ) Trafic / erreurs : le nombre de sollicitations du mod\u00e8le ( Calls ) et le nombre d'erreurs ( Errors ) Performance : le temps de r\u00e9ponse du mod\u00e8le ( Average call duration )","title":"L'onglet Model Stats"},{"location":"user/studio/nlu-qa/#longlet-intent-distance","text":"Les m\u00e9triques pr\u00e9sent\u00e9es en tableau dans cet page ( Occurrences et Average Diff ) permettent d'identifier les intentions plus ou moins proches dans le mod\u00e8le, notamment afin d'optimiser la mod\u00e9lisation.","title":"L'onglet Intent Distance"},{"location":"user/studio/nlu-qa/#longlet-model-builds","text":"Cet \u00e9cran pr\u00e9sente des statistiques sur les derni\u00e8res reconstructions du mod\u00e8le. Il s'agit donc d'indications sur la performance du mod\u00e8le.","title":"L'onglet Model Builds"},{"location":"user/studio/nlu-qa/#longlet-tests-trends","text":"Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification, ou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles. Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire un mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le. Le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois pour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel. Pr\u00e9cision que ces tests ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents. Cet onglet donne l'\u00e9volution de la pertinence des tests partiels de mod\u00e8le. Par d\u00e9faut, les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes. Il est possible de configurer ce comportement avec la propri\u00e9t\u00e9 tock_test_model_timeframe (par d\u00e9faut : 0,5 ).","title":"L'onglet Tests Trends"},{"location":"user/studio/nlu-qa/#longlet-test-intent-errors","text":"Cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection d'intentions (voir ci-dessus), avec le d\u00e9tails des phrases/expressions reconnues diff\u00e9remment du mod\u00e8le r\u00e9el. Dans cet exemple, aucune \"vraie\" erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. On peut toutefois constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement, avec une probabilit\u00e9 \u00e9lev\u00e9e. Pour chaque phrase il est possible via la colonne Actions de confirmer que le mod\u00e8le de base est correct (avec Validate Intent ) ou de corriger l'erreur d\u00e9tect\u00e9e ( Change The Intent ). Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le.","title":"L'onglet Test Intent Errors"},{"location":"user/studio/nlu-qa/#longlet-test-entity-errors","text":"A l'instar de Intent Test Errors pour les entit\u00e9s, cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection des entit\u00e9s. Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le.","title":"L'onglet Test Entity Errors"},{"location":"user/studio/nlu-qa/#continuer","text":"Rendez-vous dans Menu Settings pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user/studio/nlu/","text":"Le menu Language Understanding \u00b6 Le menu Language Understanding (ou NLU ) permet de cr\u00e9er, modifier, enrichir les mod\u00e8les conversationnels : d\u00e9clarer des intentions et des entit\u00e9s , qualifier des phrases, etc. (voir Concepts pour en savoir plus). Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Construire les mod\u00e8les conversationnels pour une pr\u00e9sentation plus guid\u00e9e par l'usage. L'onglet New Sentence \u00b6 Cet \u00e9cran permet d'entrer des phrases et et de v\u00e9rifier quelle intention/entit\u00e9s sont d\u00e9tect\u00e9es. Saisissez une phrase et validez pour voir la d\u00e9tection r\u00e9sultant du mod\u00e8le conversationnel (en pratique : comment le bot interpr\u00e8te la phrase). S'affichent alors : Intent : l'intention reconnue Language : la langue d\u00e9tect\u00e9e Le(s) score(s) retourn\u00e9(s) par les algorithmes (selon leur niveau de confiance sur l'intention et sur les \u00e9ventuelles entit\u00e9s) Le cas \u00e9ch\u00e9ant, chaque entit\u00e9 d\u00e9tect\u00e9e avec son r\u00f4le/type et son score Il est possible de modifier tous les \u00e9l\u00e9ments d\u00e9tect\u00e9s depuis cet \u00e9cran : Pour modifier l'intention (voire en cr\u00e9er une nouvelle \u00e0 la vol\u00e9e) ou la langue d\u00e9tect\u00e9es, utilisez les champs / listes de s\u00e9lection sous la phrase Pour supprimer une entit\u00e9, utilisez le bouton \u00e0 c\u00f4t\u00e9 du score de l'entit\u00e9 Pour ajouter une entit\u00e9, s\u00e9lectionnez avec la souris un bloc de mots dansla phrase puis pr\u00e9cisez son r\u00f4le/type. Remarque : si vous avez activ\u00e9 cette option au niveau de l'application/bot, il est possible de d\u00e9clarer des sous-entit\u00e9s . Vous en apprendrez plus dans Construire les mod\u00e8les conversationnels . Les boutons et commandes suivantes sont disponibles pour la phrase dans sa globalit\u00e9 : Delete : supprime la phrase Unknown : qualifier la phrase en intention inconnue (r\u00e9ponse par d\u00e9faut) Validate : confirmer l'intention/entit\u00e9s d\u00e9tect\u00e9es et enregistrer la phrase dans le mod\u00e8le (provoquant in fine une reconstruction du mod\u00e8le, son corpus \u00e9tant enrichi de cette phrase) D'autres liens sont accessibles pour afficher les conversations contenant cette phrase, copier le contenu de la phrase, cr\u00e9er un parcours \u00e0 partir de cette phrase. L'onglet Inbox \u00b6 Cet onglet montre (avec de la pagination et quelques options d'affichage) l'ensemble des phrases re\u00e7ues par le mod\u00e8le NLU avec les intentions/entit\u00e9s/langue/scores d\u00e9tect\u00e9s. Ces phrases peuvent provenir de v\u00e9ritables utilisateurs quelques soient les canaux, d'une saisie dans l'onglet Try it ou encore d'une conversation via la page Test the bot dans Tock Studio . Lorsque vous faites des tests depuis un canal externe, n'h\u00e9sitez pas \u00e0 cliquer sur le bouton Refresh (en haut \u00e0 gauche de l'\u00e9cran) pour rafra\u00eechir la liste des phrases. Les boutons et commandes sous chaque phrase sont identiques \u00e0 ceux de l'onglet Try it (voir ci-dessus). L'onglet Search \u00b6 Cet \u00e9cran permet de faire des recherches dans l'ensemble des phrases : Inbox mais aussi phrases qualifi\u00e9es enregistr\u00e9es dans le mod\u00e8le. L'onglet Unknown \u00b6 Cet \u00e9cran permet de parcourir les phrases dont l'intention n'a pas \u00e9t\u00e9 reconnue (intention unknown ). L'onglet Intents \u00b6 Cet \u00e9cran permet de g\u00e9rer les intentions. L'onglet Entities \u00b6 Cet \u00e9cran permet de g\u00e9rer les entit\u00e9s, notamment les notions d'entit\u00e9s partag\u00e9es. L'onglet Logs \u00b6 Cet \u00e9cran pr\u00e9sente le journal complet des phrases re\u00e7ues et permet de remonter aux conversations (ie. l'ensemble des phrases re\u00e7ues et r\u00e9ponses du bot pour un utilisateur). Remarque : contrairement \u00e0 la vue Inbox , les Logs montrent les phrases re\u00e7ues m\u00eame lorsqu'elles existent d\u00e9j\u00e0 \u00e0 l'identique dans le mod\u00e8le (dans ce cas, le mod\u00e8le et les algorithmes ne sont m\u00eame pas interrog\u00e9s, la r\u00e9ponse \u00e9tant connue). Continuer... \u00b6 Rendez-vous dans Menu Stories & Answers pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu Language"},{"location":"user/studio/nlu/#le-menu-language-understanding","text":"Le menu Language Understanding (ou NLU ) permet de cr\u00e9er, modifier, enrichir les mod\u00e8les conversationnels : d\u00e9clarer des intentions et des entit\u00e9s , qualifier des phrases, etc. (voir Concepts pour en savoir plus). Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Construire les mod\u00e8les conversationnels pour une pr\u00e9sentation plus guid\u00e9e par l'usage.","title":"Le menu Language Understanding"},{"location":"user/studio/nlu/#longlet-new-sentence","text":"Cet \u00e9cran permet d'entrer des phrases et et de v\u00e9rifier quelle intention/entit\u00e9s sont d\u00e9tect\u00e9es. Saisissez une phrase et validez pour voir la d\u00e9tection r\u00e9sultant du mod\u00e8le conversationnel (en pratique : comment le bot interpr\u00e8te la phrase). S'affichent alors : Intent : l'intention reconnue Language : la langue d\u00e9tect\u00e9e Le(s) score(s) retourn\u00e9(s) par les algorithmes (selon leur niveau de confiance sur l'intention et sur les \u00e9ventuelles entit\u00e9s) Le cas \u00e9ch\u00e9ant, chaque entit\u00e9 d\u00e9tect\u00e9e avec son r\u00f4le/type et son score Il est possible de modifier tous les \u00e9l\u00e9ments d\u00e9tect\u00e9s depuis cet \u00e9cran : Pour modifier l'intention (voire en cr\u00e9er une nouvelle \u00e0 la vol\u00e9e) ou la langue d\u00e9tect\u00e9es, utilisez les champs / listes de s\u00e9lection sous la phrase Pour supprimer une entit\u00e9, utilisez le bouton \u00e0 c\u00f4t\u00e9 du score de l'entit\u00e9 Pour ajouter une entit\u00e9, s\u00e9lectionnez avec la souris un bloc de mots dansla phrase puis pr\u00e9cisez son r\u00f4le/type. Remarque : si vous avez activ\u00e9 cette option au niveau de l'application/bot, il est possible de d\u00e9clarer des sous-entit\u00e9s . Vous en apprendrez plus dans Construire les mod\u00e8les conversationnels . Les boutons et commandes suivantes sont disponibles pour la phrase dans sa globalit\u00e9 : Delete : supprime la phrase Unknown : qualifier la phrase en intention inconnue (r\u00e9ponse par d\u00e9faut) Validate : confirmer l'intention/entit\u00e9s d\u00e9tect\u00e9es et enregistrer la phrase dans le mod\u00e8le (provoquant in fine une reconstruction du mod\u00e8le, son corpus \u00e9tant enrichi de cette phrase) D'autres liens sont accessibles pour afficher les conversations contenant cette phrase, copier le contenu de la phrase, cr\u00e9er un parcours \u00e0 partir de cette phrase.","title":"L'onglet New Sentence"},{"location":"user/studio/nlu/#longlet-inbox","text":"Cet onglet montre (avec de la pagination et quelques options d'affichage) l'ensemble des phrases re\u00e7ues par le mod\u00e8le NLU avec les intentions/entit\u00e9s/langue/scores d\u00e9tect\u00e9s. Ces phrases peuvent provenir de v\u00e9ritables utilisateurs quelques soient les canaux, d'une saisie dans l'onglet Try it ou encore d'une conversation via la page Test the bot dans Tock Studio . Lorsque vous faites des tests depuis un canal externe, n'h\u00e9sitez pas \u00e0 cliquer sur le bouton Refresh (en haut \u00e0 gauche de l'\u00e9cran) pour rafra\u00eechir la liste des phrases. Les boutons et commandes sous chaque phrase sont identiques \u00e0 ceux de l'onglet Try it (voir ci-dessus).","title":"L'onglet Inbox"},{"location":"user/studio/nlu/#longlet-search","text":"Cet \u00e9cran permet de faire des recherches dans l'ensemble des phrases : Inbox mais aussi phrases qualifi\u00e9es enregistr\u00e9es dans le mod\u00e8le.","title":"L'onglet Search"},{"location":"user/studio/nlu/#longlet-unknown","text":"Cet \u00e9cran permet de parcourir les phrases dont l'intention n'a pas \u00e9t\u00e9 reconnue (intention unknown ).","title":"L'onglet Unknown"},{"location":"user/studio/nlu/#longlet-intents","text":"Cet \u00e9cran permet de g\u00e9rer les intentions.","title":"L'onglet Intents"},{"location":"user/studio/nlu/#longlet-entities","text":"Cet \u00e9cran permet de g\u00e9rer les entit\u00e9s, notamment les notions d'entit\u00e9s partag\u00e9es.","title":"L'onglet Entities"},{"location":"user/studio/nlu/#longlet-logs","text":"Cet \u00e9cran pr\u00e9sente le journal complet des phrases re\u00e7ues et permet de remonter aux conversations (ie. l'ensemble des phrases re\u00e7ues et r\u00e9ponses du bot pour un utilisateur). Remarque : contrairement \u00e0 la vue Inbox , les Logs montrent les phrases re\u00e7ues m\u00eame lorsqu'elles existent d\u00e9j\u00e0 \u00e0 l'identique dans le mod\u00e8le (dans ce cas, le mod\u00e8le et les algorithmes ne sont m\u00eame pas interrog\u00e9s, la r\u00e9ponse \u00e9tant connue).","title":"L'onglet Logs"},{"location":"user/studio/nlu/#continuer","text":"Rendez-vous dans Menu Stories & Answers pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user/studio/stories-and-answers/","text":"Le menu Stories and Answers \u00b6 Le menu permet de construire des parcours et des r\u00e9ponses aux phrases de l'utilisateur. Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Cr\u00e9er son premier bot avec Tock Studio pour un exemple de cr\u00e9ation de parcours ou Construire un bot multilingue pour l'utilisation de l'onglet Answers . L'onglet New Story \u00b6 Cr\u00e9er une r\u00e9ponse simple \u00b6 Le guide Cr\u00e9er son premier bot avec Tock Studio pr\u00e9sente un exemple de cr\u00e9ation de parcours avec une r\u00e9ponse simple via New Story . L'onglet Test > Test the bot permet ensuite de rapidement v\u00e9rifier le comportement du bot sur ce parcours. Cr\u00e9er des r\u00e9ponses complexes \u00b6 Il est possible d'indiquer plusieurs r\u00e9ponses et \u00e9galement des r\u00e9ponses \"riches\" appel\u00e9es Media Message . Cela permet, quel que soit le canal d'afficher des images, des titres, des sous-titres et des boutons d'action. Entit\u00e9s obligatoires \u00b6 Il est possible, avant d'afficher la r\u00e9ponse principale, de v\u00e9rifier si certaines entit\u00e9es sont renseign\u00e9es, et si ce n'est pas le cas, d'afficher la question ad\u00e9quate. L'option correspondante est appell\u00e9e Mandatory Entities . Par exemple, supposons que nous ayons besoin de conna\u00eetre la destination de l'utilisateur. Si il ne l'a pas d\u00e9j\u00e0 indiqu\u00e9e, le bot devrait lui demander \"Pour quelle destination ?\". Actions \u00b6 Les actions sont pr\u00e9sent\u00e9es comme des suggestions, quand le canal le permet. Il est possible de pr\u00e9senter une arborescence d'actions pour construire un arbre de d\u00e9cision. L'onglet Stories \u00b6 Cet \u00e9cran permet de parcourir et g\u00e9rer les parcours ou stories cr\u00e9\u00e9es. Il peut s'agir des parcours configur\u00e9s via Tock Studio (ie. avec l'onglet New Story ) mais aussi les parcours d\u00e9clar\u00e9s programmatiquement via Bot API . Pour voir ces derniers, d\u00e9cochez l'option Only Configured Stories . L'onglet Rules \u00b6 Cet onglet contient les sections suivantes : Tagged Stories Cette section permet de visualiser les different stories qui ont une fonction particuli\u00e8re en fonction des tags avec lesquelles elles sont configur\u00e9es. On peut donc identifier les types suivants : Les stories de d\u00e9sactivation du bot qui sont tagu\u00e9es avec le tag DISABLE Les stories de r\u00e9activation du bot qui sont tagu\u00e9es avec le tag ENABLE Story Rules Cette section permet de cr\u00e9er ou modifier des r\u00e8gles de d\u00e9sactivation ou de redirection sur les stories. Application Features Cette section permet de g\u00e9rer des fonctions activables ou d\u00e9sactivables via l'interface (ou Feature Flipping ). L'onglet Answers \u00b6 Cet onglet permet de modifier les r\u00e9ponses du bot, dynamiquement selon plusieurs crit\u00e8res possibles : La langue (c'est ce qu'on appelle internationalisation ou i18n ) Le canal (textuel ou vocal), c'est-\u00e0-dire en pratique le connecteur Selon un roulement : il est possible d'enregistrer plusieurs textes de r\u00e9ponse pour un m\u00eame label dans une m\u00eame langue sur un m\u00eame connecteur - le bot r\u00e9pondra alors al\u00e9atoirement l'un de ces textes, puis effectuera un roulement afin de ne pas toujours r\u00e9pondre la m\u00eame chose. Cela permet de rendre le bot plus agr\u00e9able en variant ses r\u00e9ponses. Voir aussi Construire un bot multilingue pour l'utilisation de l'onglet Responses mais aussi les aspects d\u00e9veloppement sur ce th\u00e8me. Continuer... \u00b6 Rendez-vous dans Menu Test pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu Stories"},{"location":"user/studio/stories-and-answers/#le-menu-stories-and-answers","text":"Le menu permet de construire des parcours et des r\u00e9ponses aux phrases de l'utilisateur. Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Cr\u00e9er son premier bot avec Tock Studio pour un exemple de cr\u00e9ation de parcours ou Construire un bot multilingue pour l'utilisation de l'onglet Answers .","title":"Le menu Stories and Answers"},{"location":"user/studio/stories-and-answers/#longlet-new-story","text":"","title":"L'onglet New Story"},{"location":"user/studio/stories-and-answers/#creer-une-reponse-simple","text":"Le guide Cr\u00e9er son premier bot avec Tock Studio pr\u00e9sente un exemple de cr\u00e9ation de parcours avec une r\u00e9ponse simple via New Story . L'onglet Test > Test the bot permet ensuite de rapidement v\u00e9rifier le comportement du bot sur ce parcours.","title":"Cr\u00e9er une r\u00e9ponse simple"},{"location":"user/studio/stories-and-answers/#creer-des-reponses-complexes","text":"Il est possible d'indiquer plusieurs r\u00e9ponses et \u00e9galement des r\u00e9ponses \"riches\" appel\u00e9es Media Message . Cela permet, quel que soit le canal d'afficher des images, des titres, des sous-titres et des boutons d'action.","title":"Cr\u00e9er des r\u00e9ponses complexes"},{"location":"user/studio/stories-and-answers/#entites-obligatoires","text":"Il est possible, avant d'afficher la r\u00e9ponse principale, de v\u00e9rifier si certaines entit\u00e9es sont renseign\u00e9es, et si ce n'est pas le cas, d'afficher la question ad\u00e9quate. L'option correspondante est appell\u00e9e Mandatory Entities . Par exemple, supposons que nous ayons besoin de conna\u00eetre la destination de l'utilisateur. Si il ne l'a pas d\u00e9j\u00e0 indiqu\u00e9e, le bot devrait lui demander \"Pour quelle destination ?\".","title":"Entit\u00e9s obligatoires"},{"location":"user/studio/stories-and-answers/#actions","text":"Les actions sont pr\u00e9sent\u00e9es comme des suggestions, quand le canal le permet. Il est possible de pr\u00e9senter une arborescence d'actions pour construire un arbre de d\u00e9cision.","title":"Actions"},{"location":"user/studio/stories-and-answers/#longlet-stories","text":"Cet \u00e9cran permet de parcourir et g\u00e9rer les parcours ou stories cr\u00e9\u00e9es. Il peut s'agir des parcours configur\u00e9s via Tock Studio (ie. avec l'onglet New Story ) mais aussi les parcours d\u00e9clar\u00e9s programmatiquement via Bot API . Pour voir ces derniers, d\u00e9cochez l'option Only Configured Stories .","title":"L'onglet Stories"},{"location":"user/studio/stories-and-answers/#longlet-rules","text":"Cet onglet contient les sections suivantes : Tagged Stories Cette section permet de visualiser les different stories qui ont une fonction particuli\u00e8re en fonction des tags avec lesquelles elles sont configur\u00e9es. On peut donc identifier les types suivants : Les stories de d\u00e9sactivation du bot qui sont tagu\u00e9es avec le tag DISABLE Les stories de r\u00e9activation du bot qui sont tagu\u00e9es avec le tag ENABLE Story Rules Cette section permet de cr\u00e9er ou modifier des r\u00e8gles de d\u00e9sactivation ou de redirection sur les stories. Application Features Cette section permet de g\u00e9rer des fonctions activables ou d\u00e9sactivables via l'interface (ou Feature Flipping ).","title":"L'onglet Rules"},{"location":"user/studio/stories-and-answers/#longlet-answers","text":"Cet onglet permet de modifier les r\u00e9ponses du bot, dynamiquement selon plusieurs crit\u00e8res possibles : La langue (c'est ce qu'on appelle internationalisation ou i18n ) Le canal (textuel ou vocal), c'est-\u00e0-dire en pratique le connecteur Selon un roulement : il est possible d'enregistrer plusieurs textes de r\u00e9ponse pour un m\u00eame label dans une m\u00eame langue sur un m\u00eame connecteur - le bot r\u00e9pondra alors al\u00e9atoirement l'un de ces textes, puis effectuera un roulement afin de ne pas toujours r\u00e9pondre la m\u00eame chose. Cela permet de rendre le bot plus agr\u00e9able en variant ses r\u00e9ponses. Voir aussi Construire un bot multilingue pour l'utilisation de l'onglet Responses mais aussi les aspects d\u00e9veloppement sur ce th\u00e8me.","title":"L'onglet Answers"},{"location":"user/studio/stories-and-answers/#continuer","text":"Rendez-vous dans Menu Test pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user/studio/test/","text":"Le menu Test \u00b6 Le menu Test permet de tester un bot directement dans l'interface Tock Studio , ainsi que de g\u00e9rer des plans de tests automatiques. L'onglet Test the Bot \u00b6 Via ce menu, vous pouvez parler directement au bot en simulant diff\u00e9rentes langues et connecteurs. Cela permet de tester rapidement et simplement un bot dans l'interface Tock Studio , sans avoir \u00e0 utiliser de logiciels et canaux externes. L'interface reste minimale car l'objectif est de tester rapidement le bot, pas d'obtenir une v\u00e9ritable interface utilisateur ni m\u00eame un rendu identique \u00e0 celui de tel ou tel connecteur. Selon le type de messages renvoy\u00e9s par le bot et selon le connecteur utilis\u00e9, il se peut que le rendu dans l'\u00e9cran Test the bot ne soit pas satisfaisant. En effet, pour une compatibilit\u00e9 parfaite avec cet \u00e9cran, les connecteurs doivent respecter certaines r\u00e8gles d'impl\u00e9mentation. Si vous constatez qu'un certain type de message pour un connecteur donn\u00e9 n'est pas bien g\u00e9r\u00e9 dans cette interface, n'h\u00e9sitez pas \u00e0 remonter une issue GitHub . Pour parler \u00e0 un bot dans l'interface, une fois dans Test > Test the bot : V\u00e9rifiez la langue (en haut \u00e0 droite de l'interface) S\u00e9lectionnez une application/un bot S\u00e9lectionnez un connecteur \u00e0 \u00e9muler Commencez \u00e0 saisir des phrases... Voici un autre exemple avec une conversation comprenant des composants riches du connecteur Messenger, avec leur rendu dans l'interface g\u00e9n\u00e9rique Tock Studio : Pour chaque \u00e9change de messages avec le bot, la langue d\u00e9tect\u00e9e est indiqu\u00e9e. En cliquant sur View Nlp Stats vous pouvez voir le d\u00e9tail de la r\u00e9ponse du mod\u00e8le : intention, entit\u00e9s, scores, etc. L'onglet Test Plans \u00b6 Cet outil permet de cr\u00e9er et de suivre l'ex\u00e9cution de tests de conversations automatis\u00e9s, afin de v\u00e9rifier automatiquement et r\u00e9guli\u00e8rement la non-r\u00e9gression du bot. Cette partie est en plein d\u00e9veloppement et une documentation compl\u00e8te arrivera prochainement. Continuer... \u00b6 Rendez-vous dans Menu Analytics pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu Test"},{"location":"user/studio/test/#le-menu-test","text":"Le menu Test permet de tester un bot directement dans l'interface Tock Studio , ainsi que de g\u00e9rer des plans de tests automatiques.","title":"Le menu Test"},{"location":"user/studio/test/#longlet-test-the-bot","text":"Via ce menu, vous pouvez parler directement au bot en simulant diff\u00e9rentes langues et connecteurs. Cela permet de tester rapidement et simplement un bot dans l'interface Tock Studio , sans avoir \u00e0 utiliser de logiciels et canaux externes. L'interface reste minimale car l'objectif est de tester rapidement le bot, pas d'obtenir une v\u00e9ritable interface utilisateur ni m\u00eame un rendu identique \u00e0 celui de tel ou tel connecteur. Selon le type de messages renvoy\u00e9s par le bot et selon le connecteur utilis\u00e9, il se peut que le rendu dans l'\u00e9cran Test the bot ne soit pas satisfaisant. En effet, pour une compatibilit\u00e9 parfaite avec cet \u00e9cran, les connecteurs doivent respecter certaines r\u00e8gles d'impl\u00e9mentation. Si vous constatez qu'un certain type de message pour un connecteur donn\u00e9 n'est pas bien g\u00e9r\u00e9 dans cette interface, n'h\u00e9sitez pas \u00e0 remonter une issue GitHub . Pour parler \u00e0 un bot dans l'interface, une fois dans Test > Test the bot : V\u00e9rifiez la langue (en haut \u00e0 droite de l'interface) S\u00e9lectionnez une application/un bot S\u00e9lectionnez un connecteur \u00e0 \u00e9muler Commencez \u00e0 saisir des phrases... Voici un autre exemple avec une conversation comprenant des composants riches du connecteur Messenger, avec leur rendu dans l'interface g\u00e9n\u00e9rique Tock Studio : Pour chaque \u00e9change de messages avec le bot, la langue d\u00e9tect\u00e9e est indiqu\u00e9e. En cliquant sur View Nlp Stats vous pouvez voir le d\u00e9tail de la r\u00e9ponse du mod\u00e8le : intention, entit\u00e9s, scores, etc.","title":"L'onglet Test the Bot"},{"location":"user/studio/test/#longlet-test-plans","text":"Cet outil permet de cr\u00e9er et de suivre l'ex\u00e9cution de tests de conversations automatis\u00e9s, afin de v\u00e9rifier automatiquement et r\u00e9guli\u00e8rement la non-r\u00e9gression du bot. Cette partie est en plein d\u00e9veloppement et une documentation compl\u00e8te arrivera prochainement.","title":"L'onglet Test Plans"},{"location":"user/studio/test/#continuer","text":"Rendez-vous dans Menu Analytics pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."}]}